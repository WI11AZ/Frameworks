<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCWF OPM-ID Visualiseur Avanc√©</title>
    <style>
        :root {
            --color-white: rgba(255, 255, 255, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-gray-200: rgba(245, 245, 245, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-teal-700: rgba(26, 104, 115, 1);
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--color-cream-50);
            color: var(--color-slate-900);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 28px;
            margin: 0 0 8px 0;
            color: var(--color-slate-900);
        }

        .subtitle {
            color: var(--color-slate-500);
            margin: 0 0 24px 0;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        label {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-slate-900);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        select, input[type="text"] {
            padding: 10px 12px;
            border: 1px solid #d0d0d0;
            border-radius: 6px;
            font-family: var(--font-family);
            font-size: 13px;
            background-color: var(--color-white);
            color: var(--color-slate-900);
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--color-teal-500);
            box-shadow: 0 0 0 3px rgba(33, 128, 141, 0.1);
        }

        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 16px;
            background-color: var(--color-teal-500);
            color: var(--color-white);
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 150ms ease;
        }

        button:hover {
            background-color: var(--color-teal-600);
        }

        button:active {
            background-color: var(--color-teal-700);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: transparent;
            color: var(--color-teal-500);
            border: 1px solid var(--color-teal-500);
        }

        .btn-secondary:hover {
            background-color: rgba(33, 128, 141, 0.05);
        }

        .btn-ramp {
            padding: 8px 12px;
            font-size: 12px;
        }

        .btn-ramp.active {
            color: var(--color-white);
            font-weight: 700;
        }

        .btn-on-ramp.active {
            background-color: #3B82F6;
            border-color: #3B82F6;
        }

        .btn-off-ramp.active {
            background-color: #10B981;
            border-color: #10B981;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab-button {
            padding: 12px 16px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--color-slate-500);
            font-weight: 600;
            cursor: pointer;
            transition: all 150ms ease;
        }

        .tab-button.active {
            color: var(--color-teal-500);
            border-bottom-color: var(--color-teal-500);
        }

        .visualization {
            background-color: var(--color-white);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            overflow-x: auto;
        }

        .timeline {
            display: flex;
            align-items: center;
            gap: 4px;
            min-height: 60px;
            position: relative;
            padding: 20px 0;
        }

        .timeline-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 60px;
            flex-shrink: 0;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 150ms ease;
            position: relative;
            z-index: 2;
        }

        .dot[data-community="IT"] { background-color: #3B82F6; }
        .dot[data-community="CS"] { background-color: #10B981; }
        .dot[data-community="EN"] { background-color: #8B5CF6; }
        .dot[data-community="CE"] { background-color: #92400E; }
        .dot[data-community="CI"] { background-color: #F59E0B; }
        .dot[data-community="DA"] { background-color: #14B8A6; }
        .dot[data-community="SE"] { background-color: #EF4444; }
        .dot[data-community="Cx"] { background-color: #6B7280; }

        .ramps-detail-panel {
            background-color: var(--color-white);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
        }

        .ramps-detail-header {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--color-slate-900);
        }

        .ramp-entry {
            margin-bottom: 16px;
            padding: 12px;
            background-color: var(--color-gray-200);
            border-radius: 6px;
            border-left: 4px solid #e0e0e0;
        }

        .ramp-entry.on-ramp {
            border-left-color: #3B82F6;
        }

        .ramp-entry.off-ramp {
            border-left-color: #10B981;
        }

        .ramp-opm-id {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ramp-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .ramp-community {
            font-size: 11px;
            color: var(--color-slate-500);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ramp-type-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            color: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
            margin-bottom: 8px;
        }

        .ramp-type-label.on-ramp {
            background-color: #3B82F6;
        }

        .ramp-type-label.off-ramp {
            background-color: #10B981;
        }

        .selected-opm-section {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e0e0e0;
        }

        .selected-opm-section:last-child {
            border-bottom: none;
        }

        .selected-opm-title {
            font-weight: 700;
            font-size: 13px;
            color: var(--color-slate-900);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .selected-opm-title-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .ramps-subsection {
            margin-bottom: 12px;
        }

        .ramps-subsection-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-slate-500);
            margin-bottom: 8px;
        }

        .dot:hover {
            transform: scale(1.5);
            box-shadow: 0 0 8px currentColor;
        }

        .label {
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            color: var(--color-slate-900);
            word-break: break-word;
            max-width: 60px;
            line-height: 1.2;
        }

        .community-info {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-top: 24px;
            padding: 16px;
            background-color: var(--color-gray-200);
            border-radius: 6px;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .color-square {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .stats {
            display: flex;
            gap: 24px;
            margin-top: 16px;
            padding: 16px;
            background-color: var(--color-gray-200);
            border-radius: 6px;
            flex-wrap: wrap;
        }

        .stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--color-teal-500);
        }

        .stat-label {
            font-size: 12px;
            color: var(--color-slate-500);
            text-transform: uppercase;
        }

        .ramps-visualization {
            background-color: var(--color-white);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            display: none;
        }

        .ramps-visualization.active {
            display: block;
        }

        /* Styles pour la pr√©diction */
        .prediction-view {
            display: block;
        }

        .prediction-view.active {
            display: block;
        }

        .prediction-opm-item {
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }

        .prediction-opm-item:hover {
            background: #f3f4f6;
            border-color: #10B981;
        }

        .prediction-opm-item.selected {
            background: #10B981;
            color: white;
            border-color: #059669;
        }

        .ramps-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            align-items: center;
            flex-wrap: wrap;
        }

        .zoom-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .zoom-label {
            font-size: 12px;
            color: var(--color-slate-500);
            min-width: 60px;
        }

        .ramps-canvas-wrapper {
            position: relative;
            border: 1px solid #f0f0f0;
            border-radius: 6px;
            background-color: #fafafa;
            overflow: auto;
            height: 400px;
            width: 100%;
        }

        .ramps-canvas {
            display: block;
            min-width: 100%;
            min-height: 100%;
        }

        .scroll-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 4px;
            position: relative;
            margin-top: 8px;
            cursor: pointer;
        }

        .scroll-thumb {
            height: 100%;
            background-color: #3B82F6;
            border-radius: 4px;
            cursor: grab;
        }

        .scroll-thumb:active {
            cursor: grabbing;
        }

        .ramps-legend {
            display: flex;
            gap: 16px;
            margin-top: 16px;
            padding: 12px;
            background-color: var(--color-gray-200);
            border-radius: 6px;
            font-size: 12px;
            flex-wrap: wrap;
        }

        .ramps-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-line {
            width: 30px;
            height: 2px;
        }

        .legend-line.on-ramp {
            background-color: #3B82F6;
        }

        .legend-line.off-ramp {
            background-color: #10B981;
        }

        .circular-canvas-wrapper {
            position: relative;
            border: 1px solid #f0f0f0;
            border-radius: 6px;
            background-color: #fafafa;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 600px;
            width: 100%;
            overflow: auto;
            padding: 20px;
        }

        .circular-ramps-canvas {
            width: 100%;
            height: auto;
            display: block;
            margin: auto;
        }

        /* Styles pour la vue r√©seau */
        .node.faded {
            opacity: 0.2;
        }

        .node.highlighted {
            stroke-width: 3px;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
        }

        .link.faded {
            stroke-opacity: 0.1;
        }

        .link.highlighted {
            stroke: #ff6b00;
            stroke-opacity: 0.8;
            stroke-width: 2px;
        }

        .fullscreen-btn {
            padding: 8px 12px;
            font-size: 12px;
        }

        .settings-panel {
            padding: 12px;
            background-color: var(--color-gray-200);
            border-radius: 6px;
            margin-bottom: 12px;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .settings-panel div {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-panel label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 160px;
        }

        .settings-panel input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
            .timeline {
                padding: 30px 0;
            }
            .timeline-item {
                min-width: 50px;
            }
            h1 {
                font-size: 20px;
            }
        }
        .home-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 80vh;
            gap: 24px;
        }

        .home-title {
            font-size: 32px;
            font-weight: 700;
            color: var(--color-slate-900);
            margin-bottom: 8px;
            text-align: center;
        }

        .home-subtitle {
            color: var(--color-slate-500);
            font-size: 16px;
            margin-bottom: 48px;
            text-align: center;
        }

        .home-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 24px;
            width: 100%;
            max-width: 1000px;
        }

        .home-card {
            background-color: var(--color-white);
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 32px;
            cursor: pointer;
            transition: all 200ms ease;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .home-card:hover {
            border-color: var(--color-teal-500);
            box-shadow: 0 4px 16px rgba(33, 128, 141, 0.15);
            transform: translateY(-2px);
        }

        .home-card:active {
            transform: translateY(0);
        }

        .home-card-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--color-slate-900);
            margin-bottom: 12px;
        }

        .home-card-description {
            font-size: 14px;
            color: var(--color-slate-500);
            line-height: 1.5;
        }

        .main-content {
            display: none;
        }

        .main-content.active {
            display: block;
        }

        #offRampsContent .ramps-detail-left {
            display: none !important;
        }

        #onRampsContent .ramps-detail-right {
            display: none !important;
        }

        @media (max-width: 768px) {
            .home-cards {
                grid-template-columns: 1fr;
            }
            .home-title {
                font-size: 24px;
            }
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <!-- √âcran d'accueil -->
    <div id="homeScreen" class="home-screen">
        <h1 class="home-title"><img src="E1.png" alt="DCWF OPM-ID" style="height: 3em; vertical-align: middle;"></h1>
        <p class="home-subtitle">Syst√®me de visualisation et de s√©lection des parcours de carri√®re en cyberd√©fense</p>
        
        <div class="home-cards">
            <div class="home-card" onclick="openVisualizer()">
                <div class="home-card-title">üõ°Ô∏è Visualiseur Avanc√©</div>
                <div class="home-card-description">
                    Visualisation dynamique des r√¥les de travail et parcours de carri√®re avec vues lin√©aires et circulaires
                </div>
            </div>
            
            <div class="home-card" onclick="openOffRamps()">
                <div class="home-card-title">S√©lection off-ramps</div>
                <div class="home-card-description">
                    G√©rer et s√©lectionner les off-ramps (√©volutions de carri√®re)
                </div>
            </div>
            
            <div class="home-card" onclick="openOnRamps()">
                <div class="home-card-title">S√©lection on-ramps</div>
                <div class="home-card-description">
                    G√©rer et s√©lectionner les on-ramps (pr√©requis d'entr√©e)
                </div>
            </div>
            
            <div class="home-card" onclick="openPrediction()">
                <div class="home-card-title">üîÆ Pr√©diction</div>
                <div class="home-card-description">
                    Visualiser tous les chemins de carri√®re possibles √† partir d'un OPM-ID
                </div>
            </div>
        </div>
    </div>

    <!-- Contenu principal (masqu√© par d√©faut) -->
    <div id="mainContent" class="main-content">
    <div class="container">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
            <div style="flex: 1;">
                <h1 style="margin: 0 0 8px 0;"><img src="E1.png" alt="DCWF OPM-ID" style="height: 2.5em; vertical-align: middle; margin-right: 8px;">Visualiseur Avanc√©</h1>
                <p class="subtitle" style="margin: 0;">Visualisation dynamique des r√¥les de travail et parcours de carri√®re en cyberd√©fense</p>
            </div>
            <button class="btn-secondary" onclick="goHome()" style="margin-left: 16px;">üè† Accueil</button>
        </div>

        <div class="controls">
            <div class="control-group" style="flex: 1; min-width: 200px;">
                <label for="communityFilter">Filtrer par communaut√©(s)</label>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; text-transform: none; letter-spacing: normal;">
                        <input type="checkbox" id="cbAllCommunities" checked onchange="toggleAllCommunities()"> Toutes
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; text-transform: none; letter-spacing: normal;">
                        <input type="checkbox" id="cbIT" value="IT" checked onchange="updateCommunityFilter()"> IT
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; text-transform: none; letter-spacing: normal;">
                        <input type="checkbox" id="cbCS" value="CS" checked onchange="updateCommunityFilter()"> CS
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; text-transform: none; letter-spacing: normal;">
                        <input type="checkbox" id="cbEN" value="EN" checked onchange="updateCommunityFilter()"> EN
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; text-transform: none; letter-spacing: normal;">
                        <input type="checkbox" id="cbCE" value="CE" checked onchange="updateCommunityFilter()"> CE
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; text-transform: none; letter-spacing: normal;">
                        <input type="checkbox" id="cbCI" value="CI" checked onchange="updateCommunityFilter()"> CI
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; text-transform: none; letter-spacing: normal;">
                        <input type="checkbox" id="cbDA" value="DA" checked onchange="updateCommunityFilter()"> DA
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; text-transform: none; letter-spacing: normal;">
                        <input type="checkbox" id="cbSE" value="SE" checked onchange="updateCommunityFilter()"> SE
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; text-transform: none; letter-spacing: normal;">
                        <input type="checkbox" id="cbCx" value="Cx" checked onchange="updateCommunityFilter()"> Cx
                    </label>
                </div>
            </div>

            <div class="control-group" style="flex: 1; min-width: 200px;">
                <label for="sortOrder">Ordre de tri</label>
                <select id="sortOrder">
                    <option value="community">Croissant par communaut√©</option>
                    <option value="absolute">Croissant absolu (OPM-ID)</option>
                </select>
            </div>

            <div class="control-group">
                <label>&nbsp;</label>
                <div class="buttons">
                    <button onclick="selectAll()">S√©lectionner tout</button>
                    <button class="btn-secondary" onclick="deselectAll()">R√©initialiser</button>
                </div>
            </div>

            <div class="control-group">
                <label>&nbsp;</label>
                <div class="buttons">
                    <button id="btnOnRamps" class="btn-secondary btn-ramp btn-on-ramp" style="border-color: #3B82F6; color: #3B82F6;" onclick="toggleOnRamps()">üìà On-Ramps</button>
                    <button id="btnOffRamps" class="btn-secondary btn-ramp btn-off-ramp" style="border-color: #10B981; color: #10B981;" onclick="toggleOffRamps()">üìâ Off-Ramps</button>
                </div>
            </div>
        </div>

        <div class="visualization">
            <div class="timeline" id="timeline"></div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="selectedCount">0</div>
                    <div class="stat-label">S√©lectionn√©s</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="totalCount">0</div>
                    <div class="stat-label">Total</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="communityCount">0</div>
                    <div class="stat-label">Communaut√©s repr√©sent√©es</div>
                </div>
            </div>
        </div>

        <div class="community-info">
            <div class="info-item"><div class="color-square" style="background-color: #3B82F6;"></div>IT: Cyber IT</div>
            <div class="info-item"><div class="color-square" style="background-color: #10B981;"></div>CS: Cyber Security</div>
            <div class="info-item"><div class="color-square" style="background-color: #8B5CF6;"></div>EN: Cyber Enablers</div>
            <div class="info-item"><div class="color-square" style="background-color: #92400E;"></div>CE: Cyber Effects</div>
            <div class="info-item"><div class="color-square" style="background-color: #F59E0B;"></div>CI: Cyber Intelligence</div>
            <div class="info-item"><div class="color-square" style="background-color: #14B8A6;"></div>DA: Data/AI</div>
            <div class="info-item"><div class="color-square" style="background-color: #EF4444;"></div>SE: Software Engineering</div>
            <div class="info-item"><div class="color-square" style="background-color: #6B7280;"></div>Cx: TBD</div>
        </div>

        <div class="tabs" id="tabs">
            <button class="tab-button active" onclick="switchTab('linear')">üìä Vue Lin√©aire</button>
            <button class="tab-button" onclick="switchTab('circular')">üîÑ Vue Circulaire</button>
        </div>

        <div id="linearView" class="ramps-visualization active">
            <div class="ramps-controls">
                <span style="font-weight: 600;">Parcours de carri√®re (Vue Lin√©aire)</span>
                <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                    <div class="zoom-controls">
                        <button class="btn-secondary fullscreen-btn" onclick="zoomOut()">üîç ‚àí</button>
                        <span class="zoom-label"><span id="zoomLevel">100</span>%</span>
                        <button class="btn-secondary fullscreen-btn" onclick="zoomIn()">üîç +</button>
                        <button class="btn-secondary fullscreen-btn" onclick="fitToScreen()">‚ÜîÔ∏è Ajuster</button>
                    </div>
                    <button class="btn-secondary fullscreen-btn" onclick="toggleLinearCurveSettings()">‚öôÔ∏è Courbures</button>
                </div>
            </div>
            <div id="linearCurveSettingsPanel" class="settings-panel" style="display: none;">
                <div>
                    <label>Profondeur: <span id="linearDepthValue">0.8</span></label>
                    <input type="range" id="linearCurveDepthSlider" min="0.3" max="1.5" step="0.05" value="0.8" onchange="updateLinearCurveSettings()">
                </div>
                <div>
                    <label>√âcart min: <span id="linearMinGapValue">20</span>px</label>
                    <input type="range" id="linearMinGapSlider" min="5" max="50" step="5" value="20" onchange="updateLinearCurveSettings()">
                </div>
                <div>
                    <label>Modulation: <span id="linearModulationValue">0.7</span></label>
                    <input type="range" id="linearModulationSlider" min="0.2" max="1.5" step="0.1" value="0.7" onchange="updateLinearCurveSettings()">
                </div>
                <div>
                    <label>Al√©atoire: <span id="linearRandomnessValue">0</span></label>
                    <input type="range" id="linearRandomnessSlider" min="0" max="1" step="0.1" value="0" onchange="updateLinearCurveSettings()">
                </div>
            </div>
            <div class="ramps-canvas-wrapper" id="canvasWrapper">
                <svg class="ramps-canvas" id="rampsCanvas" viewBox="0 0 1200 400"></svg>
            </div>
            <div class="scroll-bar" id="scrollBar">
                <div class="scroll-thumb" id="scrollThumb" style="width: 50%;"></div>
            </div>
            <div class="ramps-legend">
                <div class="ramps-legend-item">
                    <div class="legend-line on-ramp"></div>
                    <span>On-Ramps (Pr√©requis - Entrantes Bleu)</span>
                </div>
                <div class="ramps-legend-item">
                    <div class="legend-line off-ramp"></div>
                    <span>Off-Ramps (√âvolutions - Sortantes Vert)</span>
                </div>
            </div>
        </div>

        <div id="circularView" style="display: none;">
            <div class="ramps-controls">
                <span style="font-weight: 600;">Parcours de carri√®re (Vue Circulaire) - Tous les OPM-ID</span>
                <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                    <div class="zoom-controls">
                        <button class="btn-secondary fullscreen-btn" onclick="circularZoomOut()">üîç ‚àí</button>
                        <span class="zoom-label"><span id="circularZoomLevel">100</span>%</span>
                        <button class="btn-secondary fullscreen-btn" onclick="circularZoomIn()">üîç +</button>
                        <button class="btn-secondary fullscreen-btn" onclick="circularFitToScreen()">‚ÜîÔ∏è Ajuster</button>
                    </div>
                    <button class="btn-secondary fullscreen-btn" onclick="toggleCircularCurveSettings()">‚öôÔ∏è Courbures</button>
                </div>
            </div>
            <div id="circularCurveSettingsPanel" class="settings-panel" style="display: none;">
                <div>
                    <label>Profondeur: <span id="circularDepthValue">0.65</span></label>
                    <input type="range" id="circularCurveDepthSlider" min="0.3" max="1.5" step="0.05" value="0.65" onchange="updateCircularCurveSettings()">
                </div>
                <div>
                    <label>Longueur min: <span id="circularMinLengthValue">60</span>px</label>
                    <input type="range" id="circularMinLengthSlider" min="30" max="150" step="5" value="60" onchange="updateCircularCurveSettings()">
                </div>
                <div>
                    <label>Espacement: <span id="circularSpacingValue">0.7</span></label>
                    <input type="range" id="circularSpacingSlider" min="0.2" max="1.5" step="0.1" value="0.7" onchange="updateCircularCurveSettings()">
                </div>
                <div>
                    <label>Modulation: <span id="circularModulationValue">1.0</span></label>
                    <input type="range" id="circularModulationSlider" min="0.5" max="2.0" step="0.1" value="1.0" onchange="updateCircularCurveSettings()">
                </div>
                <div>
                    <label>Al√©atoire: <span id="circularRandomnessValue">0</span></label>
                    <input type="range" id="circularRandomnessSlider" min="0" max="1" step="0.1" value="0" onchange="updateCircularCurveSettings()">
                </div>
            </div>
            <div class="circular-canvas-wrapper" id="circularCanvasWrapper">
                <svg class="circular-ramps-canvas" id="circularCanvas" width="800" height="800"></svg>
            </div>
            <div class="ramps-legend">
                <div class="ramps-legend-item">
                    <div class="legend-line on-ramp"></div>
                    <span>On-Ramps (Pr√©requis - Bleu) - Affich√©s si s√©lectionn√©s</span>
                </div>
                <div class="ramps-legend-item">
                    <div class="legend-line off-ramp"></div>
                    <span>Off-Ramps (√âvolutions - Vert) - Affich√©s si s√©lectionn√©s</span>
                </div>
            </div>
        </div>

        <div id="rampsDetailPanel" class="ramps-detail-panel" style="display: none;">
            <div class="ramps-detail-header">üìã D√©tail des On-Ramps et Off-Ramps</div>
            <div id="rampsDetailContent"></div>
        </div>

        <style>
            .ramps-detail-layout {
                display: flex;
                gap: 24px;
                margin-bottom: 24px;
            }

            .ramps-detail-section {
                flex: 1;
            }

            .ramps-detail-left {
                background-color: var(--color-white);
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 16px;
            }

            .ramps-detail-center {
                background-color: var(--color-white);
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 16px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                min-height: 300px;
            }

            .ramps-detail-right {
                background-color: var(--color-white);
                border: 1px solid #e0e0e0;
                border-radius: 8px;
                padding: 16px;
            }

            .ramps-section-title {
                font-size: 13px;
                font-weight: 600;
                color: var(--color-slate-900);
                margin-bottom: 12px;
                text-align: center;
                padding-bottom: 12px;
                border-bottom: 2px solid #e0e0e0;
            }

            .ramps-section-title.on-ramps {
                border-bottom-color: #3B82F6;
                color: #3B82F6;
            }

            .ramps-section-title.off-ramps {
                border-bottom-color: #10B981;
                color: #10B981;
            }

            .ramps-items-container {
                display: flex;
                flex-direction: column;
                gap: 8px;
                max-height: 400px;
                overflow-y: auto;
            }

            .ramps-item {
                padding: 10px;
                background-color: var(--color-gray-200);
                border-radius: 6px;
                font-size: 12px;
                border-left: 3px solid #3B82F6;
                text-align: center;
            }

            .ramps-item.off-ramps {
                border-left-color: #10B981;
            }

            .ramps-center-opm {
                text-align: center;
            }

            .ramps-center-opm-num {
                font-size: 36px;
                font-weight: 700;
                color: var(--color-teal-500);
                margin-bottom: 8px;
            }

            .ramps-center-opm-community {
                font-size: 12px;
                font-weight: 600;
                color: var(--color-slate-500);
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .ramps-center-dot {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                margin: 12px auto;
            }

            @media (max-width: 1024px) {
                .ramps-detail-layout {
                    flex-direction: column;
                    gap: 16px;
                }

                .ramps-detail-center {
                    min-height: 150px;
                }
            }
        </style>
    </div>
    </div>

    <!-- Interface S√©lection Off-Ramps -->
    <div id="offRampsContent" class="main-content">
        <div class="container">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                <div style="flex: 1;">
                    <h1 style="margin: 0 0 8px 0;"><img src="E1.png" alt="DCWF OPM-ID" style="height: 2.5em; vertical-align: middle; margin-right: 8px;">üìâ S√©lection Off-Ramps</h1>
                    <p class="subtitle" style="margin: 0;">S√©lectionnez les OPM-ID et leurs off-ramps pour visualiser les parcours</p>
                </div>
                <div style="display: flex; gap: 12px; align-items: center;">
                    <button onclick="validateOffRampsSelection()" style="padding: 12px 24px; font-size: 14px;">‚úÖ Valider la s√©lection</button>
                    <button class="btn-secondary" onclick="goHome()">üè† Accueil</button>
                </div>
            </div>

            <div id="offRampsDetailPanel" class="ramps-detail-panel" style="display: block;">
                <div class="ramps-detail-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>üìã S√©lection des OPM-ID et Off-Ramps</span>
                    <button onclick="selectAllOffRamps()" style="padding: 8px 16px; font-size: 13px; background-color: #10B981; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">‚úÖ Tout s√©lectionner</button>
                </div>
                <div id="offRampsDetailContent"></div>
            </div>

            <div id="offRampsVisualization" style="display: none;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                    <div class="tabs" id="offRampsTabs" style="margin: 0;">
                        <button class="tab-button active" onclick="switchOffRampsTab('linear')">üìä Vue Lin√©aire 1</button>
                        <button class="tab-button" onclick="switchOffRampsTab('circular')">üîÑ Vue Lin√©aire 2</button>
                        <button class="tab-button" onclick="switchOffRampsTab('circular-old')">‚≠ï Vue Circulaire 1</button>
                        <button class="tab-button" onclick="switchOffRampsTab('circular-2')">‚≠ï Vue Circulaire 2</button>
                        <button class="tab-button" onclick="switchOffRampsTab('network')">üï∏Ô∏è Vue R√©seau</button>
                    </div>
                    <button class="btn-secondary" onclick="resetOffRampsSelection()" style="padding: 10px 20px;">üîÑ Reset</button>
                </div>

                <div id="offRampsLinearView" class="ramps-visualization active">
                    <div class="ramps-controls">
                        <span style="font-weight: 600;">Parcours de carri√®re (Vue Lin√©aire 1)</span>
                        <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="offRampsZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsFitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                        </div>
                    </div>
                    <div class="ramps-canvas-wrapper" id="offRampsCanvasWrapper">
                        <svg class="ramps-canvas" id="offRampsCanvas" viewBox="0 0 1200 400"></svg>
                    </div>
                </div>

                <div id="offRampsCircularView" class="ramps-visualization" style="display: none;">
                    <div class="ramps-controls">
                        <span style="font-weight: 600;">Parcours de carri√®re (Vue Lin√©aire 2)</span>
                        <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                            <div class="zoom-controls" style="display: flex; gap: 8px; align-items: center;">
                                <span style="font-size: 12px; color: var(--color-slate-600); margin-right: 4px;">Tri:</span>
                                <button class="btn-secondary fullscreen-btn" onclick="setOffRampsCircularSort('chrono-asc')" title="Tri chronologique croissant">üìà ‚Üë</button>
                                <button class="btn-secondary fullscreen-btn" onclick="setOffRampsCircularSort('chrono-desc')" title="Tri chronologique d√©croissant">üìâ ‚Üì</button>
                                <button class="btn-secondary fullscreen-btn" onclick="setOffRampsCircularSort('by name')" title="Tri par nom">üî§ Nom</button>
                            </div>
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsCircularZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="offRampsCircularZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsCircularZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsCircularFitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                        </div>
                    </div>
                    <div class="circular-canvas-wrapper" id="offRampsCircularCanvasWrapper">
                        <svg class="circular-ramps-canvas" id="offRampsCircularCanvas" width="800" height="800"></svg>
                    </div>
                </div>

                <div id="offRampsCircularOldView" class="ramps-visualization" style="display: none;">
                    <div class="ramps-controls">
                        <span style="font-weight: 600;">Parcours de carri√®re (Vue Circulaire 1)</span>
                        <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsCircularOldZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="offRampsCircularOldZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsCircularOldZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsCircularOldFitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                        </div>
                    </div>
                    <div class="circular-canvas-wrapper" id="offRampsCircularOldCanvasWrapper">
                        <svg class="circular-ramps-canvas" id="offRampsCircularOldCanvas" width="800" height="800"></svg>
                    </div>
                </div>

                <div id="offRampsCircular2View" class="ramps-visualization" style="display: none;">
                    <div class="ramps-controls">
                        <span style="font-weight: 600;">Parcours de carri√®re (Vue Circulaire 2)</span>
                        <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsCircular2ZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="offRampsCircular2ZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsCircular2ZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsCircular2FitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                            <button class="btn-secondary fullscreen-btn" onclick="toggleOffRampsCircular2CurveSettings()">‚öôÔ∏è Courbures</button>
                        </div>
                    </div>
                    <div id="offRampsCircular2CurveSettingsPanel" class="settings-panel" style="display: none;">
                        <div class="settings-row">
                            <label>Profondeur: <span id="offRampsCircular2CurveDepthValue">0.65</span></label>
                            <input type="range" id="offRampsCircular2CurveDepthSlider" min="0.3" max="1.5" step="0.05" value="0.65" onchange="updateOffRampsCircular2CurveSettings()">
                        </div>
                        <div class="settings-row">
                            <label>Espacement: <span id="offRampsCircular2CurveSpacingValue">0.5</span></label>
                            <input type="range" id="offRampsCircular2CurveSpacingSlider" min="0.1" max="1.0" step="0.1" value="0.5" onchange="updateOffRampsCircular2CurveSettings()">
                        </div>
                        <div class="settings-row">
                            <label>Longueur min: <span id="offRampsCircular2MinCurveLengthValue">100</span></label>
                            <input type="range" id="offRampsCircular2MinCurveLengthSlider" min="50" max="200" step="10" value="100" onchange="updateOffRampsCircular2CurveSettings()">
                        </div>
                        <div class="settings-row">
                            <label>Modulation: <span id="offRampsCircular2ModulationValue">1.0</span></label>
                            <input type="range" id="offRampsCircular2ModulationSlider" min="0.5" max="2.0" step="0.1" value="1.0" onchange="updateOffRampsCircular2CurveSettings()">
                        </div>
                        <div class="settings-row">
                            <label>Al√©atoire: <span id="offRampsCircular2RandomnessValue">0</span></label>
                            <input type="range" id="offRampsCircular2RandomnessSlider" min="0" max="1" step="0.1" value="0" onchange="updateOffRampsCircular2CurveSettings()">
                        </div>
                    </div>
                    <div class="circular-canvas-wrapper" id="offRampsCircular2CanvasWrapper">
                        <svg class="circular-ramps-canvas" id="offRampsCircular2Canvas" width="800" height="800"></svg>
                    </div>
                </div>

                <div id="offRampsNetworkView" class="ramps-visualization" style="display: none;">
                    <div class="ramps-controls">
                        <div style="display: flex; align-items: center; gap: 16px; flex: 1;">
                            <span style="font-weight: 600;">Parcours de carri√®re (Vue R√©seau)</span>
                            <div id="offRampsNetworkHeaderSection" class="header-section" style="display: none;">
                                <div class="selected-role-card" style="background-color: #FEF3C7; border: 2px solid #F59E0B; border-radius: 8px; padding: 8px 16px; display: flex; align-items: center; gap: 8px;">
                                    <span style="font-weight: 700; color: #92400E;">‚≠ê Principale:</span>
                                    <span id="offRampsNetworkSelectedRole" style="font-weight: 600; color: #92400E;"></span>
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsNetworkZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="offRampsNetworkZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsNetworkZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsNetworkResetZoom()">‚ü≤ 1:1</button>
                                <button class="btn-secondary fullscreen-btn" onclick="offRampsNetworkFitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                        </div>
                    </div>
                    <div class="ramps-canvas-wrapper" id="offRampsNetworkCanvasWrapper" style="position: relative; min-height: 600px; width: 100%;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Interface Pr√©diction -->
    <div id="predictionContent" class="main-content">
        <div class="container">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                <div style="flex: 1;">
                    <h1 style="margin: 0 0 8px 0;"><img src="E1.png" alt="DCWF OPM-ID" style="height: 2.5em; vertical-align: middle; margin-right: 8px;">üîÆ Pr√©diction des Parcours</h1>
                    <p class="subtitle" style="margin: 0;">S√©lectionnez un OPM-ID pour visualiser tous les chemins de carri√®re possibles</p>
                </div>
                <div style="display: flex; gap: 12px; align-items: center;">
                    <button class="btn-secondary" onclick="goHome()">üè† Accueil</button>
                </div>
            </div>

            <div class="tabs" style="margin-bottom: 20px;">
                <button class="tab-button active" onclick="switchPredictionTab('off-ramps')">üìâ Off-Ramps</button>
                <button class="tab-button" onclick="switchPredictionTab('on-ramps')">üìà On-Ramps</button>
            </div>

            <!-- Vue Off-Ramps Pr√©diction -->
            <div id="predictionOffRampsView" class="prediction-view">
                <div style="display: flex; gap: 20px; height: calc(100vh - 200px);">
                    <!-- Liste des OPM-ID -->
                    <div style="width: 300px; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; overflow-y: auto; background: white;">
                        <h3 style="margin: 0 0 16px 0; font-size: 16px;">S√©lectionner un OPM-ID</h3>
                        <div id="predictionOffRampsList" style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- Liste g√©n√©r√©e dynamiquement -->
                        </div>
                    </div>
                    
                    <!-- Graphique de pr√©diction -->
                    <div style="flex: 1; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; overflow: hidden; background: white; position: relative;">
                        <div id="predictionOffRampsGraph" style="width: 100%; height: 100%; min-height: 500px;">
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #9ca3af;">
                                <p>S√©lectionnez un OPM-ID pour voir les chemins possibles</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Vue On-Ramps Pr√©diction -->
            <div id="predictionOnRampsView" class="prediction-view" style="display: none;">
                <div style="display: flex; gap: 20px; height: calc(100vh - 200px);">
                    <!-- Liste des OPM-ID -->
                    <div style="width: 300px; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; overflow-y: auto; background: white;">
                        <h3 style="margin: 0 0 16px 0; font-size: 16px;">S√©lectionner un OPM-ID</h3>
                        <div id="predictionOnRampsList" style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- Liste g√©n√©r√©e dynamiquement -->
                        </div>
                    </div>
                    
                    <!-- Graphique de pr√©diction -->
                    <div style="flex: 1; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; overflow: hidden; background: white; position: relative;">
                        <div id="predictionOnRampsGraph" style="width: 100%; height: 100%; min-height: 500px;">
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #9ca3af;">
                                <p>S√©lectionnez un OPM-ID pour voir les chemins possibles</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Interface S√©lection On-Ramps -->
    <div id="onRampsContent" class="main-content">
        <div class="container">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                <div style="flex: 1;">
                    <h1 style="margin: 0 0 8px 0;"><img src="E1.png" alt="DCWF OPM-ID" style="height: 2.5em; vertical-align: middle; margin-right: 8px;">üìà S√©lection On-Ramps</h1>
                    <p class="subtitle" style="margin: 0;">S√©lectionnez les OPM-ID et leurs on-ramps pour visualiser les parcours</p>
                </div>
                <div style="display: flex; gap: 12px; align-items: center;">
                    <button onclick="validateOnRampsSelection()" style="padding: 12px 24px; font-size: 14px;">‚úÖ Valider la s√©lection</button>
                    <button class="btn-secondary" onclick="goHome()">üè† Accueil</button>
                </div>
            </div>

            <div id="onRampsDetailPanel" class="ramps-detail-panel" style="display: block;">
                <div class="ramps-detail-header">üìã S√©lection des OPM-ID et On-Ramps</div>
                <div id="onRampsDetailContent"></div>
            </div>

            <div id="onRampsVisualization" style="display: none;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                    <div class="tabs" id="onRampsTabs" style="margin: 0;">
                        <button class="tab-button active" onclick="switchOnRampsTab('linear')">üìä Vue Lin√©aire 1</button>
                        <button class="tab-button" onclick="switchOnRampsTab('circular')">üîÑ Vue Lin√©aire 2</button>
                        <button class="tab-button" onclick="switchOnRampsTab('circular-old')">‚≠ï Vue Circulaire 1</button>
                        <button class="tab-button" onclick="switchOnRampsTab('circular-2')">‚≠ï Vue Circulaire 2</button>
                        <button class="tab-button" onclick="switchOnRampsTab('network')">üï∏Ô∏è Vue R√©seau</button>
                    </div>
                    <button class="btn-secondary" onclick="resetOnRampsSelection()" style="padding: 10px 20px;">üîÑ Reset</button>
                </div>

                <div id="onRampsLinearView" class="ramps-visualization active">
                    <div class="ramps-controls">
                        <span style="font-weight: 600;">Parcours de carri√®re (Vue Lin√©aire 1)</span>
                        <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="onRampsZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsFitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                        </div>
                    </div>
                    <div class="ramps-canvas-wrapper" id="onRampsCanvasWrapper">
                        <svg class="ramps-canvas" id="onRampsCanvas" viewBox="0 0 1200 400"></svg>
                    </div>
                </div>

                <div id="onRampsCircularView" class="ramps-visualization" style="display: none;">
                    <div class="ramps-controls">
                        <span style="font-weight: 600;">Parcours de carri√®re (Vue Lin√©aire 2)</span>
                        <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                            <div class="zoom-controls" style="display: flex; gap: 8px; align-items: center;">
                                <span style="font-size: 12px; color: var(--color-slate-600); margin-right: 4px;">Tri:</span>
                                <button class="btn-secondary fullscreen-btn" onclick="setOnRampsCircularSort('chrono-asc')" title="Tri chronologique croissant">üìà ‚Üë</button>
                                <button class="btn-secondary fullscreen-btn" onclick="setOnRampsCircularSort('chrono-desc')" title="Tri chronologique d√©croissant">üìâ ‚Üì</button>
                                <button class="btn-secondary fullscreen-btn" onclick="setOnRampsCircularSort('by name')" title="Tri par nom">üî§ Nom</button>
                            </div>
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsCircularZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="onRampsCircularZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsCircularZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsCircularFitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                        </div>
                    </div>
                    <div class="circular-canvas-wrapper" id="onRampsCircularCanvasWrapper">
                        <svg class="circular-ramps-canvas" id="onRampsCircularCanvas" width="800" height="800"></svg>
                    </div>
                </div>

                <div id="onRampsCircularOldView" class="ramps-visualization" style="display: none;">
                    <div class="ramps-controls">
                        <span style="font-weight: 600;">Parcours de carri√®re (Vue Circulaire 1)</span>
                        <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsCircularOldZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="onRampsCircularOldZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsCircularOldZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsCircularOldFitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                        </div>
                    </div>
                    <div class="circular-canvas-wrapper" id="onRampsCircularOldCanvasWrapper">
                        <svg class="circular-ramps-canvas" id="onRampsCircularOldCanvas" width="800" height="800"></svg>
                    </div>
                </div>

                <div id="onRampsCircular2View" class="ramps-visualization" style="display: none;">
                    <div class="ramps-controls">
                        <span style="font-weight: 600;">Parcours de carri√®re (Vue Circulaire 2)</span>
                        <div style="display: flex; gap: 12px; align-items: center; margin-left: auto; flex-wrap: wrap;">
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsCircular2ZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="onRampsCircular2ZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsCircular2ZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsCircular2FitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                            <button class="btn-secondary fullscreen-btn" onclick="toggleOnRampsCircular2CurveSettings()">‚öôÔ∏è Courbures</button>
                        </div>
                    </div>
                    <div id="onRampsCircular2CurveSettingsPanel" class="settings-panel" style="display: none;">
                        <div class="settings-row">
                            <label>Profondeur: <span id="onRampsCircular2CurveDepthValue">0.65</span></label>
                            <input type="range" id="onRampsCircular2CurveDepthSlider" min="0.3" max="1.5" step="0.05" value="0.65" onchange="updateOnRampsCircular2CurveSettings()">
                        </div>
                        <div class="settings-row">
                            <label>Espacement: <span id="onRampsCircular2CurveSpacingValue">0.5</span></label>
                            <input type="range" id="onRampsCircular2CurveSpacingSlider" min="0.1" max="1.0" step="0.1" value="0.5" onchange="updateOnRampsCircular2CurveSettings()">
                        </div>
                        <div class="settings-row">
                            <label>Longueur min: <span id="onRampsCircular2MinCurveLengthValue">100</span></label>
                            <input type="range" id="onRampsCircular2MinCurveLengthSlider" min="50" max="200" step="10" value="100" onchange="updateOnRampsCircular2CurveSettings()">
                        </div>
                        <div class="settings-row">
                            <label>Modulation: <span id="onRampsCircular2ModulationValue">1.0</span></label>
                            <input type="range" id="onRampsCircular2ModulationSlider" min="0.5" max="2.0" step="0.1" value="1.0" onchange="updateOnRampsCircular2CurveSettings()">
                        </div>
                        <div class="settings-row">
                            <label>Al√©atoire: <span id="onRampsCircular2RandomnessValue">0</span></label>
                            <input type="range" id="onRampsCircular2RandomnessSlider" min="0" max="1" step="0.1" value="0" onchange="updateOnRampsCircular2CurveSettings()">
                        </div>
                    </div>
                    <div class="circular-canvas-wrapper" id="onRampsCircular2CanvasWrapper">
                        <svg class="circular-ramps-canvas" id="onRampsCircular2Canvas" width="800" height="800"></svg>
                    </div>
                </div>

                <div id="onRampsNetworkView" class="ramps-visualization" style="display: none;">
                    <div class="ramps-controls">
                        <div style="display: flex; align-items: center; gap: 16px; flex: 1;">
                            <span style="font-weight: 600;">Parcours de carri√®re (Vue R√©seau)</span>
                            <div id="onRampsNetworkHeaderSection" class="header-section" style="display: none;">
                                <div class="selected-role-card" style="background-color: #FEF3C7; border: 2px solid #F59E0B; border-radius: 8px; padding: 8px 16px; display: flex; align-items: center; gap: 8px;">
                                    <span style="font-weight: 700; color: #92400E;">‚≠ê Principale:</span>
                                    <span id="onRampsNetworkSelectedRole" style="font-weight: 600; color: #92400E;"></span>
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                            <div class="zoom-controls">
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsNetworkZoomOut()">üîç ‚àí</button>
                                <span class="zoom-label"><span id="onRampsNetworkZoomLevel">100</span>%</span>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsNetworkZoomIn()">üîç +</button>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsNetworkResetZoom()">‚ü≤ 1:1</button>
                                <button class="btn-secondary fullscreen-btn" onclick="onRampsNetworkFitToScreen()">‚ÜîÔ∏è Ajuster</button>
                            </div>
                        </div>
                    </div>
                    <div class="ramps-canvas-wrapper" id="onRampsNetworkCanvasWrapper" style="position: relative; min-height: 600px; width: 100%;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function openVisualizer() {
            document.getElementById('homeScreen').style.display = 'none';
            document.getElementById('mainContent').classList.add('active');
            document.getElementById('offRampsContent').classList.remove('active');
            document.getElementById('onRampsContent').classList.remove('active');
        }

        function openOffRamps() {
            document.getElementById('homeScreen').style.display = 'none';
            document.getElementById('mainContent').classList.remove('active');
            document.getElementById('offRampsContent').classList.add('active');
            document.getElementById('onRampsContent').classList.remove('active');
            document.getElementById('predictionContent').classList.remove('active');
            renderOffRampsSelection();
        }

        function openOnRamps() {
            document.getElementById('homeScreen').style.display = 'none';
            document.getElementById('mainContent').classList.remove('active');
            document.getElementById('offRampsContent').classList.remove('active');
            document.getElementById('onRampsContent').classList.add('active');
            document.getElementById('predictionContent').classList.remove('active');
            renderOnRampsSelection();
        }

        function openPrediction() {
            document.getElementById('homeScreen').style.display = 'none';
            document.getElementById('mainContent').classList.remove('active');
            document.getElementById('offRampsContent').classList.remove('active');
            document.getElementById('onRampsContent').classList.remove('active');
            document.getElementById('predictionContent').classList.add('active');
            renderPredictionLists();
        }

        function goHome() {
            document.getElementById('homeScreen').style.display = 'flex';
            document.getElementById('mainContent').classList.remove('active');
            document.getElementById('offRampsContent').classList.remove('active');
            document.getElementById('onRampsContent').classList.remove('active');
            document.getElementById('predictionContent').classList.remove('active');
        }
    </script>

    <script>
        const opmData = {
            'IT': ['411', '421', '431', '441', '451', '632', '641', '651', '661', '671'],
            'CS': ['141', '212', '462', '511', '521', '531', '541', '611', '612', '622', '631', '652', '722', '723'],
            'EN': ['211', '221', '711', '712', '731', '732', '751', '752', '801', '802', '803', '804', '805', '901'],
            'CE': ['112', '121', '122', '131', '132', '133', '321', '322', '332', '333', '341', '442', '443', '463', '551'],
            'CI': ['111', '151', '311', '312', '331'],
            'DA': ['422', '423', '424', '623', '624', '653', '672', '733', '753', '902', '903'],
            'SE': ['461', '621', '625', '626', '627', '628', '673', '806'],
            'Cx': ['TBD-A', 'TBD-B']
        };

        const niceFramework = {
            '651': { on_ramps: ['652', '621', '631', '661'], off_ramps: ['652', '711', '712', '752', '901', '801'] },
            '652': { on_ramps: ['661', '631', '621', '651'], off_ramps: ['801', '901', '752', '712', '711', '651'] },
            '621': { on_ramps: ['661', '631', '651'], off_ramps: ['652', '801', '901', '752'] },
            '631': { on_ramps: ['661', '621', '651'], off_ramps: ['652', '801', '901', '712'] },
            '661': { on_ramps: ['651', '621', '631'], off_ramps: ['801', '901', '752', '711', '712'] },
            '801': { on_ramps: ['651', '652', '661', '631'], off_ramps: ['901'] },
            '901': { on_ramps: ['801', '751', '752'], off_ramps: [] },
            '711': { on_ramps: ['651', '652', '661'], off_ramps: ['712', '751', '752'] },
            '712': { on_ramps: ['651', '652', '661'], off_ramps: ['711', '751', '752'] },
            '752': { on_ramps: ['651', '652', '661', '801'], off_ramps: ['901', '751'] },
            '751': { on_ramps: ['711', '712', '752'], off_ramps: ['901'] },
            '411': { on_ramps: ['421', '431'], off_ramps: ['632', '641'] },
            '421': { on_ramps: ['411', '431'], off_ramps: ['632', '641'] },
            '431': { on_ramps: ['411', '421'], off_ramps: ['632', '641', '651'] },
            '441': { on_ramps: ['451', '641'], off_ramps: ['632', '651'] },
            '451': { on_ramps: ['441', '641'], off_ramps: ['632', '651'] },
            '632': { on_ramps: ['411', '421', '431', '441', '451'], off_ramps: ['641', '651', '661'] },
            '641': { on_ramps: ['411', '421', '431', '441', '451'], off_ramps: ['651', '661', '671'] },
            '671': { on_ramps: ['641', '651', '661'], off_ramps: [] },
            '141': { on_ramps: ['212', '511'], off_ramps: ['462', '531'] },
            '212': { on_ramps: ['141', '511'], off_ramps: ['462', '521', '531'] },
            '462': { on_ramps: ['141', '212', '511'], off_ramps: ['531', '541', '611', '612'] },
            '511': { on_ramps: ['141', '212'], off_ramps: ['521', '531', '622'] },
            '521': { on_ramps: ['212', '511'], off_ramps: ['531', '541', '622'] },
            '531': { on_ramps: ['141', '462', '212', '511'], off_ramps: ['541', '611', '612', '622'] },
            '541': { on_ramps: ['531', '462', '521'], off_ramps: ['611', '612', '622'] },
            '611': { on_ramps: ['531', '541', '462'], off_ramps: ['612', '622', '631'] },
            '612': { on_ramps: ['531', '541', '462'], off_ramps: ['611', '622', '631'] },
            '622': { on_ramps: ['531', '541', '511', '521'], off_ramps: ['611', '612', '631', '723'] },
            '631': { on_ramps: ['611', '612', '622'], off_ramps: ['651', '661'] },
            '652': { on_ramps: ['661', '631', '621', '651'], off_ramps: ['801', '901', '752', '712', '711', '651'] },
            '722': { on_ramps: ['612', '622', '611'], off_ramps: ['723', '752'] },
            '723': { on_ramps: ['722', '622', '612'], off_ramps: ['752', '801'] },
            '211': { on_ramps: ['221'], off_ramps: ['711', '712'] },
            '221': { on_ramps: ['211'], off_ramps: ['711', '712', '731'] },
            '711': { on_ramps: ['211', '221'], off_ramps: ['712', '751', '752'] },
            '712': { on_ramps: ['211', '221'], off_ramps: ['711', '751', '752'] },
            '731': { on_ramps: ['221', '732'], off_ramps: ['752', '751'] },
            '732': { on_ramps: ['731'], off_ramps: ['751', '752'] },
            '751': { on_ramps: ['711', '712', '752'], off_ramps: ['901'] },
            '752': { on_ramps: ['731', '732', '711', '712'], off_ramps: ['901', '751'] },
            '801': { on_ramps: ['802', '803', '804'], off_ramps: ['805', '901'] },
            '802': { on_ramps: ['801', '803'], off_ramps: ['804', '805'] },
            '803': { on_ramps: ['801', '802'], off_ramps: ['804', '805'] },
            '804': { on_ramps: ['801', '802', '803'], off_ramps: ['805', '901'] },
            '805': { on_ramps: ['804', '803'], off_ramps: ['901'] },
            '901': { on_ramps: ['805', '801', '752', '751'], off_ramps: [] },
            '112': { on_ramps: ['121', '122'], off_ramps: ['131', '132', '133'] },
            '121': { on_ramps: ['112', '122'], off_ramps: ['131', '132', '341'] },
            '122': { on_ramps: ['112', '121'], off_ramps: ['131', '132', '133'] },
            '131': { on_ramps: ['112', '121', '122'], off_ramps: ['132', '133', '321', '322'] },
            '132': { on_ramps: ['112', '121', '131'], off_ramps: ['133', '341', '442'] },
            '133': { on_ramps: ['112', '122', '131'], off_ramps: ['321', '322', '332', '333'] },
            '321': { on_ramps: ['131', '133'], off_ramps: ['322', '332', '341'] },
            '322': { on_ramps: ['131', '321'], off_ramps: ['332', '333', '341'] },
            '332': { on_ramps: ['133', '321', '322'], off_ramps: ['333', '341', '443'] },
            '333': { on_ramps: ['133', '322', '332'], off_ramps: ['341', '442', '443'] },
            '341': { on_ramps: ['132', '321', '322', '332'], off_ramps: ['442', '443', '551'] },
            '442': { on_ramps: ['132', '333', '341'], off_ramps: ['443', '463', '551'] },
            '443': { on_ramps: ['333', '341', '332'], off_ramps: ['463', '551'] },
            '463': { on_ramps: ['442', '443'], off_ramps: ['551'] },
            '551': { on_ramps: ['341', '442', '443', '463'], off_ramps: [] },
            '111': { on_ramps: ['151'], off_ramps: ['311', '312', '331'] },
            '151': { on_ramps: ['111'], off_ramps: ['311', '312', '331'] },
            '311': { on_ramps: ['111', '151'], off_ramps: ['312', '331'] },
            '312': { on_ramps: ['111', '151', '311'], off_ramps: ['331'] },
            '331': { on_ramps: ['151', '311', '312'], off_ramps: [] },
            '422': { on_ramps: ['423', '424'], off_ramps: ['623', '624'] },
            '423': { on_ramps: ['422', '424'], off_ramps: ['623', '624', '653'] },
            '424': { on_ramps: ['422', '423'], off_ramps: ['623', '624', '653'] },
            '623': { on_ramps: ['422', '423', '424'], off_ramps: ['624', '653', '672'] },
            '624': { on_ramps: ['422', '423', '624'], off_ramps: ['623', '653', '672'] },
            '653': { on_ramps: ['423', '424', '623', '624'], off_ramps: ['672', '733'] },
            '672': { on_ramps: ['623', '624', '653'], off_ramps: ['733', '753'] },
            '733': { on_ramps: ['653', '672'], off_ramps: ['753', '902', '903'] },
            '753': { on_ramps: ['672', '733'], off_ramps: ['902', '903'] },
            '902': { on_ramps: ['733', '753'], off_ramps: ['903'] },
            '903': { on_ramps: ['733', '753', '902'], off_ramps: [] },
            '461': { on_ramps: ['625', '626'], off_ramps: ['621', '625'] },
            '621': { on_ramps: ['461', '625', '626'], off_ramps: ['625', '626', '627', '628'] },
            '625': { on_ramps: ['461', '621'], off_ramps: ['626', '627', '628', '673'] },
            '626': { on_ramps: ['461', '621', '625'], off_ramps: ['627', '628', '673'] },
            '627': { on_ramps: ['621', '625', '626'], off_ramps: ['628', '673', '806'] },
            '628': { on_ramps: ['621', '625', '626', '627'], off_ramps: ['673'] },
            '673': { on_ramps: ['625', '626', '627', '628'], off_ramps: ['806'] },
            '806': { on_ramps: ['627', '673'], off_ramps: [] }
        };

        let selectedIds = new Set();
        let selectedCommunities = new Set();
        let currentSort = 'community';
        let detailSelectedIds = new Set();
        let showOnRamps = false;
        let showOffRamps = false;
        let currentZoom = 1;
        let circularZoom = 1;
        let currentTab = 'linear';
        let canvasWidth = 1200;
        let canvasHeight = 400;
        let linearArrowsInitialized = false;
        let circularArrowsInitialized = false;
        
        // Param√®tres de courbure circulaire
        let circularCurveDepth = 0.65;
        let circularMinCurveLength = 60;
        let circularCurveSpacing = 0.7;
        let circularModulation = 1.0;
        
        // Param√®tres de courbure lin√©aire
        let linearCurveDepth = 0.8;
        let linearMinGap = 20;
        let linearModulation = 0.7;
        let linearRandomness = 0;
        
        // Param√®tres de courbure circulaire randomness
        let circularRandomness = 0;
        
        // Cache pour la randomness (pour coh√©rence visuelle par courbe)
        let randomnessCache = new Map();

        function getAllOpmIds() {
            const ids = [];
            for (const community in opmData) {
                for (const id of opmData[community]) {
                    ids.push({ id: `${id}_${community}`, num: isNaN(parseInt(id)) ? Infinity : parseInt(id), community });
                }
            }
            return ids;
        }

        function getSortedIds() {
            let ids = getAllOpmIds();
            if (selectedCommunities.size > 0) {
                ids = ids.filter(item => selectedCommunities.has(item.community));
            }
            if (currentSort === 'absolute') {
                ids.sort((a, b) => {
                    if (a.num === Infinity && b.num === Infinity) return a.id.localeCompare(b.id);
                    if (a.num === Infinity) return 1;
                    if (b.num === Infinity) return -1;
                    return a.num - b.num;
                });
            } else {
                ids.sort((a, b) => {
                    if (a.community !== b.community) {
                        const communityOrder = ['IT', 'CS', 'EN', 'CE', 'CI', 'DA', 'SE', 'Cx'];
                        return communityOrder.indexOf(a.community) - communityOrder.indexOf(b.community);
                    }
                    if (a.num === Infinity && b.num === Infinity) return a.id.localeCompare(b.id);
                    if (a.num === Infinity) return 1;
                    if (b.num === Infinity) return -1;
                    return a.num - b.num;
                });
            }
            return ids;
        }

        function renderTimeline() {
            const timeline = document.getElementById('timeline');
            timeline.innerHTML = '';
            const ids = getSortedIds();

            ids.forEach(item => {
                const isSelected = selectedIds.has(item.id);
                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item';

                const dot = document.createElement('div');
                dot.className = `dot ${isSelected ? 'selected' : ''}`;
                dot.setAttribute('data-community', item.community);
                dot.setAttribute('data-id', item.id);
                dot.style.opacity = isSelected ? '1' : '0.6';
                dot.style.transform = isSelected ? 'scale(1.3)' : 'scale(1)';
                dot.onclick = () => toggleSelection(item.id);

                const label = document.createElement('div');
                label.className = 'label';
                label.textContent = item.id;
                label.style.fontSize = isSelected ? '12px' : '11px';
                label.style.fontWeight = isSelected ? '700' : '600';

                timelineItem.appendChild(dot);
                timelineItem.appendChild(label);
                timeline.appendChild(timelineItem);
            });

            updateStats();
            if (showOnRamps || showOffRamps) {
                renderRampsVisualization();
            }
        }

        function toggleSelection(id) {
            if (selectedIds.has(id)) {
                selectedIds.delete(id);
            } else {
                selectedIds.add(id);
            }
            renderTimeline();
        }

        function selectAll() {
            const ids = getSortedIds();
            ids.forEach(item => selectedIds.add(item.id));
            renderTimeline();
        }

        function deselectAll() {
            selectedIds.clear();
            renderTimeline();
        }

        function updateStats() {
            document.getElementById('selectedCount').textContent = selectedIds.size;
            document.getElementById('totalCount').textContent = getAllOpmIds().length;
            const communitiesInView = new Set(getSortedIds().map(item => item.community));
            document.getElementById('communityCount').textContent = communitiesInView.size;
            updateRampsDetailPanel();
        }

        function updateRampsDetailPanel() {
            const panel = document.getElementById('rampsDetailPanel');
            const content = document.getElementById('rampsDetailContent');
            
            if (selectedIds.size === 0) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            
            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };
            
            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });
            
            let html = '';
            const selectedArray = Array.from(selectedIds).sort();
            
            selectedArray.forEach(selectedId => {
                const num = selectedId.split('_')[0];
                const community = selectedId.split('_')[1];
                const communityColor = communityColors[community] || '#d0d0d0';
                
                const data = niceFramework[num];
                if (!data) return;
                
                // Partie gauche: On-Ramps
                let leftHtml = `<div class="ramps-section-title on-ramps">üìà On-Ramps</div><div class="ramps-items-container">`;
                if (data.on_ramps && data.on_ramps.length > 0) {
                    data.on_ramps.forEach(rampNum => {
                        const rampCommunity = idToCommunity[rampNum] || 'Unknown';
                        const rampColor = communityColors[rampCommunity] || '#d0d0d0';
                        const isDetailSelected = detailSelectedIds.has(`${num}_on_${rampNum}`);
                        leftHtml += `
                            <div class="ramps-item ${isDetailSelected ? 'selected' : ''}" style="cursor: pointer; ${isDetailSelected ? 'background-color: #3B82F6; color: white; border-left-color: #2563EB;' : ''}" onclick="toggleDetailSelection('${num}_on_${rampNum}')">
                                <div style="font-weight: 600; color: ${isDetailSelected ? 'white' : rampColor};">${rampNum}</div>
                                <div style="font-size: 10px; color: ${isDetailSelected ? 'rgba(255,255,255,0.7)' : 'var(--color-slate-500)'}; margin-top: 2px;">${rampCommunity}</div>
                            </div>
                        `;
                    });
                } else {
                    leftHtml += `<div style="text-align: center; color: var(--color-slate-500); padding: 16px 0;">Aucun</div>`;
                }
                leftHtml += `</div>`;
                
                // Partie centrale: OPM-ID
                const isCentralSelected = detailSelectedIds.has(`${num}_center`);
                const centerHtml = `
                    <div class="ramps-center-opm" style="cursor: pointer; ${isCentralSelected ? 'background-color: #3B82F6; padding: 16px; border-radius: 8px; color: white;' : ''}" onclick="toggleDetailSelection('${num}_center')">
                        <div class="ramps-center-dot" style="background-color: ${isCentralSelected ? 'white' : communityColor};"></div>
                        <div class="ramps-center-opm-num" style="color: ${isCentralSelected ? 'white' : 'var(--color-teal-500)'};">${num}</div>
                        <div class="ramps-center-opm-community" style="color: ${isCentralSelected ? 'rgba(255,255,255,0.7)' : 'var(--color-slate-500)'};">${community}</div>
                    </div>
                `;
                
                // Partie droite: Off-Ramps
                let rightHtml = `<div class="ramps-section-title off-ramps">üìâ Off-Ramps</div><div class="ramps-items-container">`;
                if (data.off_ramps && data.off_ramps.length > 0) {
                    data.off_ramps.forEach(rampNum => {
                        const rampCommunity = idToCommunity[rampNum] || 'Unknown';
                        const rampColor = communityColors[rampCommunity] || '#d0d0d0';
                        const isDetailSelected = detailSelectedIds.has(`${num}_off_${rampNum}`);
                        rightHtml += `
                            <div class="ramps-item off-ramps ${isDetailSelected ? 'selected' : ''}" style="cursor: pointer; ${isDetailSelected ? 'background-color: #10B981; color: white; border-left-color: #059669;' : ''}" onclick="toggleDetailSelection('${num}_off_${rampNum}')">
                                <div style="font-weight: 600; color: ${isDetailSelected ? 'white' : rampColor};">${rampNum}</div>
                                <div style="font-size: 10px; color: ${isDetailSelected ? 'rgba(255,255,255,0.7)' : 'var(--color-slate-500)'}; margin-top: 2px;">${rampCommunity}</div>
                            </div>
                        `;
                    });
                } else {
                    rightHtml += `<div style="text-align: center; color: var(--color-slate-500); padding: 16px 0;">Aucun</div>`;
                }
                rightHtml += `</div>`;
                
                html += `
                    <div class="ramps-detail-layout">
                        <div class="ramps-detail-section ramps-detail-left">
                            ${leftHtml}
                        </div>
                        <div class="ramps-detail-section ramps-detail-center">
                            ${centerHtml}
                        </div>
                        <div class="ramps-detail-section ramps-detail-right">
                            ${rightHtml}
                        </div>
                    </div>
                `;
            });
            
            content.innerHTML = html;
        }

        function toggleOnRamps() {
            if (selectedIds.size === 0) {
                alert('Veuillez s√©lectionner au moins un OPM-ID');
                return;
            }
            showOnRamps = !showOnRamps;
            updateButtonStyles();
            renderRampsVisualization();
        }

        function toggleOffRamps() {
            if (selectedIds.size === 0) {
                alert('Veuillez s√©lectionner au moins un OPM-ID');
                return;
            }
            showOffRamps = !showOffRamps;
            updateButtonStyles();
            renderRampsVisualization();
        }

        function updateButtonStyles() {
            const btnOn = document.getElementById('btnOnRamps');
            const btnOff = document.getElementById('btnOffRamps');
            
            if (showOnRamps) {
                btnOn.classList.add('active');
                btnOn.style.backgroundColor = '#3B82F6';
                btnOn.style.color = '#FFF';
            } else {
                btnOn.classList.remove('active');
                btnOn.style.backgroundColor = 'transparent';
                btnOn.style.color = '#3B82F6';
            }
            
            if (showOffRamps) {
                btnOff.classList.add('active');
                btnOff.style.backgroundColor = '#10B981';
                btnOff.style.color = '#FFF';
            } else {
                btnOff.classList.remove('active');
                btnOff.style.backgroundColor = 'transparent';
                btnOff.style.color = '#10B981';
            }
        }

        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            document.getElementById('linearView').style.display = tab === 'linear' ? 'block' : 'none';
            document.getElementById('circularView').style.display = tab === 'circular' ? 'block' : 'none';
            
            if (tab === 'circular') {
                renderCircularVisualization();
            }
        }

        function zoomIn() {
            currentZoom = Math.min(currentZoom + 0.2, 3);
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100);
            applyCanvasTransform();
        }

        function zoomOut() {
            currentZoom = Math.max(currentZoom - 0.2, 0.5);
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100);
            applyCanvasTransform();
        }

        function fitToScreen() {
            currentZoom = 1;
            document.getElementById('zoomLevel').textContent = '100';
            const wrapper = document.getElementById('canvasWrapper');
            if (wrapper) {
                wrapper.scrollLeft = 0;
                wrapper.scrollTop = 0;
            }
            applyCanvasTransform();
        }

        function applyCanvasTransform() {
            const canvas = document.getElementById('rampsCanvas');
            if (canvas) {
                const group = canvas.querySelector('g[data-transform-group]');
                if (group) {
                    group.setAttribute('transform', `scale(${currentZoom})`);
                    group.setAttribute('transform-origin', '0 0');
                }
            }
        }

        function circularZoomIn() {
            circularZoom = Math.min(circularZoom + 0.2, 3);
            document.getElementById('circularZoomLevel').textContent = Math.round(circularZoom * 100);
            renderCircularVisualization();
        }

        function circularZoomOut() {
            circularZoom = Math.max(circularZoom - 0.2, 0.5);
            document.getElementById('circularZoomLevel').textContent = Math.round(circularZoom * 100);
            renderCircularVisualization();
        }

        function circularFitToScreen() {
            circularZoom = 1;
            document.getElementById('circularZoomLevel').textContent = '100';
            renderCircularVisualization();
        }

        function toggleLinearCurveSettings() {
            const panel = document.getElementById('linearCurveSettingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'flex' : 'none';
        }

        function toggleCircularCurveSettings() {
            const panel = document.getElementById('circularCurveSettingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'flex' : 'none';
        }

        function updateLinearCurveSettings() {
            linearCurveDepth = parseFloat(document.getElementById('linearCurveDepthSlider').value);
            linearMinGap = parseInt(document.getElementById('linearMinGapSlider').value);
            linearModulation = parseFloat(document.getElementById('linearModulationSlider').value);
            linearRandomness = parseFloat(document.getElementById('linearRandomnessSlider').value);
            
            document.getElementById('linearDepthValue').textContent = linearCurveDepth.toFixed(2);
            document.getElementById('linearMinGapValue').textContent = linearMinGap;
            document.getElementById('linearModulationValue').textContent = linearModulation.toFixed(1);
            document.getElementById('linearRandomnessValue').textContent = linearRandomness.toFixed(1);
            
            randomnessCache.clear();
            renderRampsVisualization();
        }

        function updateCircularCurveSettings() {
            circularCurveDepth = parseFloat(document.getElementById('circularCurveDepthSlider').value);
            circularMinCurveLength = parseInt(document.getElementById('circularMinLengthSlider').value);
            circularCurveSpacing = parseFloat(document.getElementById('circularSpacingSlider').value);
            circularModulation = parseFloat(document.getElementById('circularModulationSlider').value);
            circularRandomness = parseFloat(document.getElementById('circularRandomnessSlider').value);
            
            document.getElementById('circularDepthValue').textContent = circularCurveDepth.toFixed(2);
            document.getElementById('circularMinLengthValue').textContent = circularMinCurveLength;
            document.getElementById('circularSpacingValue').textContent = circularCurveSpacing.toFixed(1);
            document.getElementById('circularModulationValue').textContent = circularModulation.toFixed(1);
            document.getElementById('circularRandomnessValue').textContent = circularRandomness.toFixed(1);
            
            randomnessCache.clear();
            renderCircularVisualization();
        }

        function toggleDetailSelection(key) {
            if (detailSelectedIds.has(key)) {
                detailSelectedIds.delete(key);
            } else {
                detailSelectedIds.add(key);
            }
            updateRampsDetailPanel();
            renderRampsVisualization();
            if (currentTab === 'circular') {
                renderCircularVisualization();
            }
        }

        function renderRampsVisualization() {
            if (selectedIds.size === 0) {
                return;
            }
            
            const canvas = document.getElementById('rampsCanvas');
            canvas.innerHTML = '';
            
            const ids = getSortedIds();
            const selectedArray = Array.from(selectedIds).map(id => id.split('_')[0]);
            
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('data-transform-group', 'true');
            
            const positionMap = {};
            let xPos = 40;
            ids.forEach((item) => {
                positionMap[item.id.split('_')[0]] = { x: xPos, y: 200, id: item.id };
                xPos += 60;
            });
            
            canvasWidth = Math.max(1200, xPos + 40);
            canvasHeight = 400;
            
            canvas.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
            canvas.setAttribute('width', canvasWidth);
            canvas.setAttribute('height', canvasHeight);
            
            const connections = [];
            const rampsToShow = new Set();
            
            selectedArray.forEach(selectedNum => {
                // Ajouter l'OPM-ID central s'il est s√©lectionn√© dans le d√©tail
                if (detailSelectedIds.size > 0) {
                    if (detailSelectedIds.has(`${selectedNum}_center`)) {
                        rampsToShow.add(selectedNum);
                    }
                } else {
                    // Si aucune s√©lection d√©tail, afficher tous les OPM-ID
                    rampsToShow.add(selectedNum);
                }
                
                const data = niceFramework[selectedNum];
                if (!data) return;
                
                if (showOnRamps) {
                    data.on_ramps.forEach(rampNum => {
                        if (detailSelectedIds.size === 0 || detailSelectedIds.has(`${selectedNum}_on_${rampNum}`)) {
                            rampsToShow.add(rampNum);
                            connections.push({ from: rampNum, to: selectedNum, type: 'on-ramp' });
                        }
                    });
                }
                
                if (showOffRamps) {
                    data.off_ramps.forEach(rampNum => {
                        if (detailSelectedIds.size === 0 || detailSelectedIds.has(`${selectedNum}_off_${rampNum}`)) {
                            rampsToShow.add(rampNum);
                            connections.push({ from: selectedNum, to: rampNum, type: 'off-ramp' });
                        }
                    });
                }
            });
            
            connections.forEach((conn, index) => {
                const fromPos = positionMap[conn.from];
                const toPos = positionMap[conn.to];
                if (fromPos && toPos) {
                    drawLinearArc(group, fromPos, toPos, conn.type, index, connections);
                }
            });
            
            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };
            
            ids.forEach(item => {
                const num = item.id.split('_')[0];
                const community = item.community;
                const pos = positionMap[num];
                const isSelected = selectedIds.has(item.id);
                const isRamp = rampsToShow.has(num);
                const communityColor = communityColors[community] || '#d0d0d0';
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', pos.x);
                circle.setAttribute('cy', pos.y);
                circle.setAttribute('r', isSelected ? 8 : isRamp ? 6 : 4);
                circle.setAttribute('fill', communityColor);
                circle.setAttribute('opacity', isSelected || isRamp ? 1 : 0.3);
                group.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', pos.x);
                text.setAttribute('y', pos.y + 20);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '14px');
                text.setAttribute('font-weight', '700');
                text.setAttribute('fill', communityColor);
                text.textContent = num;
                group.appendChild(text);
            });
            
            canvas.appendChild(group);
            if (!linearArrowsInitialized) {
                initArrowMarkers();
                linearArrowsInitialized = true;
            } else {
                reinitArrowMarkers();
            }
            applyCanvasTransform();
        }

        function getRandomnessForConnection(key) {
            if (!randomnessCache.has(key)) {
                const r1 = Math.random();
                const r2 = Math.random();
                const r3 = Math.random();
                randomnessCache.set(key, { lengthRand: r1, curveRand: r2, ampRand: r3 });
            }
            return randomnessCache.get(key);
        }

        function drawLinearArc(canvas, fromPos, toPos, rampType, index, allConnections) {
            const isOnRamp = rampType === 'on-ramp';
            const color = isOnRamp ? '#3B82F6' : '#10B981';
            
            const xDiff = Math.abs(toPos.x - fromPos.x);
            const gap = xDiff / 60; // nombre de positions
            
            // Calculer la profondeur d'amplitude bas√©e sur la proximit√©
            let amplitudeModifier = 1;
            if (gap <= 3) {
                // Points tr√®s proches : augmenter fortement l'amplitude
                amplitudeModifier = 2 + (3 - gap) * linearModulation;
            } else if (gap <= 5) {
                amplitudeModifier = 1.5 + (5 - gap) * 0.3;
            }
            
            // Appliquer la randomness
            const connectionKey = `${fromPos.x}-${fromPos.y}-${toPos.x}-${toPos.y}-${rampType}`;
            const randomness = getRandomnessForConnection(connectionKey);
            
            if (linearRandomness > 0) {
                // Modulation al√©atoire de la longueur (variation de position du point de contr√¥le)
                const lengthVariation = (randomness.lengthRand - 0.5) * 2 * linearRandomness * 30;
                // Modulation al√©atoire de la courbure (variation de la profondeur)
                const curveVariation = (randomness.curveRand - 0.5) * 2 * linearRandomness;
                // Modulation al√©atoire de l'amplitude
                const ampVariation = (randomness.ampRand - 0.5) * 2 * linearRandomness;
                
                amplitudeModifier *= (1 + ampVariation);
            }
            
            // Calculer l'offset vertical de base pour √©viter les chevauchements
            const baseHeight = 60 * linearCurveDepth;
            const midY = isOnRamp ? fromPos.y - baseHeight * amplitudeModifier : fromPos.y + baseHeight * amplitudeModifier;
            
            let midX = (fromPos.x + toPos.x) / 2;
            if (linearRandomness > 0) {
                const randomness2 = getRandomnessForConnection(connectionKey + '-x');
                midX += (randomness2.lengthRand - 0.5) * 2 * linearRandomness * 15;
            }
            
            const pathData = `M ${fromPos.x} ${fromPos.y} Q ${midX} ${midY} ${toPos.x} ${toPos.y}`;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', `url(#arrowhead-${rampType})`);
            path.setAttribute('opacity', '0.7');
            canvas.appendChild(path);
        }

        function renderCircularVisualization() {
            const canvas = document.getElementById('circularCanvas');
            canvas.innerHTML = '';
            circularArrowsInitialized = false;
            
            const baseSize = 800;
            const size = baseSize * circularZoom;
            const center = size / 2;
            const radius = size * 0.35;
            
            canvas.setAttribute('width', size);
            canvas.setAttribute('height', size);
            
            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bg.setAttribute('width', size);
            bg.setAttribute('height', size);
            bg.setAttribute('fill', '#fafafa');
            canvas.appendChild(bg);
            
            const allIds = getAllOpmIds();
            const positions = {};
            
            allIds.forEach((item, index) => {
                const angle = (index / allIds.length) * 2 * Math.PI - Math.PI / 2;
                const x = center + radius * Math.cos(angle);
                const y = center + radius * Math.sin(angle);
                const num = item.id.split('_')[0];
                positions[num] = { x, y, community: item.community, fullId: item.id, angle };
            });
            
            const selectedArray = Array.from(selectedIds).map(id => id.split('_')[0]);
            const allRamps = new Set();
            const connections = [];
            
            if (selectedIds.size > 0 && (showOnRamps || showOffRamps)) {
                selectedArray.forEach(selectedNum => {
                    const data = niceFramework[selectedNum];
                    if (!data) return;
                    
                    // Ajouter l'OPM-ID central s'il est s√©lectionn√© dans le d√©tail
                    if (detailSelectedIds.size > 0) {
                        if (detailSelectedIds.has(`${selectedNum}_center`)) {
                            allRamps.add(selectedNum);
                        }
                    } else {
                        // Si aucune s√©lection d√©tail, afficher tous les OPM-ID
                        allRamps.add(selectedNum);
                    }
                    
                    if (showOnRamps) {
                        data.on_ramps.forEach(rampNum => {
                            if (detailSelectedIds.size === 0 || detailSelectedIds.has(`${selectedNum}_on_${rampNum}`)) {
                                allRamps.add(rampNum);
                                connections.push({ from: rampNum, to: selectedNum, type: 'on-ramp' });
                            }
                        });
                    }
                    
                    if (showOffRamps) {
                        data.off_ramps.forEach(rampNum => {
                            if (detailSelectedIds.size === 0 || detailSelectedIds.has(`${selectedNum}_off_${rampNum}`)) {
                                allRamps.add(rampNum);
                                connections.push({ from: selectedNum, to: rampNum, type: 'off-ramp' });
                            }
                        });
                    }
                });
            }
            
            if (showOnRamps || showOffRamps) {
                connections.forEach((conn, connIndex) => {
                    const fromPos = positions[conn.from];
                    const toPos = positions[conn.to];
                    if (fromPos && toPos) {
                        const color = conn.type === 'on-ramp' ? '#3B82F6' : '#10B981';
                        const dx = toPos.x - fromPos.x;
                        const dy = toPos.y - fromPos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Calculer l'angle angulaire entre les deux points
                        const angleDiff = Math.abs(toPos.angle - fromPos.angle);
                        const normalizedAngleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                        
                        // Modulation d'amplitude bas√©e sur la proximit√© angulaire
                        let amplitudeModifier = 1;
                        if (normalizedAngleDiff < 0.1) {
                            amplitudeModifier = 1.5 + (0.1 - normalizedAngleDiff) * circularModulation * 5;
                        } else if (normalizedAngleDiff < 0.2) {
                            amplitudeModifier = 1.2 + (0.2 - normalizedAngleDiff) * 1.5;
                        }
                        
                        // Appliquer la randomness circulaire
                        const connectionKey = `circ-${conn.from}-${conn.to}-${conn.type}`;
                        const randomness = getRandomnessForConnection(connectionKey);
                        
                        if (circularRandomness > 0) {
                            const lengthVariation = (randomness.lengthRand - 0.5) * 2 * circularRandomness;
                            const curveVariation = (randomness.curveRand - 0.5) * 2 * circularRandomness;
                            const ampVariation = (randomness.ampRand - 0.5) * 2 * circularRandomness;
                            
                            amplitudeModifier *= (1 + ampVariation);
                        }
                        
                        let depthMultiplier = 1;
                        if (distance < circularMinCurveLength) {
                            depthMultiplier = 1 + (circularMinCurveLength - distance) / circularMinCurveLength * circularCurveSpacing;
                        }
                        
                        const baseRadius = Math.max(distance * 0.4, 50);
                        const curvatureRadius = baseRadius * depthMultiplier * amplitudeModifier;
                        
                        let midX = (fromPos.x + toPos.x) / 2;
                        let midY = (fromPos.y + toPos.y) / 2;
                        
                        // Appliquer variation al√©atoire aux positions du contr√¥le
                        if (circularRandomness > 0) {
                            const randomness2 = getRandomnessForConnection(connectionKey + '-mid');
                            midX += (randomness2.lengthRand - 0.5) * 2 * circularRandomness * 20;
                            midY += (randomness2.curveRand - 0.5) * 2 * circularRandomness * 20;
                        }
                        
                        const perpX = -dy / distance;
                        const perpY = dx / distance;
                        
                        const midToCenterX = center - midX;
                        const midToCenterY = center - midY;
                        const midToCenter = Math.sqrt(midToCenterX * midToCenterX + midToCenterY * midToCenterY);
                        
                        const normMidToCenterX = midToCenter > 0 ? midToCenterX / midToCenter : 0;
                        const normMidToCenterY = midToCenter > 0 ? midToCenterY / midToCenter : 0;
                        
                        const dotProduct = perpX * normMidToCenterX + perpY * normMidToCenterY;
                        const curveDir = dotProduct > 0 ? 1 : -1;
                        
                        const controlX = midX + perpX * curveDir * curvatureRadius * circularCurveDepth;
                        const controlY = midY + perpY * curveDir * curvatureRadius * circularCurveDepth;
                        
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const pathData = `M ${fromPos.x} ${fromPos.y} Q ${controlX} ${controlY} ${toPos.x} ${toPos.y}`;
                        path.setAttribute('d', pathData);
                        path.setAttribute('stroke', color);
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('opacity', '0.6');
                        path.setAttribute('marker-end', `url(#arrow-${conn.type})`);
                        canvas.appendChild(path);
                    }
                });
                
                let defs = canvas.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    canvas.insertBefore(defs, canvas.firstChild);
                }
                
                if (!canvas.querySelector('#arrow-on-ramp')) {
                    const arrowOn = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    arrowOn.setAttribute('id', 'arrow-on-ramp');
                    arrowOn.setAttribute('markerWidth', '10');
                    arrowOn.setAttribute('markerHeight', '10');
                    arrowOn.setAttribute('refX', '7');
                    arrowOn.setAttribute('refY', '3');
                    arrowOn.setAttribute('orient', 'auto');
                    const polyOn = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polyOn.setAttribute('points', '0 0, 10 3, 0 6');
                    polyOn.setAttribute('fill', '#3B82F6');
                    arrowOn.appendChild(polyOn);
                    defs.appendChild(arrowOn);
                }
                
                if (!canvas.querySelector('#arrow-off-ramp')) {
                    const arrowOff = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    arrowOff.setAttribute('id', 'arrow-off-ramp');
                    arrowOff.setAttribute('markerWidth', '10');
                    arrowOff.setAttribute('markerHeight', '10');
                    arrowOff.setAttribute('refX', '7');
                    arrowOff.setAttribute('refY', '3');
                    arrowOff.setAttribute('orient', 'auto');
                    const polyOff = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polyOff.setAttribute('points', '0 0, 10 3, 0 6');
                    polyOff.setAttribute('fill', '#10B981');
                    arrowOff.appendChild(polyOff);
                    defs.appendChild(arrowOff);
                }
            }
            
            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };
            
            allIds.forEach((item) => {
                const num = item.id.split('_')[0];
                const pos = positions[num];
                const isSelected = selectedIds.has(item.id);
                const isRamp = allRamps.has(num);
                const community = item.community;
                const baseColor = communityColors[community] || '#d0d0d0';
                
                let pointColor = baseColor;
                let pointSize = 2;
                let opacity = 0.5;
                
                if (isSelected) {
                    pointSize = 3;
                    opacity = 1;
                } else if (isRamp) {
                    pointSize = 2.5;
                    opacity = 0.9;
                }
                
                const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                point.setAttribute('cx', pos.x);
                point.setAttribute('cy', pos.y);
                point.setAttribute('r', pointSize);
                point.setAttribute('fill', pointColor);
                point.setAttribute('opacity', opacity);
                canvas.appendChild(point);
                
                const textRadius = radius + 40;
                const angle = pos.angle;
                const textX = center + textRadius * Math.cos(angle);
                const textY = center + textRadius * Math.sin(angle);
                
                const textSize = isSelected ? '13px' : isRamp ? '11px' : '10px';
                const textWeight = isSelected ? '700' : isRamp ? '600' : '400';
                const textOpacity = isSelected || isRamp ? '1' : '0.7';
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', textX);
                text.setAttribute('y', textY);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', textSize);
                text.setAttribute('font-weight', textWeight);
                text.setAttribute('fill', baseColor);
                text.setAttribute('opacity', textOpacity);
                text.textContent = num;
                canvas.appendChild(text);
                
                const communityText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                communityText.setAttribute('x', textX);
                communityText.setAttribute('y', textY + 12);
                communityText.setAttribute('text-anchor', 'middle');
                communityText.setAttribute('font-size', '9px');
                communityText.setAttribute('font-weight', '500');
                communityText.setAttribute('fill', baseColor);
                communityText.setAttribute('opacity', textOpacity);
                communityText.textContent = community;
                canvas.appendChild(communityText);
            });
        }

        function initArrowMarkers() {
            let defs = document.querySelector('#rampsCanvas defs');
            if (defs) {
                defs.remove();
            }
            
            const canvas = document.getElementById('rampsCanvas');
            const newDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            const arrowOn = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            arrowOn.setAttribute('id', 'arrowhead-on-ramp');
            arrowOn.setAttribute('markerWidth', '10');
            arrowOn.setAttribute('markerHeight', '10');
            arrowOn.setAttribute('refX', '9');
            arrowOn.setAttribute('refY', '3');
            arrowOn.setAttribute('orient', 'auto');
            const polygonOn = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygonOn.setAttribute('points', '0 0, 10 3, 0 6');
            polygonOn.setAttribute('fill', '#3B82F6');
            arrowOn.appendChild(polygonOn);
            newDefs.appendChild(arrowOn);
            
            const arrowOff = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            arrowOff.setAttribute('id', 'arrowhead-off-ramp');
            arrowOff.setAttribute('markerWidth', '10');
            arrowOff.setAttribute('markerHeight', '10');
            arrowOff.setAttribute('refX', '9');
            arrowOff.setAttribute('refY', '3');
            arrowOff.setAttribute('orient', 'auto');
            const polygonOff = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygonOff.setAttribute('points', '0 0, 10 3, 0 6');
            polygonOff.setAttribute('fill', '#10B981');
            arrowOff.appendChild(polygonOff);
            newDefs.appendChild(arrowOff);
            
            canvas.insertBefore(newDefs, canvas.firstChild);
        }

        function toggleAllCommunities() {
            const cbAll = document.getElementById('cbAllCommunities');
            const communities = ['IT', 'CS', 'EN', 'CE', 'CI', 'DA', 'SE', 'Cx'];
            
            if (cbAll.checked) {
                communities.forEach(c => {
                    document.getElementById(`cb${c}`).checked = true;
                    selectedCommunities.add(c);
                });
            } else {
                communities.forEach(c => {
                    document.getElementById(`cb${c}`).checked = false;
                    selectedCommunities.delete(c);
                });
            }
            renderTimeline();
        }

        function updateCommunityFilter() {
            selectedCommunities.clear();
            const communities = ['IT', 'CS', 'EN', 'CE', 'CI', 'DA', 'SE', 'Cx'];
            let checkedCount = 0;
            
            communities.forEach(c => {
                if (document.getElementById(`cb${c}`).checked) {
                    selectedCommunities.add(c);
                    checkedCount++;
                }
            });
            
            document.getElementById('cbAllCommunities').checked = (checkedCount === communities.length);
            renderTimeline();
        }

        document.getElementById('sortOrder').addEventListener('change', (e) => {
            currentSort = e.target.value;
            randomnessCache.clear();
            renderTimeline();
        });

        const scrollBar = document.getElementById('scrollBar');
        const scrollThumb = document.getElementById('scrollThumb');
        let isDragging = false;

        scrollBar.addEventListener('mousedown', (e) => {
            isDragging = true;
            handleScrollBarInteraction(e);
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            handleScrollBarInteraction(e);
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        function handleScrollBarInteraction(e) {
            const wrapper = document.getElementById('canvasWrapper');
            const scrollBar = document.getElementById('scrollBar');
            const canvas = document.getElementById('rampsCanvas');
            
            if (!wrapper || !canvas) return;
            
            const rect = scrollBar.getBoundingClientRect();
            const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
            const scrollPercentage = x / rect.width;
            const maxScroll = canvas.scrollWidth - wrapper.clientWidth;
            wrapper.scrollLeft = scrollPercentage * maxScroll;
        }

        // Initialisation par d√©faut
        document.getElementById('sortOrder').value = 'community';
        currentSort = 'community';
        
        // Initialiser toutes les communaut√©s comme s√©lectionn√©es
        const communities = ['IT', 'CS', 'EN', 'CE', 'CI', 'DA', 'SE', 'Cx'];
        communities.forEach(c => {
            selectedCommunities.add(c);
        });
        
        renderTimeline();

        // ========== FONCTIONS POUR S√âLECTION OFF-RAMPS ==========
        let offRampsSelectedCenters = new Set(); // Modules s√©lectionn√©s dans center
        let offRampsSelectedOffRamps = new Set(); // Paires "centerName-rampName" pour tracker les off-ramps sp√©cifiques s√©lectionn√©s
        let offRampsCurrentZoom = 1;
        let offRampsCircularZoom = 1;
        let offRampsCircularOldZoom = 1;
        let offRampsCircular2Zoom = 1;
        let offRampsCircular2CurveDepth = 0.65;
        let offRampsCircular2CurveSpacing = 0.5;
        let offRampsCircular2MinCurveLength = 100;
        let offRampsCircular2Modulation = 1.0;
        let offRampsCircular2Randomness = 0;
        let offRampsNetworkZoom = 1;
        let offRampsNetworkSimulation = null;
        let offRampsNetworkSelectedNode = null;
        let offRampsCircularSortOrder = 'by name'; // 'by name', 'chrono-asc', 'chrono-desc'
        let offRampsCurrentTab = 'linear';
        let flareData = null; // Donn√©es charg√©es depuis flare.json

        // Fonction pour charger et transformer les donn√©es de flare.json
        async function loadFlareData() {
            if (flareData) return flareData;
            
            try {
                const response = await fetch('flare.json');
                const data = await response.json();
                
                // Transformer les donn√©es en structure similaire √† niceFramework
                flareData = {};
                data.forEach(item => {
                    flareData[item.name] = {
                        off_ramps: item.imports || []
                    };
                });
                
                return flareData;
            } catch (error) {
                console.error('Erreur lors du chargement de flare.json:', error);
                return {};
            }
        }

        // Fonction pour extraire le nom court d'un module (derni√®re partie apr√®s le dernier point)
        function getShortName(fullName) {
            const parts = fullName.split('.');
            return parts[parts.length - 1];
        }

        // Fonction pour extraire la cat√©gorie d'un module (avant-derni√®re partie)
        function getCategory(fullName) {
            const parts = fullName.split('.');
            return parts.length > 2 ? parts[parts.length - 2] : 'other';
        }

        // Fonctions helper du code.txt pour la visualisation D3.js
        function hierarchy(data, delimiter = ".") {
            let root;
            const map = new Map;
            data.forEach(function find(data) {
                const {name} = data;
                if (map.has(name)) return map.get(name);
                const i = name.lastIndexOf(delimiter);
                map.set(name, data);
                if (i >= 0) {
                    find({name: name.substring(0, i), children: []}).children.push(data);
                    data.name = name.substring(i + 1);
                } else {
                    root = data;
                }
                return data;
            });
            return root;
        }

        function bilink(root) {
            const map = new Map(root.leaves().map(d => [id(d), d]));
            for (const d of root.leaves()) d.incoming = [], d.outgoing = d.data.imports.map(i => [d, map.get(i)]);
            for (const d of root.leaves()) for (const o of d.outgoing) o[1].incoming.push(o);
            return root;
        }

        function id(node) {
            return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
        }

        function renderOffRampsSelectionWithNiceFramework() {
            const content = document.getElementById('offRampsDetailContent');
            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });

            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };

            let html = '';
            const allOpmNums = Object.keys(niceFramework).sort((a, b) => {
                const aNum = isNaN(parseInt(a)) ? Infinity : parseInt(a);
                const bNum = isNaN(parseInt(b)) ? Infinity : parseInt(b);
                if (aNum === Infinity && bNum === Infinity) return a.localeCompare(b);
                if (aNum === Infinity) return 1;
                if (bNum === Infinity) return -1;
                return aNum - bNum;
            });

            allOpmNums.forEach(num => {
                const data = niceFramework[num];
                if (!data) return;

                const community = idToCommunity[num] || 'Unknown';
                const communityColor = communityColors[community] || '#d0d0d0';

                // Partie centrale: OPM-ID
                const isCenterSelected = offRampsSelectedCenters.has(num);
                const centerHtml = `
                    <div class="ramps-center-opm" style="cursor: pointer; ${isCenterSelected ? 'background-color: var(--color-teal-500); padding: 16px; border-radius: 8px; color: white;' : ''}" onclick="toggleOffRampsCenter('${num}')">
                        <div class="ramps-center-dot" style="background-color: ${isCenterSelected ? 'white' : communityColor};"></div>
                        <div class="ramps-center-opm-num" style="color: ${isCenterSelected ? 'white' : 'var(--color-teal-500)'};">${num}</div>
                        <div class="ramps-center-opm-community" style="color: ${isCenterSelected ? 'rgba(255,255,255,0.7)' : 'var(--color-slate-500)'};">${community}</div>
                    </div>
                `;

                // Partie droite: Off-Ramps
                let rightHtml = `<div class="ramps-section-title off-ramps">üìâ Off-Ramps</div><div class="ramps-items-container">`;
                if (data.off_ramps && data.off_ramps.length > 0) {
                    data.off_ramps.forEach(rampNum => {
                        const rampCommunity = idToCommunity[rampNum] || 'Unknown';
                        const rampColor = communityColors[rampCommunity] || '#d0d0d0';
                        // V√©rifier si cette paire sp√©cifique (centerNum-rampNum) est s√©lectionn√©e
                        const pairKey = `${num}::${rampNum}`;
                        const isOffRampSelected = offRampsSelectedOffRamps.has(pairKey);
                        rightHtml += `
                            <div class="ramps-item off-ramps ${isOffRampSelected ? 'selected' : ''}" style="cursor: pointer; ${isOffRampSelected ? 'background-color: #10B981; color: white; border-left-color: #059669;' : ''}" onclick="toggleOffRampsOffRamp('${num}', '${rampNum}')">
                                <div style="font-weight: 600; color: ${isOffRampSelected ? 'white' : rampColor};">${rampNum}</div>
                                <div style="font-size: 10px; color: ${isOffRampSelected ? 'rgba(255,255,255,0.7)' : 'var(--color-slate-500)'}; margin-top: 2px;">${rampCommunity}</div>
                            </div>
                        `;
                    });
                } else {
                    rightHtml += `<div style="text-align: center; color: var(--color-slate-500); padding: 16px 0;">Aucun</div>`;
                }
                rightHtml += `</div>`;

                html += `
                    <div class="ramps-detail-layout">
                        <div class="ramps-detail-section ramps-detail-center">
                            ${centerHtml}
                        </div>
                        <div class="ramps-detail-section ramps-detail-right">
                            ${rightHtml}
                        </div>
                    </div>
                `;
            });

            content.innerHTML = html;
        }

        function renderOffRampsSelection() {
            // Utiliser niceFramework pour afficher les OPM-ID
            renderOffRampsSelectionWithNiceFramework();
        }

        async function renderOffRampsSelectionWithFlare() {
            const content = document.getElementById('offRampsDetailContent');
            
            // Charger les donn√©es de flare.json
            const flareFramework = await loadFlareData();
            if (!flareFramework || Object.keys(flareFramework).length === 0) {
                // Si le chargement √©choue, utiliser niceFramework comme fallback
                console.warn('Impossible de charger flare.json, utilisation de niceFramework');
                renderOffRampsSelectionWithNiceFramework();
                return;
            }

            // Couleurs pour les diff√©rentes cat√©gories
            const categoryColors = {
                'analytics': '#3B82F6',
                'animate': '#10B981',
                'data': '#8B5CF6',
                'display': '#92400E',
                'flex': '#F59E0B',
                'physics': '#14B8A6',
                'query': '#EF4444',
                'scale': '#6B7280',
                'util': '#EC4899',
                'vis': '#F97316',
                'other': '#d0d0d0'
            };

            let html = '';
            const allModuleNames = Object.keys(flareFramework).sort((a, b) => {
                return a.localeCompare(b);
            });

            allModuleNames.forEach(moduleName => {
                const data = flareFramework[moduleName];
                if (!data) return;

                const category = getCategory(moduleName);
                const categoryColor = categoryColors[category] || categoryColors['other'];
                const shortName = getShortName(moduleName);

                // Partie centrale: Module
                const isCenterSelected = offRampsSelectedCenters.has(moduleName);
                const centerHtml = `
                    <div class="ramps-center-opm" style="cursor: pointer; ${isCenterSelected ? 'background-color: var(--color-teal-500); padding: 16px; border-radius: 8px; color: white;' : ''}" onclick="toggleOffRampsCenter('${moduleName.replace(/'/g, "\\'")}')">
                        <div class="ramps-center-dot" style="background-color: ${isCenterSelected ? 'white' : categoryColor};"></div>
                        <div class="ramps-center-opm-num" style="color: ${isCenterSelected ? 'white' : 'var(--color-teal-500)'}; font-size: 12px; word-break: break-word;">${shortName}</div>
                        <div class="ramps-center-opm-community" style="color: ${isCenterSelected ? 'rgba(255,255,255,0.7)' : 'var(--color-slate-500)'}; font-size: 10px; margin-top: 4px;">${category}</div>
                        <div style="color: ${isCenterSelected ? 'rgba(255,255,255,0.6)' : 'var(--color-slate-400)'}; font-size: 9px; margin-top: 2px; word-break: break-word;">${moduleName}</div>
                    </div>
                `;

                // Partie droite: Off-Ramps (imports)
                let rightHtml = `<div class="ramps-section-title off-ramps">üìâ Off-Ramps (Imports)</div><div class="ramps-items-container">`;
                if (data.off_ramps && data.off_ramps.length > 0) {
                    data.off_ramps.forEach(importName => {
                        const importCategory = getCategory(importName);
                        const importColor = categoryColors[importCategory] || categoryColors['other'];
                        const importShortName = getShortName(importName);
                        // V√©rifier si cette paire sp√©cifique (centerName::importName) est s√©lectionn√©e
                        const pairKey = `${moduleName}::${importName}`;
                        const isOffRampSelected = offRampsSelectedOffRamps.has(pairKey);
                        rightHtml += `
                            <div class="ramps-item off-ramps ${isOffRampSelected ? 'selected' : ''}" style="cursor: pointer; ${isOffRampSelected ? 'background-color: #10B981; color: white; border-left-color: #059669;' : ''}" onclick="toggleOffRampsOffRamp('${moduleName.replace(/'/g, "\\'")}', '${importName.replace(/'/g, "\\'")}')">
                                <div style="font-weight: 600; color: ${isOffRampSelected ? 'white' : importColor}; font-size: 12px; word-break: break-word;">${importShortName}</div>
                                <div style="font-size: 9px; color: ${isOffRampSelected ? 'rgba(255,255,255,0.7)' : 'var(--color-slate-500)'}; margin-top: 2px; word-break: break-word;">${importName}</div>
                            </div>
                        `;
                    });
                } else {
                    rightHtml += `<div style="text-align: center; color: var(--color-slate-500); padding: 16px 0;">Aucun</div>`;
                }
                rightHtml += `</div>`;

                html += `
                    <div class="ramps-detail-layout">
                        <div class="ramps-detail-section ramps-detail-center">
                            ${centerHtml}
                        </div>
                        <div class="ramps-detail-section ramps-detail-right">
                            ${rightHtml}
                        </div>
                    </div>
                `;
            });

            content.innerHTML = html;
        }

        function toggleOffRampsCenter(num) {
            if (offRampsSelectedCenters.has(num)) {
                offRampsSelectedCenters.delete(num);
            } else {
                offRampsSelectedCenters.add(num);
            }
            // Ne pas s√©lectionner automatiquement dans right quand on s√©lectionne dans center
            renderOffRampsSelection();
        }

        function toggleOffRampsOffRamp(centerName, importName) {
            const pairKey = `${centerName}::${importName}`;
            if (offRampsSelectedOffRamps.has(pairKey)) {
                offRampsSelectedOffRamps.delete(pairKey);
            } else {
                offRampsSelectedOffRamps.add(pairKey);
                // Si on s√©lectionne un off-ramp, s√©lectionner automatiquement le center parent
                if (!offRampsSelectedCenters.has(centerName)) {
                    offRampsSelectedCenters.add(centerName);
                }
                // ET aussi s√©lectionner le center correspondant √† l'import (car importName peut √™tre un module dans le center)
                if (!offRampsSelectedCenters.has(importName)) {
                    offRampsSelectedCenters.add(importName);
                }
            }
            renderOffRampsSelection();
        }

        async function validateOffRampsSelection() {
            // Avec miserables.json, on peut afficher m√™me sans s√©lection (toutes les donn√©es)
            // La v√©rification de s√©lection est maintenant optionnelle
            
            document.getElementById('offRampsDetailPanel').style.display = 'none';
            document.getElementById('offRampsVisualization').style.display = 'block';
            
            // Afficher la vue circulaire par d√©faut
            document.getElementById('offRampsLinearView').style.display = 'none';
            document.getElementById('offRampsCircularView').style.display = 'block';
            document.querySelectorAll('#offRampsTabs .tab-button').forEach(btn => btn.classList.remove('active'));
            const circularTab = document.querySelector('#offRampsTabs .tab-button:last-child');
            if (circularTab) circularTab.classList.add('active');
            offRampsCurrentTab = 'circular';
            
            // Rendre la visualisation circulaire (avec ou sans s√©lections)
            renderOffRampsCircularGraph();
        }

        function selectAllOffRamps() {
            // S√©lectionner tous les OPM-ID (centers)
            Object.keys(niceFramework).forEach(num => {
                offRampsSelectedCenters.add(num);
            });
            
            // S√©lectionner tous les off-ramps
            Object.keys(niceFramework).forEach(sourceId => {
                const data = niceFramework[sourceId];
                if (data && data.off_ramps) {
                    data.off_ramps.forEach(targetId => {
                        const pairKey = `${sourceId}::${targetId}`;
                        offRampsSelectedOffRamps.add(pairKey);
                    });
                }
            });
            
            // Rafra√Æchir l'affichage
            renderOffRampsSelection();
        }

        function resetOffRampsSelection() {
            // R√©initialiser toutes les s√©lections
            offRampsSelectedCenters.clear();
            offRampsSelectedOffRamps.clear();
            offRampsNetworkSelectedNode = null;

            // Masquer la carte "principale" dans le header
            const headerSection = document.getElementById('offRampsNetworkHeaderSection');
            if (headerSection) {
                headerSection.style.display = 'none';
            }

            // R√©initialiser les zooms
            offRampsCurrentZoom = 1;
            offRampsCircularZoom = 1;
            offRampsCurrentTab = 'linear';

            // Mettre √† jour les labels de zoom
            const zoomLevelEl = document.getElementById('offRampsZoomLevel');
            const circularZoomLevelEl = document.getElementById('offRampsCircularZoomLevel');
            if (zoomLevelEl) zoomLevelEl.textContent = '100';
            if (circularZoomLevelEl) circularZoomLevelEl.textContent = '100';
            
            // R√©afficher le panneau de s√©lection
            document.getElementById('offRampsDetailPanel').style.display = 'block';
            document.getElementById('offRampsVisualization').style.display = 'none';
            
            // R√©initialiser les onglets
            document.querySelectorAll('#offRampsTabs .tab-button').forEach(btn => btn.classList.remove('active'));
            const firstTab = document.querySelector('#offRampsTabs .tab-button:first-child');
            if (firstTab) firstTab.classList.add('active');
            document.getElementById('offRampsLinearView').style.display = 'block';
            document.getElementById('offRampsCircularView').style.display = 'none';
            
            // R√©afficher la s√©lection
            renderOffRampsSelection();
        }

        function switchOffRampsTab(tab) {
            offRampsCurrentTab = tab;
            document.querySelectorAll('#offRampsTabs .tab-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            document.getElementById('offRampsLinearView').style.display = tab === 'linear' ? 'block' : 'none';
            document.getElementById('offRampsCircularView').style.display = tab === 'circular' ? 'block' : 'none';
            document.getElementById('offRampsCircularOldView').style.display = tab === 'circular-old' ? 'block' : 'none';
            document.getElementById('offRampsCircular2View').style.display = tab === 'circular-2' ? 'block' : 'none';
            document.getElementById('offRampsNetworkView').style.display = tab === 'network' ? 'block' : 'none';

            if (tab === 'circular') {
                renderOffRampsCircularGraph();
            } else if (tab === 'circular-old') {
                renderOffRampsCircularOldGraph();
            } else if (tab === 'circular-2') {
                renderOffRampsCircular2Graph();
            } else if (tab === 'network') {
                renderOffRampsNetworkGraph();
            } else {
                renderOffRampsGraph();
            }
        }

        function renderOffRampsGraph() {
            const canvas = document.getElementById('offRampsCanvas');
            canvas.innerHTML = '';

            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });

            // Cr√©er un Set de tous les OPM-ID √† afficher (centers + off-ramps)
            const opmsToShow = new Set();
            offRampsSelectedCenters.forEach(num => opmsToShow.add(num));
            // Extraire les rampNum uniques des paires "centerNum::rampNum"
            offRampsSelectedOffRamps.forEach(pair => {
                const rampNum = pair.split('::')[1];
                if (rampNum) opmsToShow.add(rampNum);
            });

            // Cr√©er la liste tri√©e des OPM-ID √† afficher
            const sortedOpms = Array.from(opmsToShow).sort((a, b) => {
                const aNum = isNaN(parseInt(a)) ? Infinity : parseInt(a);
                const bNum = isNaN(parseInt(b)) ? Infinity : parseInt(b);
                if (aNum === Infinity && bNum === Infinity) return a.localeCompare(b);
                if (aNum === Infinity) return 1;
                if (bNum === Infinity) return -1;
                return aNum - bNum;
            });

            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('data-transform-group', 'true');

            const positionMap = {};
            let xPos = 40;
            sortedOpms.forEach(num => {
                positionMap[num] = { x: xPos, y: 200 };
                xPos += 80;
            });

            const canvasWidth = Math.max(1200, xPos + 40);
            canvas.setAttribute('viewBox', `0 0 ${canvasWidth} 400`);
            canvas.setAttribute('width', canvasWidth);
            canvas.setAttribute('height', 400);

            // Dessiner les connexions off-ramps
            const connections = [];
            offRampsSelectedCenters.forEach(centerNum => {
                const data = niceFramework[centerNum];
                if (!data) return;

                data.off_ramps.forEach(rampNum => {
                    const pairKey = `${centerNum}::${rampNum}`;
                    if (offRampsSelectedOffRamps.has(pairKey) && opmsToShow.has(rampNum)) {
                        connections.push({ from: centerNum, to: rampNum, type: 'off-ramp' });
                    }
                });
            });

            connections.forEach((conn, index) => {
                const fromPos = positionMap[conn.from];
                const toPos = positionMap[conn.to];
                if (fromPos && toPos) {
                    drawOffRampsLinearArc(group, fromPos, toPos, conn.type, index, connections);
                }
            });

            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };

            sortedOpms.forEach(num => {
                const community = idToCommunity[num] || 'Unknown';
                const communityColor = communityColors[community] || '#d0d0d0';
                const pos = positionMap[num];
                const isCenter = offRampsSelectedCenters.has(num);
                // V√©rifier si ce num est pr√©sent dans une des paires comme rampNum
                let isOffRamp = false;
                offRampsSelectedOffRamps.forEach(pair => {
                    const rampNum = pair.split('::')[1];
                    if (rampNum === num) {
                        isOffRamp = true;
                    }
                });

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', pos.x);
                circle.setAttribute('cy', pos.y);
                circle.setAttribute('r', isCenter ? 10 : 8);
                circle.setAttribute('fill', communityColor);
                circle.setAttribute('opacity', '1');
                group.appendChild(circle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', pos.x);
                text.setAttribute('y', pos.y + 25);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', isCenter ? '16px' : '14px');
                text.setAttribute('font-weight', '700');
                text.setAttribute('fill', communityColor);
                text.textContent = num;
                group.appendChild(text);
            });

            canvas.appendChild(group);
            initOffRampsArrowMarkers();
            applyOffRampsCanvasTransform();
        }

        function drawOffRampsLinearArc(canvas, fromPos, toPos, rampType, index, allConnections) {
            const color = '#10B981';
            const xDiff = Math.abs(toPos.x - fromPos.x);
            const gap = xDiff / 80;
            
            let amplitudeModifier = 1;
            if (gap <= 3) {
                amplitudeModifier = 2 + (3 - gap) * 0.7;
            } else if (gap <= 5) {
                amplitudeModifier = 1.5 + (5 - gap) * 0.3;
            }
            
            const baseHeight = 60 * 0.8;
            const midY = fromPos.y + baseHeight * amplitudeModifier;
            const midX = (fromPos.x + toPos.x) / 2;
            
            const pathData = `M ${fromPos.x} ${fromPos.y} Q ${midX} ${midY} ${toPos.x} ${toPos.y}`;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', 'url(#arrowhead-off-ramp-offramps)');
            path.setAttribute('opacity', '0.7');
            canvas.appendChild(path);
        }

        function initOffRampsArrowMarkers() {
            let defs = document.querySelector('#offRampsCanvas defs');
            if (defs) {
                defs.remove();
            }
            
            const canvas = document.getElementById('offRampsCanvas');
            const newDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            const arrowOff = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            arrowOff.setAttribute('id', 'arrowhead-off-ramp-offramps');
            arrowOff.setAttribute('markerWidth', '10');
            arrowOff.setAttribute('markerHeight', '10');
            arrowOff.setAttribute('refX', '9');
            arrowOff.setAttribute('refY', '3');
            arrowOff.setAttribute('orient', 'auto');
            const polygonOff = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygonOff.setAttribute('points', '0 0, 10 3, 0 6');
            polygonOff.setAttribute('fill', '#10B981');
            arrowOff.appendChild(polygonOff);
            newDefs.appendChild(arrowOff);
            
            canvas.insertBefore(newDefs, canvas.firstChild);
        }

        function applyOffRampsCanvasTransform() {
            const canvas = document.getElementById('offRampsCanvas');
            if (canvas) {
                const group = canvas.querySelector('g[data-transform-group]');
                if (group) {
                    group.setAttribute('transform', `scale(${offRampsCurrentZoom})`);
                    group.setAttribute('transform-origin', '0 0');
                }
            }
        }

        function offRampsZoomIn() {
            offRampsCurrentZoom = Math.min(offRampsCurrentZoom + 0.2, 3);
            document.getElementById('offRampsZoomLevel').textContent = Math.round(offRampsCurrentZoom * 100);
            applyOffRampsCanvasTransform();
        }

        function offRampsZoomOut() {
            offRampsCurrentZoom = Math.max(offRampsCurrentZoom - 0.2, 0.5);
            document.getElementById('offRampsZoomLevel').textContent = Math.round(offRampsCurrentZoom * 100);
            applyOffRampsCanvasTransform();
        }

        function offRampsFitToScreen() {
            offRampsCurrentZoom = 1;
            document.getElementById('offRampsZoomLevel').textContent = '100';
            const wrapper = document.getElementById('offRampsCanvasWrapper');
            if (wrapper) {
                wrapper.scrollLeft = 0;
                wrapper.scrollTop = 0;
            }
            applyOffRampsCanvasTransform();
        }

        // Convertir niceFramework en format nodes/links pour la visualisation
        function convertNiceFrameworkToNodesLinks() {
            // Obtenir les communaut√©s pour chaque OPM-ID
            const allIds = getAllOpmIds();
            const idToCommunity = {};
            const communityToGroup = {};
            const communities = new Set();
            
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
                communities.add(item.community);
            });
            
            // Cr√©er un mapping communaut√© -> group (num√©ro)
            const sortedCommunities = Array.from(communities).sort();
            sortedCommunities.forEach((comm, index) => {
                communityToGroup[comm] = index;
            });
            
            // Cr√©er les n≈ìuds
            const nodes = [];
            const nodeSet = new Set();
            
            // Si aucune s√©lection, inclure tous les OPM-ID de niceFramework
            if (offRampsSelectedCenters.size === 0 && offRampsSelectedOffRamps.size === 0) {
                Object.keys(niceFramework).forEach(opmId => {
                    if (!nodeSet.has(opmId)) {
                        const community = idToCommunity[opmId] || 'Unknown';
                        nodes.push({
                            id: opmId,
                            group: communityToGroup[community] !== undefined ? communityToGroup[community] : -1
                        });
                        nodeSet.add(opmId);
                    }
                });
            } else {
                // Cr√©er un Set de tous les n≈ìuds √† inclure
                const nodesToInclude = new Set();
                
                // Ajouter les n≈ìuds s√©lectionn√©s comme centers
                offRampsSelectedCenters.forEach(nodeId => nodesToInclude.add(nodeId));
                
                // Ajouter les n≈ìuds qui sont des sources ou destinations de liens s√©lectionn√©s
                offRampsSelectedOffRamps.forEach(pair => {
                    const parts = pair.split('::');
                    if (parts.length >= 2) {
                        const source = parts[0];
                        const target = parts.slice(1).join('::');
                        nodesToInclude.add(source);
                        nodesToInclude.add(target);
                    }
                });
                
                nodesToInclude.forEach(opmId => {
                    if (!nodeSet.has(opmId)) {
                        const community = idToCommunity[opmId] || 'Unknown';
                        nodes.push({
                            id: opmId,
                            group: communityToGroup[community] !== undefined ? communityToGroup[community] : -1
                        });
                        nodeSet.add(opmId);
                    }
                });
            }
            
            // Cr√©er les liens (off-ramps)
            const links = [];
            const linkSet = new Set();
            
            Object.keys(niceFramework).forEach(sourceId => {
                const data = niceFramework[sourceId];
                if (!data || !data.off_ramps) return;
                
                data.off_ramps.forEach(targetId => {
                    // V√©rifier si ce lien doit √™tre inclus
                    const pairKey = `${sourceId}::${targetId}`;
                    const shouldInclude = 
                        (offRampsSelectedCenters.size === 0 && offRampsSelectedOffRamps.size === 0) ||
                        offRampsSelectedOffRamps.has(pairKey) ||
                        (offRampsSelectedCenters.has(sourceId) && nodeSet.has(targetId));
                    
                    if (shouldInclude && nodeSet.has(sourceId) && nodeSet.has(targetId)) {
                        const linkKey = `${sourceId}->${targetId}`;
                        if (!linkSet.has(linkKey)) {
                            links.push({
                                source: sourceId,
                                target: targetId,
                                value: 1
                            });
                            linkSet.add(linkKey);
                        }
                    }
                });
            });
            
            console.log('Donn√©es converties:', nodes.length, 'n≈ìuds,', links.length, 'liens');
            return { nodes, links };
        }


        function renderOffRampsCircularGraph() {
            const canvas = document.getElementById('offRampsCircularCanvas');
            const wrapper = document.getElementById('offRampsCircularCanvasWrapper');
            if (!canvas) {
                console.error('Canvas offRampsCircularCanvas introuvable');
                return;
            }
            canvas.innerHTML = '';
            
            try {
                // Convertir niceFramework en format nodes/links
                const { nodes, links } = convertNiceFrameworkToNodesLinks();
                
                if (!nodes || nodes.length === 0) {
                    console.warn('Aucune donn√©e disponible pour la visualisation');
                    canvas.innerHTML = `
                        <g>
                            <text x="320" y="200" text-anchor="middle" fill="#666" font-size="16px" font-weight="bold">Aucune donn√©e disponible</text>
                            <text x="320" y="230" text-anchor="middle" fill="#999" font-size="12px">Impossible de charger miserables.json</text>
                            <text x="320" y="250" text-anchor="middle" fill="#999" font-size="11px">Assurez-vous d'utiliser un serveur HTTP local</text>
                        </g>
                    `;
                    return;
                }
                
                console.log('Rendu de la visualisation avec', nodes.length, 'n≈ìuds et', links.length, 'liens');

                // Dimensions comme dans code.txt (marginLeft augment√© pour les labels avec cat√©gorie)
                const width = 640;
                const step = 14;
                const marginTop = 20;
                const marginRight = 20;
                const marginBottom = 20;
                const marginLeft = 180; // Augment√© pour accommoder les labels avec cat√©gorie (ex: "311_CI")
                const height = (nodes.length - 1) * step + marginTop + marginBottom;

                // Cr√©er les ordres de tri
                const degree = d3.rollup(
                    links.flatMap(({ source, target, value }) => [
                        { node: source, value },
                        { node: target, value }
                    ]),
                    (v) => d3.sum(v, ({ value }) => value),
                    ({ node }) => node
                );
                
                // Obtenir les communaut√©s pour le tri
                const allIds = getAllOpmIds();
                const idToCommunity = {};
                allIds.forEach(item => {
                    const num = item.id.split('_')[0];
                    idToCommunity[num] = item.community;
                });
                
                // Fonction pour extraire le num√©ro OPM-ID pour le tri chronologique
                function getOpmNumber(opmId) {
                    const num = parseInt(opmId);
                    return isNaN(num) ? Infinity : num;
                }
                
                const orders = new Map([
                    ["by name", d3.sort(nodes.map((d) => d.id))],
                    ["by group", d3.sort(nodes, (d) => idToCommunity[d.id] || 'Unknown', ({id}) => id).map(({id}) => id)],
                    ["by degree", d3.sort(nodes, ({id}) => degree.get(id) || 0, ({id}) => id).map(({id}) => id).reverse()],
                    ["chrono-asc", d3.sort(nodes, (d) => getOpmNumber(d.id), (d) => d.id).map(({id}) => id)],
                    ["chrono-desc", d3.sort(nodes, (d) => getOpmNumber(d.id), (d) => d.id).reverse().map(({id}) => id)]
                ]);

                console.log('Tri actuel:', offRampsCircularSortOrder);
                const currentOrder = orders.get(offRampsCircularSortOrder) || orders.get("by name");
                console.log('Ordre utilis√©:', currentOrder.slice(0, 5), '...');
                const y = d3.scalePoint(currentOrder, [marginTop, height - marginBottom]);

                // Couleurs des communaut√©s
                const communityColors = {
                    'IT': '#3B82F6',
                    'CS': '#10B981',
                    'EN': '#8B5CF6',
                    'CE': '#92400E',
                    'CI': '#F59E0B',
                    'DA': '#14B8A6',
                    'SE': '#EF4444',
                    'Cx': '#6B7280'
                };
                
                // Fonction pour obtenir la couleur d'un n≈ìud
                function getNodeColor(nodeId) {
                    const community = idToCommunity[nodeId] || 'Unknown';
                    return communityColors[community] || '#aaa';
                }
                
                // Fonction pour v√©rifier si source et target ont la m√™me communaut√©
                const nodeCommunities = new Map(nodes.map(d => [d.id, idToCommunity[d.id] || 'Unknown']));
                function samegroup({ source, target }) {
                    const sourceComm = nodeCommunities.get(source);
                    const targetComm = nodeCommunities.get(target);
                    return sourceComm === targetComm ? sourceComm : null;
                }
                
                // Fonction pour obtenir la couleur d'un groupe
                function getGroupColor(group) {
                    if (group === null) return '#ccc';
                    return communityColors[group] || '#aaa';
                }

                // Cr√©er le SVG
                canvas.setAttribute('width', width);
                canvas.setAttribute('height', height);
                canvas.setAttribute('viewBox', `0 0 ${width} ${height}`);
                canvas.setAttribute('style', 'max-width: 100%; height: auto;');

                // Positions actuelles des n≈ìuds (pour animations)
                const Y = new Map(nodes.map(({id}) => [id, y(id)]));
                
                // Fonction pour cr√©er les arcs
                function arc(d) {
                    const y1 = Y.get(d.source);
                    const y2 = Y.get(d.target);
                    const r = Math.abs(y2 - y1) / 2;
                    return `M${marginLeft},${y1}A${r},${r} 0,0,${y1 < y2 ? 1 : 0} ${marginLeft},${y2}`;
                }
                
                // Fonction update pour animer les changements de tri (inspir√©e de code.txt)
                function update(order) {
                    y.domain(order);
                    
                    // Mettre √† jour les positions Y
                    labelGroup.querySelectorAll('g.node').forEach((g, i) => {
                        const nodeId = g.getAttribute('data-id');
                        const newY = y(nodeId);
                        const oldY = Y.get(nodeId);
                        Y.set(nodeId, newY);
                        
                        // Animation avec transition
                        g.style.transition = 'transform 750ms';
                        g.style.transitionDelay = `${i * 20}ms`;
                        g.setAttribute('transform', `translate(${marginLeft},${newY})`);
                    });
                    
                    // Mettre √† jour les arcs avec transition
                    pathGroup.querySelectorAll('path').forEach((path, i) => {
                        const linkData = path.getAttribute('data-link');
                        const [source, target] = linkData.split('->');
                        path.style.transition = `d 750ms`;
                        path.style.transitionDelay = `${i * 5}ms`;
                        path.setAttribute('d', arc({ source, target }));
                    });
                }

                // Cr√©er les d√©finitions pour les fl√®ches
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const arrowMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                arrowMarker.setAttribute('id', 'arrowhead-offramps');
                arrowMarker.setAttribute('markerWidth', '6');
                arrowMarker.setAttribute('markerHeight', '6');
                arrowMarker.setAttribute('refX', '5');
                arrowMarker.setAttribute('refY', '3');
                arrowMarker.setAttribute('orient', 'auto');
                const arrowPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                arrowPolygon.setAttribute('points', '0 0, 6 3, 0 6');
                arrowPolygon.setAttribute('fill', '#999');
                arrowPolygon.setAttribute('opacity', '0.8');
                arrowMarker.appendChild(arrowPolygon);
                defs.appendChild(arrowMarker);
                canvas.appendChild(defs);

                // Dessiner les arcs (liens)
                const pathGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                pathGroup.setAttribute('fill', 'none');
                pathGroup.setAttribute('stroke-opacity', '0.6');
                pathGroup.setAttribute('stroke-width', '1.5');

                links.forEach(d => {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('stroke', getGroupColor(samegroup(d)));
                    path.setAttribute('d', arc(d));
                    path.setAttribute('marker-end', 'url(#arrowhead-offramps)');
                    path.setAttribute('data-link', `${d.source}->${d.target}`);
                    pathGroup.appendChild(path);
                });

                canvas.appendChild(pathGroup);

                // Dessiner les labels et points
                const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                labelGroup.setAttribute('font-family', 'sans-serif');
                labelGroup.setAttribute('font-size', '10');
                labelGroup.setAttribute('text-anchor', 'end');

                nodes.forEach(d => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('transform', `translate(${marginLeft},${Y.get(d.id)})`);
                    g.setAttribute('class', 'node');
                    g.setAttribute('data-id', d.id);

                    // Texte avec cat√©gorie
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', '-6');
                    text.setAttribute('dy', '0.35em');
                    const nodeColor = getNodeColor(d.id);
                    const textColor = d3.lab(nodeColor).darker(2);
                    text.setAttribute('fill', textColor);
                    const community = idToCommunity[d.id] || 'Unknown';
                    text.textContent = `${d.id}_${community}`;
                    g.appendChild(text);

                    // Cercle
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', '3');
                    circle.setAttribute('fill', nodeColor);
                    g.appendChild(circle);

                    // Rectangle invisible pour les interactions
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('fill', 'none');
                    rect.setAttribute('width', marginLeft + 40);
                    rect.setAttribute('height', step);
                    rect.setAttribute('x', -marginLeft);
                    rect.setAttribute('y', -step / 2);
                    rect.setAttribute('pointer-events', 'all');
                    rect.setAttribute('cursor', 'pointer');
                    
                    rect.addEventListener('pointerenter', function(event) {
                        canvas.classList.add('hover');
                        labelGroup.querySelectorAll('g').forEach(g => {
                            g.classList.remove('primary', 'secondary');
                            if (g.getAttribute('data-id') === d.id) {
                                g.classList.add('primary');
                            } else if (links.some(({source, target}) => 
                                (g.getAttribute('data-id') === source && d.id === target) || 
                                (g.getAttribute('data-id') === target && d.id === source)
                            )) {
                                g.classList.add('secondary');
                            }
                        });
                        pathGroup.querySelectorAll('path').forEach(path => {
                            const linkSource = path.getAttribute('data-link').split('->')[0];
                            const linkTarget = path.getAttribute('data-link').split('->')[1];
                            if (linkSource === d.id || linkTarget === d.id) {
                                path.classList.add('primary');
                                path.parentNode.appendChild(path); // raise
                            } else {
                                path.classList.remove('primary');
                            }
                        });
                    });
                    
                    rect.addEventListener('pointerout', function(event) {
                        canvas.classList.remove('hover');
                        labelGroup.querySelectorAll('g').forEach(g => {
                            g.classList.remove('primary', 'secondary');
                        });
                        pathGroup.querySelectorAll('path').forEach(path => {
                            path.classList.remove('primary');
                        });
                    });

                    g.appendChild(rect);
                    labelGroup.appendChild(g);
                });

                canvas.appendChild(labelGroup);

                // Ajouter les styles CSS pour les interactions
                const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                style.textContent = `
                    .hover text { fill: #aaa; }
                    .hover g.primary text { font-weight: bold; fill: #333; }
                    .hover g.secondary text { fill: #333; }
                    .hover path { stroke: #ccc; }
                    .hover path.primary { stroke: #333; }
                `;
                canvas.appendChild(style);

            } catch (error) {
                console.error('Erreur lors du rendu du graphique:', error);
                const errorMsg = error.message || 'Erreur inconnue';
                canvas.innerHTML = `
                    <g>
                        <text x="320" y="200" text-anchor="middle" fill="#f00" font-size="16px" font-weight="bold">Erreur de chargement</text>
                        <text x="320" y="230" text-anchor="middle" fill="#666" font-size="12px">${errorMsg}</text>
                    </g>
                `;
            }
        }


        function setOffRampsCircularSort(sortOrder) {
            console.log('setOffRampsCircularSort appel√© avec:', sortOrder);
            offRampsCircularSortOrder = sortOrder;
            console.log('offRampsCircularSortOrder mis √† jour:', offRampsCircularSortOrder);
            renderOffRampsCircularGraph();
        }

        function offRampsCircularZoomIn() {
            offRampsCircularZoom = Math.min(offRampsCircularZoom + 0.2, 3);
            document.getElementById('offRampsCircularZoomLevel').textContent = Math.round(offRampsCircularZoom * 100);
            renderOffRampsCircularGraph();
        }

        function offRampsCircularZoomOut() {
            offRampsCircularZoom = Math.max(offRampsCircularZoom - 0.2, 0.5);
            document.getElementById('offRampsCircularZoomLevel').textContent = Math.round(offRampsCircularZoom * 100);
            renderOffRampsCircularGraph();
        }

        function offRampsCircularFitToScreen() {
            offRampsCircularZoom = 1;
            document.getElementById('offRampsCircularZoomLevel').textContent = '100';
            const wrapper = document.getElementById('offRampsCircularCanvasWrapper');
            if (wrapper) {
                wrapper.scrollLeft = 0;
                wrapper.scrollTop = 0;
            }
            renderOffRampsCircularGraph();
        }

        // Ancienne visualisation circulaire (bas√©e sur circu1/code.txt)
        function renderOffRampsCircularOldGraph() {
            const canvas = document.getElementById('offRampsCircularOldCanvas');
            const wrapper = document.getElementById('offRampsCircularOldCanvasWrapper');
            if (!canvas) {
                console.error('Canvas offRampsCircularOldCanvas introuvable');
                return;
            }
            canvas.innerHTML = '';
            
            try {
                // Convertir niceFramework en format adapt√©
                const { nodes, links } = convertNiceFrameworkToNodesLinks();
                
                if (!nodes || nodes.length === 0) {
                    canvas.innerHTML = '<text x="400" y="400" text-anchor="middle" fill="#666" font-size="16px">Aucune donn√©e disponible</text>';
                    return;
                }

                const width = 954;
                const radius = width / 2;
                
                // Utiliser la taille du wrapper ou une taille par d√©faut
                const wrapperWidth = wrapper ? wrapper.clientWidth : 800;
                const wrapperHeight = wrapper ? wrapper.clientHeight : 800;
                const baseSize = Math.min(wrapperWidth, wrapperHeight, 800);
                const size = baseSize * offRampsCircularOldZoom;

                // ViewBox centr√© comme dans code.txt
                canvas.setAttribute('width', '100%');
                canvas.setAttribute('height', '100%');
                canvas.setAttribute('viewBox', `${-width / 2} ${-width / 2} ${width} ${width}`);
                canvas.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                canvas.setAttribute('style', 'max-width: 100%; height: auto; font: 10px sans-serif;');

                // Convertir en format hi√©rarchique pour D3
                const dataArray = [];
                nodes.forEach(node => {
                    const nodeLinks = links.filter(l => l.source === node.id);
                    dataArray.push({
                        name: node.id,
                        imports: nodeLinks.map(l => l.target)
                    });
                });

                // Fonction hierarchy adapt√©e pour OPM-ID
                function hierarchyOPM(data) {
                    const root = { name: "OPM", children: [] };
                    const map = new Map();
                    data.forEach(item => {
                        const node = {
                            name: item.name,
                            imports: item.imports || [],
                            children: []
                        };
                        map.set(item.name, node);
                        root.children.push(node);
                    });
                    return root;
                }

                // Fonction bilink adapt√©e pour OPM-ID
                function bilinkOPM(root) {
                    const map = new Map(root.leaves().map(d => [idOPM(d), d]));
                    for (const d of root.leaves()) {
                        d.incoming = [];
                        d.outgoing = (d.data.imports || []).map(i => {
                            const target = map.get(i);
                            return target ? [d, target] : null;
                        }).filter(x => x !== null);
                    }
                    for (const d of root.leaves()) {
                        for (const o of d.outgoing) {
                            o[1].incoming.push(o);
                        }
                    }
                    return root;
                }

                // Fonction id adapt√©e pour OPM-ID
                function idOPM(node) {
                    return node.data.name;
                }

                const tree = d3.cluster()
                    .size([2 * Math.PI, radius - 100]);
                
                const data = hierarchyOPM(dataArray);
                const root = tree(bilinkOPM(d3.hierarchy(data)
                    .sort((a, b) => {
                        const aNum = parseInt(a.data.name) || 0;
                        const bNum = parseInt(b.data.name) || 0;
                        return aNum - bNum;
                    })));

                const mainGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                // Pas besoin de transformation, le viewBox est d√©j√† centr√©

                const colornone = "#ccc";
                const colorout = "#10B981"; // Vert pour off-ramps
                const colorin = "#3B82F6"; // Bleu pour on-ramps (incoming)

                const line = d3.lineRadial()
                    .curve(d3.curveBundle.beta(0.85))
                    .radius(d => d.y)
                    .angle(d => d.x);

                const linkGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                linkGroup.setAttribute('stroke', colornone);
                linkGroup.setAttribute('fill', 'none');
                linkGroup.setAttribute('style', 'mix-blend-mode: multiply;');

                root.leaves().forEach(leaf => {
                    leaf.pathElements = [];
                });

                root.leaves().forEach(leaf => {
                    leaf.outgoing.forEach(([i, o]) => {
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const pathData = line(i.path(o));
                        path.setAttribute('d', pathData);
                        path.setAttribute('stroke', colornone);
                        path.setAttribute('stroke-width', '1.5');
                        path.setAttribute('opacity', '0.6');
                        linkGroup.appendChild(path);
                        if (!i.pathElements) i.pathElements = [];
                        if (!o.pathElements) o.pathElements = [];
                        i.pathElements.push(path);
                        o.pathElements.push(path);
                    });
                });

                mainGroup.appendChild(linkGroup);

                const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                // Obtenir les communaut√©s
                const allIds = getAllOpmIds();
                const idToCommunity = {};
                allIds.forEach(item => {
                    const num = item.id.split('_')[0];
                    idToCommunity[num] = item.community;
                });
                
                root.leaves().forEach(d => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const angle = d.x * 180 / Math.PI - 90;
                    const translateX = d.y;
                    g.setAttribute('transform', `rotate(${angle}) translate(${translateX},0)`);
                    g.setAttribute('class', 'node');
                    g.setAttribute('data-id', idOPM(d));

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('dy', '0.31em');
                    text.setAttribute('x', d.x < Math.PI ? 6 : -6);
                    text.setAttribute('text-anchor', d.x < Math.PI ? 'start' : 'end');
                    if (d.x >= Math.PI) {
                        text.setAttribute('transform', 'rotate(180)');
                    }
                    text.setAttribute('font-size', '11px');
                    text.setAttribute('fill', '#333');
                    text.setAttribute('font-weight', '500');
                    
                    // Ajouter la cat√©gorie
                    const community = idToCommunity[d.data.name] || 'Unknown';
                    text.textContent = `${d.data.name}_${community}`;
                    
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = `${idOPM(d)}\n${d.outgoing.length} outgoing\n${d.incoming.length} incoming`;
                    text.appendChild(title);

                    text.setAttribute('style', 'cursor: pointer;');
                    text.addEventListener('mouseover', function(event) {
                        overedOld(event, d, linkGroup, colorin, colorout);
                    });
                    text.addEventListener('mouseout', function(event) {
                        outedOld(event, d, linkGroup, colornone);
                    });

                    g.appendChild(text);
                    nodeGroup.appendChild(g);
                    
                    d.text = text;
                });

                mainGroup.appendChild(nodeGroup);
                canvas.appendChild(mainGroup);
            } catch (error) {
                console.error('Erreur lors du rendu de l\'ancien graphique circulaire:', error);
                canvas.innerHTML = `<text x="0" y="0" text-anchor="middle" fill="#f00" font-size="14px">Erreur: ${error.message}</text>`;
            }
        }

        // Event handlers pour l'ancienne vue circulaire
        function overedOld(event, d, linkGroup, colorin, colorout) {
            linkGroup.style.mixBlendMode = null;
            d.text.setAttribute('font-weight', 'bold');

            d.incoming.forEach(([from,]) => {
                if (from.pathElements) {
                    from.pathElements.forEach(path => {
                        path.setAttribute('stroke', colorin);
                        path.parentNode.appendChild(path);
                    });
                }
                if (from.text) {
                    from.text.setAttribute('fill', colorin);
                    from.text.setAttribute('font-weight', 'bold');
                }
            });
            
            d.outgoing.forEach(([, to]) => {
                if (to.pathElements) {
                    to.pathElements.forEach(path => {
                        path.setAttribute('stroke', colorout);
                        path.parentNode.appendChild(path);
                    });
                }
                if (to.text) {
                    to.text.setAttribute('fill', colorout);
                    to.text.setAttribute('font-weight', 'bold');
                }
            });
        }

        function outedOld(event, d, linkGroup, colornone) {
            linkGroup.style.mixBlendMode = 'multiply';
            d.text.setAttribute('font-weight', null);

            d.incoming.forEach(([from,]) => {
                if (from.pathElements) {
                    from.pathElements.forEach(path => {
                        path.setAttribute('stroke', colornone);
                    });
                }
                if (from.text) {
                    from.text.setAttribute('fill', null);
                    from.text.setAttribute('font-weight', null);
                }
            });

            d.outgoing.forEach(([, to]) => {
                if (to.pathElements) {
                    to.pathElements.forEach(path => {
                        path.setAttribute('stroke', colornone);
                    });
                }
                if (to.text) {
                    to.text.setAttribute('fill', null);
                    to.text.setAttribute('font-weight', null);
                }
            });
        }

        function offRampsCircularOldZoomIn() {
            offRampsCircularOldZoom = Math.min(offRampsCircularOldZoom + 0.2, 3);
            document.getElementById('offRampsCircularOldZoomLevel').textContent = Math.round(offRampsCircularOldZoom * 100);
            renderOffRampsCircularOldGraph();
        }

        function offRampsCircularOldZoomOut() {
            offRampsCircularOldZoom = Math.max(offRampsCircularOldZoom - 0.2, 0.5);
            document.getElementById('offRampsCircularOldZoomLevel').textContent = Math.round(offRampsCircularOldZoom * 100);
            renderOffRampsCircularOldGraph();
        }

        function offRampsCircularOldFitToScreen() {
            offRampsCircularOldZoom = 1;
            document.getElementById('offRampsCircularOldZoomLevel').textContent = '100';
            const wrapper = document.getElementById('offRampsCircularOldCanvasWrapper');
            if (wrapper) {
                wrapper.scrollLeft = 0;
                wrapper.scrollTop = 0;
            }
            renderOffRampsCircularOldGraph();
        }

        // Vue Circulaire 2 (bas√©e sur DCWF OPM-ID Visualiseur Avanc√©)
        function renderOffRampsCircular2Graph() {
            const canvas = document.getElementById('offRampsCircular2Canvas');
            const wrapper = document.getElementById('offRampsCircular2CanvasWrapper');
            if (!canvas) {
                console.error('Canvas offRampsCircular2Canvas introuvable');
                return;
            }
            canvas.innerHTML = '';
            
            try {
                const baseSize = 800;
                const size = baseSize * offRampsCircular2Zoom;
                const center = size / 2;
                const radius = size * 0.35;
                
                canvas.setAttribute('width', size);
                canvas.setAttribute('height', size);
                
                const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bg.setAttribute('width', size);
                bg.setAttribute('height', size);
                bg.setAttribute('fill', '#fafafa');
                canvas.appendChild(bg);
                
                const allIds = getAllOpmIds();
                const positions = {};
                
                allIds.forEach((item, index) => {
                    const angle = (index / allIds.length) * 2 * Math.PI - Math.PI / 2;
                    const x = center + radius * Math.cos(angle);
                    const y = center + radius * Math.sin(angle);
                    const num = item.id.split('_')[0];
                    positions[num] = { x, y, community: item.community, fullId: item.id, angle };
                });
                
                // Utiliser les s√©lections off-ramps
                const selectedArray = Array.from(offRampsSelectedCenters);
                const allRamps = new Set();
                const connections = [];
                
                if (offRampsSelectedCenters.size > 0 || offRampsSelectedOffRamps.size > 0) {
                    selectedArray.forEach(selectedNum => {
                        const data = niceFramework[selectedNum];
                        if (!data) return;
                        
                        allRamps.add(selectedNum);
                        
                        // Ajouter les off-ramps s√©lectionn√©s
                        data.off_ramps.forEach(rampNum => {
                            const pairKey = `${selectedNum}::${rampNum}`;
                            if (offRampsSelectedOffRamps.size === 0 || offRampsSelectedOffRamps.has(pairKey)) {
                                allRamps.add(rampNum);
                                connections.push({ from: selectedNum, to: rampNum, type: 'off-ramp' });
                            }
                        });
                    });
                } else {
                    // Si aucune s√©lection, afficher tous les OPM-ID
                    Object.keys(niceFramework).forEach(num => {
                        allRamps.add(num);
                        const data = niceFramework[num];
                        if (data && data.off_ramps) {
                            data.off_ramps.forEach(rampNum => {
                                connections.push({ from: num, to: rampNum, type: 'off-ramp' });
                            });
                        }
                    });
                }
                
                // Dessiner les connexions
                connections.forEach((conn) => {
                    const fromPos = positions[conn.from];
                    const toPos = positions[conn.to];
                    if (fromPos && toPos) {
                        const color = conn.type === 'on-ramp' ? '#3B82F6' : '#10B981';
                        const dx = toPos.x - fromPos.x;
                        const dy = toPos.y - fromPos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Calculer l'angle angulaire entre les deux points
                        const angleDiff = Math.abs(toPos.angle - fromPos.angle);
                        const normalizedAngleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                        
                        // Modulation d'amplitude bas√©e sur la proximit√© angulaire
                        let amplitudeModifier = 1;
                        if (normalizedAngleDiff < 0.1) {
                            amplitudeModifier = 1.5 + (0.1 - normalizedAngleDiff) * offRampsCircular2Modulation * 5;
                        } else if (normalizedAngleDiff < 0.2) {
                            amplitudeModifier = 1.2 + (0.2 - normalizedAngleDiff) * 1.5;
                        }
                        
                        // Appliquer la randomness circulaire
                        const connectionKey = `offramps-circ2-${conn.from}-${conn.to}-${conn.type}`;
                        const randomness = getRandomnessForConnection(connectionKey);
                        
                        if (offRampsCircular2Randomness > 0) {
                            const lengthVariation = (randomness.lengthRand - 0.5) * 2 * offRampsCircular2Randomness;
                            const curveVariation = (randomness.curveRand - 0.5) * 2 * offRampsCircular2Randomness;
                            const ampVariation = (randomness.ampRand - 0.5) * 2 * offRampsCircular2Randomness;
                            
                            amplitudeModifier *= (1 + ampVariation);
                        }
                        
                        let depthMultiplier = 1;
                        if (distance < offRampsCircular2MinCurveLength) {
                            depthMultiplier = 1 + (offRampsCircular2MinCurveLength - distance) / offRampsCircular2MinCurveLength * offRampsCircular2CurveSpacing;
                        }
                        
                        const baseRadius = Math.max(distance * 0.4, 50);
                        const curvatureRadius = baseRadius * depthMultiplier * amplitudeModifier;
                        
                        let midX = (fromPos.x + toPos.x) / 2;
                        let midY = (fromPos.y + toPos.y) / 2;
                        
                        // Appliquer variation al√©atoire aux positions du contr√¥le
                        if (offRampsCircular2Randomness > 0) {
                            const randomness2 = getRandomnessForConnection(connectionKey + '-mid');
                            midX += (randomness2.lengthRand - 0.5) * 2 * offRampsCircular2Randomness * 20;
                            midY += (randomness2.curveRand - 0.5) * 2 * offRampsCircular2Randomness * 20;
                        }
                        
                        const perpX = -dy / distance;
                        const perpY = dx / distance;
                        
                        const midToCenterX = center - midX;
                        const midToCenterY = center - midY;
                        const midToCenter = Math.sqrt(midToCenterX * midToCenterX + midToCenterY * midToCenterY);
                        
                        const normMidToCenterX = midToCenter > 0 ? midToCenterX / midToCenter : 0;
                        const normMidToCenterY = midToCenter > 0 ? midToCenterY / midToCenter : 0;
                        
                        const dotProduct = perpX * normMidToCenterX + perpY * normMidToCenterY;
                        const curveDir = dotProduct > 0 ? 1 : -1;
                        
                        const controlX = midX + perpX * curveDir * curvatureRadius * offRampsCircular2CurveDepth;
                        const controlY = midY + perpY * curveDir * curvatureRadius * offRampsCircular2CurveDepth;
                        
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const pathData = `M ${fromPos.x} ${fromPos.y} Q ${controlX} ${controlY} ${toPos.x} ${toPos.y}`;
                        path.setAttribute('d', pathData);
                        path.setAttribute('stroke', color);
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('opacity', '0.6');
                        path.setAttribute('marker-end', `url(#offramps-circ2-arrow-${conn.type})`);
                        canvas.appendChild(path);
                    }
                });
                
                // Cr√©er les d√©finitions pour les fl√®ches
                let defs = canvas.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    canvas.insertBefore(defs, canvas.firstChild);
                }
                
                if (!canvas.querySelector('#offramps-circ2-arrow-off-ramp')) {
                    const arrowOff = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    arrowOff.setAttribute('id', 'offramps-circ2-arrow-off-ramp');
                    arrowOff.setAttribute('markerWidth', '10');
                    arrowOff.setAttribute('markerHeight', '10');
                    arrowOff.setAttribute('refX', '7');
                    arrowOff.setAttribute('refY', '3');
                    arrowOff.setAttribute('orient', 'auto');
                    const polyOff = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polyOff.setAttribute('points', '0 0, 10 3, 0 6');
                    polyOff.setAttribute('fill', '#10B981');
                    arrowOff.appendChild(polyOff);
                    defs.appendChild(arrowOff);
                }
                
                // Dessiner les n≈ìuds
                const communityColors = {
                    'IT': '#3B82F6',
                    'CS': '#10B981',
                    'EN': '#8B5CF6',
                    'CE': '#92400E',
                    'CI': '#F59E0B',
                    'DA': '#14B8A6',
                    'SE': '#EF4444',
                    'Cx': '#6B7280'
                };
                
                allIds.forEach((item) => {
                    const num = item.id.split('_')[0];
                    const pos = positions[num];
                    if (!pos) return;
                    
                    const isSelected = offRampsSelectedCenters.has(num);
                    const isRamp = allRamps.has(num);
                    const community = item.community;
                    const baseColor = communityColors[community] || '#d0d0d0';
                    
                    let pointColor = baseColor;
                    let pointSize = 2;
                    let opacity = 0.5;
                    
                    if (isSelected) {
                        pointSize = 3;
                        opacity = 1;
                    } else if (isRamp) {
                        pointSize = 2.5;
                        opacity = 0.9;
                    }
                    
                    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    point.setAttribute('cx', pos.x);
                    point.setAttribute('cy', pos.y);
                    point.setAttribute('r', pointSize);
                    point.setAttribute('fill', pointColor);
                    point.setAttribute('opacity', opacity);
                    canvas.appendChild(point);
                    
                    const textRadius = radius + 40;
                    const angle = pos.angle;
                    const textX = center + textRadius * Math.cos(angle);
                    const textY = center + textRadius * Math.sin(angle);
                    
                    const textSize = isSelected ? '13px' : isRamp ? '11px' : '10px';
                    const textWeight = isSelected ? '700' : isRamp ? '600' : '400';
                    const textOpacity = isSelected || isRamp ? '1' : '0.7';
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', textSize);
                    text.setAttribute('font-weight', textWeight);
                    text.setAttribute('fill', baseColor);
                    text.setAttribute('opacity', textOpacity);
                    text.textContent = `${num}_${community}`;
                    canvas.appendChild(text);
                });
            } catch (error) {
                console.error('Erreur lors du rendu de la vue circulaire 2:', error);
                canvas.innerHTML = `<text x="400" y="400" text-anchor="middle" fill="#f00" font-size="14px">Erreur: ${error.message}</text>`;
            }
        }

        function toggleOffRampsCircular2CurveSettings() {
            const panel = document.getElementById('offRampsCircular2CurveSettingsPanel');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }

        function updateOffRampsCircular2CurveSettings() {
            offRampsCircular2CurveDepth = parseFloat(document.getElementById('offRampsCircular2CurveDepthSlider').value);
            offRampsCircular2CurveSpacing = parseFloat(document.getElementById('offRampsCircular2CurveSpacingSlider').value);
            offRampsCircular2MinCurveLength = parseFloat(document.getElementById('offRampsCircular2MinCurveLengthSlider').value);
            offRampsCircular2Modulation = parseFloat(document.getElementById('offRampsCircular2ModulationSlider').value);
            offRampsCircular2Randomness = parseFloat(document.getElementById('offRampsCircular2RandomnessSlider').value);
            
            document.getElementById('offRampsCircular2CurveDepthValue').textContent = offRampsCircular2CurveDepth.toFixed(2);
            document.getElementById('offRampsCircular2CurveSpacingValue').textContent = offRampsCircular2CurveSpacing.toFixed(1);
            document.getElementById('offRampsCircular2MinCurveLengthValue').textContent = offRampsCircular2MinCurveLength;
            document.getElementById('offRampsCircular2ModulationValue').textContent = offRampsCircular2Modulation.toFixed(1);
            document.getElementById('offRampsCircular2RandomnessValue').textContent = offRampsCircular2Randomness.toFixed(1);
            
            renderOffRampsCircular2Graph();
        }

        function offRampsCircular2ZoomIn() {
            offRampsCircular2Zoom = Math.min(offRampsCircular2Zoom + 0.2, 3);
            document.getElementById('offRampsCircular2ZoomLevel').textContent = Math.round(offRampsCircular2Zoom * 100);
            renderOffRampsCircular2Graph();
        }

        function offRampsCircular2ZoomOut() {
            offRampsCircular2Zoom = Math.max(offRampsCircular2Zoom - 0.2, 0.5);
            document.getElementById('offRampsCircular2ZoomLevel').textContent = Math.round(offRampsCircular2Zoom * 100);
            renderOffRampsCircular2Graph();
        }

        function offRampsCircular2FitToScreen() {
            offRampsCircular2Zoom = 1;
            document.getElementById('offRampsCircular2ZoomLevel').textContent = '100';
            const wrapper = document.getElementById('offRampsCircular2CanvasWrapper');
            if (wrapper) {
                wrapper.scrollLeft = 0;
                wrapper.scrollTop = 0;
            }
            renderOffRampsCircular2Graph();
        }

        // Vue R√©seau (bas√©e sur RIP_LABS)
        function renderOffRampsNetworkGraph() {
            const canvasWrapper = document.getElementById('offRampsNetworkCanvasWrapper');
            const canvasId = 'offRampsNetworkCanvas';
            if (!canvasWrapper) {
                console.error('Wrapper offRampsNetworkCanvasWrapper introuvable');
                return;
            }
            
            // Nettoyer le wrapper
            canvasWrapper.innerHTML = '';
            if (offRampsNetworkSimulation) {
                offRampsNetworkSimulation.stop();
            }
            
            try {
                // Obtenir les dimensions
                const width = canvasWrapper.clientWidth || 1200;
                const height = canvasWrapper.clientHeight || 600;
                
                // Convertir niceFramework en format nodes/links
                const { nodes: dataNodes, links: dataLinks } = convertNiceFrameworkToNodesLinks();
                
                if (!dataNodes || dataNodes.length === 0) {
                    const errorText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    errorText.setAttribute('x', width / 2);
                    errorText.setAttribute('y', height / 2);
                    errorText.setAttribute('text-anchor', 'middle');
                    errorText.setAttribute('fill', '#666');
                    errorText.setAttribute('font-size', '16px');
                    errorText.textContent = 'Aucune donn√©e disponible';
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('id', canvasId);
                    svg.setAttribute('width', width);
                    svg.setAttribute('height', height);
                    svg.appendChild(errorText);
                    canvasWrapper.appendChild(svg);
                    return;
                }
                
                // Obtenir les communaut√©s
                const allIds = getAllOpmIds();
                const idToCommunity = {};
                allIds.forEach(item => {
                    const num = item.id.split('_')[0];
                    idToCommunity[num] = item.community;
                });
                
                const communityColors = {
                    'IT': '#3B82F6',
                    'CS': '#10B981',
                    'EN': '#8B5CF6',
                    'CE': '#92400E',
                    'CI': '#F59E0B',
                    'DA': '#14B8A6',
                    'SE': '#EF4444',
                    'Cx': '#6B7280'
                };
                
                // Cr√©er les n≈ìuds pour D3
                const nodes = dataNodes.map(node => ({
                    id: node.id,
                    group: idToCommunity[node.id] || 'Unknown',
                    num: node.id
                }));
                
                // Cr√©er les liens pour D3 (s'assurer que source et target sont des objets)
                const links = dataLinks.map(link => ({
                    source: link.source,
                    target: link.target
                }));
                
                // Cr√©er le SVG avec D3
                const svg = d3.select(canvasWrapper)
                    .append('svg')
                    .attr('id', canvasId)
                    .attr('width', width)
                    .attr('height', height);
                
                const g = svg.append('g');
                
                // Ajouter le zoom avec la molette de la souris
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 5])
                    .on('zoom', function(event) {
                        offRampsNetworkZoom = event.transform.k;
                        const zoomLevelEl = document.getElementById('offRampsNetworkZoomLevel');
                        if (zoomLevelEl) {
                            zoomLevelEl.textContent = Math.round(offRampsNetworkZoom * 100);
                        }
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
                // Cr√©er les d√©finitions pour les fl√®ches (off-ramps)
                const defs = svg.append('defs');
                const arrowMarker = defs.append('marker')
                    .attr('id', 'offramps-network-arrow')
                    .attr('markerWidth', 12)
                    .attr('markerHeight', 12)
                    .attr('refX', 10)
                    .attr('refY', 6)
                    .attr('orient', 'auto')
                    .attr('markerUnits', 'userSpaceOnUse');
                arrowMarker.append('polygon')
                    .attr('points', '0 0, 12 6, 0 12')
                    .attr('fill', '#10B981');
                
                // Cr√©er la simulation de force (sans confinement pour permettre aux n≈ìuds de sortir du cadre)
                const nodeRadius = 18; // Taille augment√©e des n≈ìuds
                
                offRampsNetworkSimulation = d3.forceSimulation(nodes)
                    .force('link', d3.forceLink(links).id(d => d.id).distance(120).strength(0.3))
                    .force('charge', d3.forceManyBody().strength(-500))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(nodeRadius + 5));
                
                // Dessiner les liens avec fl√®ches directionnelles
                const link = g.append('g')
                    .attr('class', 'links')
                    .selectAll('line')
                    .data(links)
                    .enter()
                    .append('line')
                    .attr('class', 'link')
                    .attr('stroke', '#10B981')
                    .attr('stroke-opacity', 0.7)
                    .attr('stroke-width', 1.5)
                    .attr('marker-end', 'url(#offramps-network-arrow)');
                
                // Dessiner les n≈ìuds (taille augment√©e)
                const node = g.append('g')
                    .attr('class', 'nodes')
                    .selectAll('circle')
                    .data(nodes)
                    .enter()
                    .append('circle')
                    .attr('class', 'node')
                    .attr('r', nodeRadius)
                    .attr('fill', d => communityColors[d.group] || '#d0d0d0')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 2)
                    .style('cursor', 'pointer')
                    .on('click', function(event, d) {
                        selectOffRampsNetworkNode(event, d, node, link, links);
                    })
                    .call(d3.drag()
                        .filter(function(event) {
                            // Permettre le drag seulement avec le bouton gauche de la souris
                            return event.button === 0;
                        })
                        .on('start', dragstartedNetwork)
                        .on('drag', draggedNetwork)
                        .on('end', dragendedNetwork));
                
                // Dessiner les labels avec fond pour meilleure lisibilit√©
                const labels = g.append('g')
                    .attr('class', 'labels')
                    .selectAll('g')
                    .data(nodes)
                    .enter()
                    .append('g');
                
                // Fond pour les labels
                labels.append('rect')
                    .attr('x', -35)
                    .attr('y', -8)
                    .attr('width', 70)
                    .attr('height', 16)
                    .attr('rx', 4)
                    .attr('fill', 'rgba(0, 0, 0, 0.7)')
                    .attr('stroke', 'rgba(255, 255, 255, 0.3)')
                    .attr('stroke-width', 1);
                
                // Texte des labels
                labels.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '.3em')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold')
                    .attr('font-size', '11px')
                    .text(d => {
                        const community = idToCommunity[d.id] || 'Unknown';
                        return `${d.id}_${community}`;
                    })
                    .style('pointer-events', 'none');
                
                // Mettre √† jour la simulation
                const strokeWidth = 2;
                const totalRadius = nodeRadius + strokeWidth;
                
                offRampsNetworkSimulation.on('tick', () => {
                    // Pas de confinement - les n≈ìuds peuvent sortir du cadre
                    
                    link.each(function(d) {
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            // Point de d√©part (au bord du n≈ìud source)
                            const startX = d.source.x + (dx / distance) * totalRadius;
                            const startY = d.source.y + (dy / distance) * totalRadius;
                            
                            // Point d'arriv√©e (au bord du n≈ìud cible, avec espace pour la fl√®che)
                            const arrowOffset = 15; // Espace pour la fl√®che (augment√©)
                            const endX = d.target.x - (dx / distance) * (totalRadius + arrowOffset);
                            const endY = d.target.y - (dy / distance) * (totalRadius + arrowOffset);
                            
                            d3.select(this)
                                .attr('x1', startX)
                                .attr('y1', startY)
                                .attr('x2', endX)
                                .attr('y2', endY);
                        }
                    });
                    
                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                    
                    labels
                        .attr('transform', d => `translate(${d.x}, ${d.y})`);
                });
                
                // Ajuster automatiquement la vue apr√®s la simulation pour que tous les n≈ìuds soient visibles
                offRampsNetworkSimulation.on('end', () => {
                    adjustOffRampsNetworkView();
                });
                
                // Appliquer le zoom initial
                applyOffRampsNetworkZoom();
                
            } catch (error) {
                console.error('Erreur lors du rendu de la vue r√©seau:', error);
                const errorText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                errorText.setAttribute('x', '400');
                errorText.setAttribute('y', '300');
                errorText.setAttribute('text-anchor', 'middle');
                errorText.setAttribute('fill', '#f00');
                errorText.setAttribute('font-size', '14px');
                errorText.textContent = `Erreur: ${error.message}`;
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('id', canvasId);
                svg.setAttribute('width', '800');
                svg.setAttribute('height', '600');
                svg.appendChild(errorText);
                canvasWrapper.appendChild(svg);
            }
        }
        
        function selectOffRampsNetworkNode(event, d, node, link, links) {
            offRampsNetworkSelectedNode = d;
            
            const connected = new Set([d.id]);
            links.forEach(l => {
                const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                if (sourceId === d.id) connected.add(targetId);
                if (targetId === d.id) connected.add(sourceId);
            });
            
            node.classed('faded', nodeData => !connected.has(nodeData.id))
                .classed('highlighted', nodeData => nodeData.id === d.id);
            
            link.classed('faded', l => {
                const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                const isDirect = sourceId === d.id || targetId === d.id;
                const bothConnected = connected.has(sourceId) && connected.has(targetId);
                return !(isDirect || bothConnected);
            })
            .classed('highlighted', l => {
                const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                return sourceId === d.id || targetId === d.id;
            });
            
            // Afficher la carte "principale" dans le header
            const headerSection = document.getElementById('offRampsNetworkHeaderSection');
            const selectedRoleSpan = document.getElementById('offRampsNetworkSelectedRole');
            if (headerSection && selectedRoleSpan) {
                selectedRoleSpan.textContent = d.id;
                headerSection.style.display = 'flex';
            }
        }
        
        function dragstartedNetwork(event) {
            // Emp√™cher le zoom pendant le drag
            if (event.sourceEvent) {
                event.sourceEvent.stopPropagation();
            }
            if (!event.active) offRampsNetworkSimulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        
        function draggedNetwork(event) {
            // d3.drag g√®re automatiquement les transformations de zoom
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        
        function dragendedNetwork(event) {
            if (!event.active) offRampsNetworkSimulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        
        function applyOffRampsNetworkZoom() {
            const canvasWrapper = document.getElementById('offRampsNetworkCanvasWrapper');
            if (!canvasWrapper) return;
            const svg = d3.select(canvasWrapper).select('svg');
            if (svg.empty()) return;
            
            // Appliquer la transformation de zoom via d3.zoom
            const currentTransform = d3.zoomTransform(svg.node());
            const newTransform = d3.zoomIdentity
                .translate(currentTransform.x, currentTransform.y)
                .scale(offRampsNetworkZoom);
            
            svg.call(d3.zoom().transform, newTransform);
        }
        
        function offRampsNetworkZoomIn() {
            offRampsNetworkZoom = Math.min(offRampsNetworkZoom * 1.2, 5);
            document.getElementById('offRampsNetworkZoomLevel').textContent = Math.round(offRampsNetworkZoom * 100);
            applyOffRampsNetworkZoom();
        }
        
        function offRampsNetworkZoomOut() {
            offRampsNetworkZoom = Math.max(offRampsNetworkZoom / 1.2, 0.1);
            document.getElementById('offRampsNetworkZoomLevel').textContent = Math.round(offRampsNetworkZoom * 100);
            applyOffRampsNetworkZoom();
        }
        
        function offRampsNetworkResetZoom() {
            offRampsNetworkZoom = 1;
            document.getElementById('offRampsNetworkZoomLevel').textContent = '100';
            applyOffRampsNetworkZoom();
        }
        
        function offRampsNetworkFitToScreen() {
            // Ajuster automatiquement le zoom pour que tous les n≈ìuds soient visibles
            const canvasWrapper = document.getElementById('offRampsNetworkCanvasWrapper');
            if (!canvasWrapper || !offRampsNetworkSimulation) return;
            
            const svg = canvasWrapper.querySelector('svg');
            if (!svg) return;
            
            const nodes = offRampsNetworkSimulation.nodes();
            if (!nodes || nodes.length === 0) return;
            
            // Trouver les limites de tous les n≈ìuds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            nodes.forEach(d => {
                if (d.x !== undefined && d.y !== undefined) {
                    const nodeRadius = 18;
                    minX = Math.min(minX, d.x - nodeRadius);
                    maxX = Math.max(maxX, d.x + nodeRadius);
                    minY = Math.min(minY, d.y - nodeRadius);
                    maxY = Math.max(maxY, d.y + nodeRadius);
                }
            });
            
            if (minX === Infinity) return; // Aucun n≈ìud valide
            
            // Ajouter un padding
            const padding = 80;
            const boundsWidth = maxX - minX + padding * 2;
            const boundsHeight = maxY - minY + padding * 2;
            
            const svgWidth = parseFloat(svg.getAttribute('width'));
            const svgHeight = parseFloat(svg.getAttribute('height'));
            
            // Calculer le zoom n√©cessaire pour que tout soit visible
            const scaleX = svgWidth / boundsWidth;
            const scaleY = svgHeight / boundsHeight;
            const optimalZoom = Math.min(scaleX, scaleY) * 0.95; // 0.95 pour un peu de marge
            
            if (optimalZoom > 0) {
                offRampsNetworkZoom = optimalZoom;
                document.getElementById('offRampsNetworkZoomLevel').textContent = Math.round(offRampsNetworkZoom * 100);
                applyOffRampsNetworkZoom();
            }
        }
        
        function adjustOffRampsNetworkView() {
            // Ajuster automatiquement le zoom pour que tous les n≈ìuds soient visibles
            const canvasWrapper = document.getElementById('offRampsNetworkCanvasWrapper');
            if (!canvasWrapper || !offRampsNetworkSimulation) return;
            
            const svg = canvasWrapper.querySelector('svg');
            if (!svg) return;
            
            const nodes = offRampsNetworkSimulation.nodes();
            if (!nodes || nodes.length === 0) return;
            
            // Trouver les limites de tous les n≈ìuds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            nodes.forEach(d => {
                if (d.x !== undefined && d.y !== undefined) {
                    minX = Math.min(minX, d.x);
                    maxX = Math.max(maxX, d.x);
                    minY = Math.min(minY, d.y);
                    maxY = Math.max(maxY, d.y);
                }
            });
            
            if (minX === Infinity) return; // Aucun n≈ìud valide
            
            // Ajouter un padding
            const padding = 100;
            const nodeRadius = 18;
            const boundsWidth = maxX - minX + (nodeRadius + padding) * 2;
            const boundsHeight = maxY - minY + (nodeRadius + padding) * 2;
            
            const svgWidth = parseFloat(svg.getAttribute('width'));
            const svgHeight = parseFloat(svg.getAttribute('height'));
            
            // Calculer le zoom n√©cessaire pour que tout soit visible
            const scaleX = svgWidth / boundsWidth;
            const scaleY = svgHeight / boundsHeight;
            const optimalZoom = Math.min(scaleX, scaleY, 1) * 0.9; // 0.9 pour un peu de marge
            
            if (optimalZoom > 0 && optimalZoom < 1) {
                offRampsNetworkZoom = optimalZoom;
                document.getElementById('offRampsNetworkZoomLevel').textContent = Math.round(offRampsNetworkZoom * 100);
                applyOffRampsNetworkZoom();
            }
        }

        // ========== FONCTIONS POUR PR√âDICTION ==========
        let predictionCurrentTab = 'off-ramps';
        let predictionSelectedOpmId = null;

        function switchPredictionTab(tab) {
            predictionCurrentTab = tab;
            document.querySelectorAll('#predictionContent .tab-button').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(tab === 'off-ramps' ? 'Off-Ramps' : 'On-Ramps')) {
                    btn.classList.add('active');
                }
            });
            
            if (tab === 'off-ramps') {
                document.getElementById('predictionOffRampsView').style.display = 'block';
                document.getElementById('predictionOnRampsView').style.display = 'none';
            } else {
                document.getElementById('predictionOffRampsView').style.display = 'none';
                document.getElementById('predictionOnRampsView').style.display = 'block';
            }
        }

        function renderPredictionLists() {
            renderPredictionOffRampsList();
            renderPredictionOnRampsList();
        }

        function renderPredictionOffRampsList() {
            const listContainer = document.getElementById('predictionOffRampsList');
            if (!listContainer) return;

            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });

            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };

            const allOpmNums = Object.keys(niceFramework).sort((a, b) => {
                const aNum = isNaN(parseInt(a)) ? Infinity : parseInt(a);
                const bNum = isNaN(parseInt(b)) ? Infinity : parseInt(b);
                if (aNum === Infinity && bNum === Infinity) return a.localeCompare(b);
                if (aNum === Infinity) return 1;
                if (bNum === Infinity) return -1;
                return aNum - bNum;
            });

            let html = '';
            allOpmNums.forEach(num => {
                const community = idToCommunity[num] || 'Unknown';
                const color = communityColors[community] || '#d0d0d0';
                const isSelected = predictionSelectedOpmId === num && predictionCurrentTab === 'off-ramps';
                
                html += `
                    <div class="prediction-opm-item ${isSelected ? 'selected' : ''}" 
                         onclick="selectPredictionOpmId('${num}', 'off-ramps')"
                         style="${isSelected ? 'background: #10B981; color: white;' : ''}">
                        <div style="font-weight: 600; color: ${isSelected ? 'white' : color};">${num}</div>
                        <div style="font-size: 11px; color: ${isSelected ? 'rgba(255,255,255,0.7)' : '#6b7280'}; margin-top: 4px;">${community}</div>
                    </div>
                `;
            });

            listContainer.innerHTML = html;
        }

        function renderPredictionOnRampsList() {
            const listContainer = document.getElementById('predictionOnRampsList');
            if (!listContainer) return;

            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });

            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };

            const allOpmNums = Object.keys(niceFramework).sort((a, b) => {
                const aNum = isNaN(parseInt(a)) ? Infinity : parseInt(a);
                const bNum = isNaN(parseInt(b)) ? Infinity : parseInt(b);
                if (aNum === Infinity && bNum === Infinity) return a.localeCompare(b);
                if (aNum === Infinity) return 1;
                if (bNum === Infinity) return -1;
                return aNum - bNum;
            });

            let html = '';
            allOpmNums.forEach(num => {
                const community = idToCommunity[num] || 'Unknown';
                const color = communityColors[community] || '#d0d0d0';
                const isSelected = predictionSelectedOpmId === num && predictionCurrentTab === 'on-ramps';
                
                html += `
                    <div class="prediction-opm-item ${isSelected ? 'selected' : ''}" 
                         onclick="selectPredictionOpmId('${num}', 'on-ramps')"
                         style="${isSelected ? 'background: #3B82F6; color: white;' : ''}">
                        <div style="font-weight: 600; color: ${isSelected ? 'white' : color};">${num}</div>
                        <div style="font-size: 11px; color: ${isSelected ? 'rgba(255,255,255,0.7)' : '#6b7280'}; margin-top: 4px;">${community}</div>
                    </div>
                `;
            });

            listContainer.innerHTML = html;
        }

        function selectPredictionOpmId(opmId, type) {
            predictionSelectedOpmId = opmId;
            
            if (type === 'off-ramps') {
                renderPredictionOffRampsList();
                renderPredictionOffRampsGraph(opmId);
            } else {
                renderPredictionOnRampsList();
                renderPredictionOnRampsGraph(opmId);
            }
        }

        function renderPredictionOffRampsGraph(startOpmId) {
            const graphContainer = document.getElementById('predictionOffRampsGraph');
            if (!graphContainer) return;

            graphContainer.innerHTML = '';
            
            // Collecter tous les n≈ìuds et liens r√©cursivement
            const nodes = new Map();
            const links = [];
            const visited = new Set();
            
            function collectOffRamps(opmId, depth = 0, maxDepth = 5) {
                if (depth > maxDepth || visited.has(opmId)) return;
                visited.add(opmId);
                
                if (!nodes.has(opmId)) {
                    nodes.set(opmId, { id: opmId, depth: depth });
                }
                
                const data = niceFramework[opmId];
                if (data && data.off_ramps) {
                    data.off_ramps.forEach(targetId => {
                        if (!nodes.has(targetId)) {
                            nodes.set(targetId, { id: targetId, depth: depth + 1 });
                        }
                        links.push({ source: opmId, target: targetId });
                        collectOffRamps(targetId, depth + 1, maxDepth);
                    });
                }
            }
            
            collectOffRamps(startOpmId);
            
            if (nodes.size === 0) {
                graphContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #9ca3af;"><p>Aucun off-ramp disponible pour cet OPM-ID</p></div>';
                return;
            }
            
            // Obtenir les communaut√©s
            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });
            
            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };
            
            // Cr√©er le SVG
            const width = graphContainer.clientWidth || 800;
            const height = graphContainer.clientHeight || 600;
            
            const svg = d3.select(graphContainer)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g');
            
            // Cr√©er les d√©finitions pour les fl√®ches (normal et estomp√©)
            const defs = svg.append('defs');
            
            // Fl√®che normale (verte)
            const arrowMarker = defs.append('marker')
                .attr('id', 'prediction-arrow')
                .attr('markerWidth', 12)
                .attr('markerHeight', 12)
                .attr('refX', 10)
                .attr('refY', 6)
                .attr('orient', 'auto')
                .attr('markerUnits', 'userSpaceOnUse');
            arrowMarker.append('polygon')
                .attr('points', '0 0, 12 6, 0 12')
                .attr('fill', '#10B981')
                .attr('opacity', 1);
            
            // Fl√®che estomp√©e (verte avec faible opacit√©)
            const arrowMarkerFaded = defs.append('marker')
                .attr('id', 'prediction-arrow-faded')
                .attr('markerWidth', 12)
                .attr('markerHeight', 12)
                .attr('refX', 10)
                .attr('refY', 6)
                .attr('orient', 'auto')
                .attr('markerUnits', 'userSpaceOnUse');
            arrowMarkerFaded.append('polygon')
                .attr('points', '0 0, 12 6, 0 12')
                .attr('fill', '#10B981')
                .attr('opacity', 0.1);
            
            // Convertir les n≈ìuds en array avec marqueur pour le n≈ìud de d√©part
            const nodesArray = Array.from(nodes.values()).map(node => ({
                id: node.id,
                group: idToCommunity[node.id] || 'Unknown',
                depth: node.depth,
                isStart: node.id === startOpmId
            }));
            
            // Organiser les n≈ìuds par profondeur pour un layout hi√©rarchique
            const nodesByDepth = new Map();
            nodesArray.forEach(node => {
                if (!nodesByDepth.has(node.depth)) {
                    nodesByDepth.set(node.depth, []);
                }
                nodesByDepth.get(node.depth).push(node);
            });
            
            // Calculer les positions initiales pour un layout hi√©rarchique
            const maxDepth = Math.max(...nodesArray.map(n => n.depth));
            const columnWidth = width / (maxDepth + 1);
            const padding = 50;
            
            nodesArray.forEach(node => {
                const depthNodes = nodesByDepth.get(node.depth);
                const index = depthNodes.indexOf(node);
                const totalInDepth = depthNodes.length;
                const spacing = (height - 2 * padding) / Math.max(1, totalInDepth - 1);
                
                // Position initiale pour un layout hi√©rarchique
                node.fx = padding + node.depth * columnWidth;
                node.fy = padding + index * spacing;
            });
            
            // Cr√©er les liens en r√©f√©ren√ßant les objets n≈ìuds
            const nodeMap = new Map(nodesArray.map(n => [n.id, n]));
            const linksArray = links.map(link => ({
                source: nodeMap.get(link.source),
                target: nodeMap.get(link.target)
            })).filter(l => l.source && l.target);
            
            // Cr√©er la simulation de force avec layout hi√©rarchique
            const simulation = d3.forceSimulation(nodesArray)
                .force('link', d3.forceLink(linksArray).id(d => d.id).distance(120).strength(0.8))
                .force('charge', d3.forceManyBody().strength(-600))
                .force('collision', d3.forceCollide().radius(30))
                .force('x', d3.forceX().x(d => {
                    const depthNodes = nodesByDepth.get(d.depth);
                    const index = depthNodes.indexOf(d);
                    const totalInDepth = depthNodes.length;
                    const spacing = (height - 2 * padding) / Math.max(1, totalInDepth - 1);
                    return padding + d.depth * columnWidth;
                }).strength(0.8))
                .force('y', d3.forceY().y(d => {
                    const depthNodes = nodesByDepth.get(d.depth);
                    const index = depthNodes.indexOf(d);
                    const totalInDepth = depthNodes.length;
                    const spacing = (height - 2 * padding) / Math.max(1, totalInDepth - 1);
                    return padding + index * spacing;
                }).strength(0.8));
            
            // Dessiner les liens
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(linksArray)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke', '#10B981')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 2)
                .attr('marker-end', 'url(#prediction-arrow)')
                .style('pointer-events', 'none');
            
            // Dessiner les n≈ìuds
            const nodeRadius = 20;
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodesArray)
                .enter()
                .append('circle')
                .attr('class', 'node')
                .attr('r', nodeRadius)
                .attr('fill', d => communityColors[d.group] || '#d0d0d0')
                .attr('stroke', d => d.isStart ? '#FCD34D' : 'white')
                .attr('stroke-width', d => d.isStart ? 4 : 3)
                .style('cursor', 'pointer');
            
            // Dessiner les labels
            const labels = g.append('g')
                .attr('class', 'labels')
                .selectAll('g')
                .data(nodesArray)
                .enter()
                .append('g');
            
            labels.append('rect')
                .attr('x', -35)
                .attr('y', -10)
                .attr('width', 70)
                .attr('height', 20)
                .attr('rx', 4)
                .attr('fill', d => d.isStart ? 'rgba(234, 179, 8, 0.9)' : 'rgba(0, 0, 0, 0.7)')
                .attr('stroke', d => d.isStart ? 'rgba(234, 179, 8, 1)' : 'rgba(255, 255, 255, 0.3)')
                .attr('stroke-width', d => d.isStart ? 2 : 1);
            
            labels.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '.3em')
                .attr('fill', d => d.isStart ? '#000' : 'white')
                .attr('font-weight', 'bold')
                .attr('font-size', d => d.isStart ? '13px' : '12px')
                .text(d => {
                    const community = idToCommunity[d.id] || 'Unknown';
                    return `${d.id}_${community}`;
                })
                .style('pointer-events', 'none');
            
            // Variable pour suivre le n≈ìud s√©lectionn√©
            let selectedNodeId = null;
            
            // Fonction pour mettre en √©vidence les connexions
            function highlightConnections(nodeId) {
                selectedNodeId = nodeId;
                const connectedIds = new Set([nodeId]);
                
                // Trouver tous les n≈ìuds connect√©s
                linksArray.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    if (sourceId === nodeId) {
                        connectedIds.add(targetId);
                    }
                    if (targetId === nodeId) {
                        connectedIds.add(sourceId);
                    }
                });
                
                // Mettre √† jour les n≈ìuds
                node
                    .classed('highlighted', d => d.id === nodeId)
                    .classed('connected', d => connectedIds.has(d.id) && d.id !== nodeId)
                    .classed('faded', d => !connectedIds.has(d.id))
                    .attr('opacity', d => connectedIds.has(d.id) ? 1 : 0.2)
                    .attr('stroke-width', d => {
                        if (d.id === nodeId) return 5;
                        if (connectedIds.has(d.id)) return 4;
                        return d.isStart ? 4 : 3;
                    });
                
                // Mettre √† jour les labels
                labels
                    .classed('highlighted', d => d.id === nodeId)
                    .classed('connected', d => connectedIds.has(d.id) && d.id !== nodeId)
                    .classed('faded', d => !connectedIds.has(d.id))
                    .attr('opacity', d => connectedIds.has(d.id) ? 1 : 0.2);
                
                // Mettre √† jour les liens
                link
                    .classed('highlighted', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        return sourceId === nodeId || targetId === nodeId;
                    })
                    .classed('faded', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        return sourceId !== nodeId && targetId !== nodeId;
                    })
                    .attr('stroke-opacity', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        return (sourceId === nodeId || targetId === nodeId) ? 1 : 0.1;
                    })
                    .attr('marker-end', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        const isHighlighted = (sourceId === nodeId || targetId === nodeId);
                        // Utiliser le marqueur appropri√© selon l'√©tat
                        // Pour on-ramps, utiliser prediction-onramps-arrow, pour off-ramps utiliser prediction-arrow
                        const isOnRamps = !svg.select('defs marker#prediction-onramps-arrow').empty();
                        const markerBase = isOnRamps ? 'prediction-onramps-arrow' : 'prediction-arrow';
                        return isHighlighted ? `url(#${markerBase})` : `url(#${markerBase}-faded)`;
                    })
                    .attr('stroke-width', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        return (sourceId === nodeId || targetId === nodeId) ? 3 : 1;
                    });
            }
            
            // Fonction pour r√©initialiser la s√©lection
            function resetHighlight() {
                selectedNodeId = null;
                node
                    .classed('highlighted', false)
                    .classed('connected', false)
                    .classed('faded', false)
                    .attr('opacity', 1)
                    .attr('stroke-width', d => d.isStart ? 4 : 3);
                
                labels
                    .classed('highlighted', false)
                    .classed('connected', false)
                    .classed('faded', false)
                    .attr('opacity', 1);
                
                link
                    .classed('highlighted', false)
                    .classed('faded', false)
                    .attr('stroke-opacity', 0.6)
                    .attr('marker-end', function() {
                        // D√©tecter si c'est on-ramps ou off-ramps
                        const isOnRamps = !svg.select('defs marker#prediction-onramps-arrow').empty();
                        const markerBase = isOnRamps ? 'prediction-onramps-arrow' : 'prediction-arrow';
                        return `url(#${markerBase})`;
                    })
                    .attr('stroke-width', 2);
            }
            
            // Ajouter les gestionnaires de clic
            node.on('click', function(event, d) {
                event.stopPropagation();
                if (selectedNodeId === d.id) {
                    resetHighlight();
                } else {
                    highlightConnections(d.id);
                }
            });
            
            labels
                .style('cursor', 'pointer')
                .on('click', function(event, d) {
                    event.stopPropagation();
                    if (selectedNodeId === d.id) {
                        resetHighlight();
                    } else {
                        highlightConnections(d.id);
                    }
                });
            
            // Permettre de r√©initialiser en cliquant sur le fond
            svg.on('click', function(event) {
                if (event.target === svg.node() || event.target === g.node()) {
                    resetHighlight();
                }
            });
            
            // Mettre √† jour la simulation
            const strokeWidth = 3;
            const totalRadius = nodeRadius + strokeWidth;
            
            simulation.on('tick', () => {
                link.each(function(d) {
                    const sourceNode = typeof d.source === 'object' ? d.source : nodesArray.find(n => n.id === d.source);
                    const targetNode = typeof d.target === 'object' ? d.target : nodesArray.find(n => n.id === d.target);
                    if (!sourceNode || !targetNode || !sourceNode.x || !targetNode.x) return;
                    
                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const startX = sourceNode.x + (dx / distance) * totalRadius;
                        const startY = sourceNode.y + (dy / distance) * totalRadius;
                        const arrowOffset = 18;
                        const endX = targetNode.x - (dx / distance) * (totalRadius + arrowOffset);
                        const endY = targetNode.y - (dy / distance) * (totalRadius + arrowOffset);
                        
                        d3.select(this)
                            .attr('x1', startX)
                            .attr('y1', startY)
                            .attr('x2', endX)
                            .attr('y2', endY);
                    }
                });
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                labels
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
            });
            
            // Lib√©rer les positions fixes apr√®s la simulation pour permettre le drag
            simulation.on('end', () => {
                nodesArray.forEach(node => {
                    node.fx = null;
                    node.fy = null;
                });
            });
            
            // Ajouter le zoom
            const zoom = d3.zoom()
                .scaleExtent([0.1, 5])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
        }

        function renderPredictionOnRampsGraph(startOpmId) {
            const graphContainer = document.getElementById('predictionOnRampsGraph');
            if (!graphContainer) return;

            graphContainer.innerHTML = '';
            
            // Collecter tous les n≈ìuds et liens r√©cursivement
            // Les on-ramps d'un OPM-ID sont les OPM-ID qui ont cet OPM-ID dans leurs off-ramps
            const nodes = new Map();
            const links = [];
            const visited = new Set();
            
            function collectOnRamps(opmId, depth = 0, maxDepth = 5) {
                if (depth > maxDepth || visited.has(opmId)) return;
                visited.add(opmId);
                
                if (!nodes.has(opmId)) {
                    nodes.set(opmId, { id: opmId, depth: depth });
                }
                
                // Trouver tous les OPM-ID qui ont opmId dans leurs off-ramps
                Object.keys(niceFramework).forEach(sourceId => {
                    const data = niceFramework[sourceId];
                    if (data && data.off_ramps && data.off_ramps.includes(opmId)) {
                        if (!nodes.has(sourceId)) {
                            nodes.set(sourceId, { id: sourceId, depth: depth + 1 });
                        }
                        links.push({ source: sourceId, target: opmId });
                        collectOnRamps(sourceId, depth + 1, maxDepth);
                    }
                });
            }
            
            collectOnRamps(startOpmId);
            
            if (nodes.size === 0) {
                graphContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #9ca3af;"><p>Aucun on-ramp disponible pour cet OPM-ID</p></div>';
                return;
            }
            
            // Obtenir les communaut√©s
            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });
            
            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };
            
            // Cr√©er le SVG
            const width = graphContainer.clientWidth || 800;
            const height = graphContainer.clientHeight || 600;
            
            const svg = d3.select(graphContainer)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g');
            
            // Cr√©er les d√©finitions pour les fl√®ches (bleu pour on-ramps - normal et estomp√©)
            const defs = svg.append('defs');
            
            // Fl√®che normale (bleue)
            const arrowMarker = defs.append('marker')
                .attr('id', 'prediction-onramps-arrow')
                .attr('markerWidth', 12)
                .attr('markerHeight', 12)
                .attr('refX', 10)
                .attr('refY', 6)
                .attr('orient', 'auto')
                .attr('markerUnits', 'userSpaceOnUse');
            arrowMarker.append('polygon')
                .attr('points', '0 0, 12 6, 0 12')
                .attr('fill', '#3B82F6')
                .attr('opacity', 1);
            
            // Fl√®che estomp√©e (bleue avec faible opacit√©)
            const arrowMarkerFaded = defs.append('marker')
                .attr('id', 'prediction-onramps-arrow-faded')
                .attr('markerWidth', 12)
                .attr('markerHeight', 12)
                .attr('refX', 10)
                .attr('refY', 6)
                .attr('orient', 'auto')
                .attr('markerUnits', 'userSpaceOnUse');
            arrowMarkerFaded.append('polygon')
                .attr('points', '0 0, 12 6, 0 12')
                .attr('fill', '#3B82F6')
                .attr('opacity', 0.1);
            
            // Convertir les n≈ìuds en array avec marqueur pour le n≈ìud de d√©part
            const nodesArray = Array.from(nodes.values()).map(node => ({
                id: node.id,
                group: idToCommunity[node.id] || 'Unknown',
                depth: node.depth,
                isStart: node.id === startOpmId
            }));
            
            // Organiser les n≈ìuds par profondeur pour un layout hi√©rarchique
            const nodesByDepth = new Map();
            nodesArray.forEach(node => {
                if (!nodesByDepth.has(node.depth)) {
                    nodesByDepth.set(node.depth, []);
                }
                nodesByDepth.get(node.depth).push(node);
            });
            
            // Calculer les positions initiales pour un layout hi√©rarchique
            const maxDepth = Math.max(...nodesArray.map(n => n.depth));
            const columnWidth = width / (maxDepth + 1);
            const padding = 50;
            
            nodesArray.forEach(node => {
                const depthNodes = nodesByDepth.get(node.depth);
                const index = depthNodes.indexOf(node);
                const totalInDepth = depthNodes.length;
                const spacing = (height - 2 * padding) / Math.max(1, totalInDepth - 1);
                
                // Position initiale pour un layout hi√©rarchique
                node.fx = padding + node.depth * columnWidth;
                node.fy = padding + index * spacing;
            });
            
            // Cr√©er les liens en r√©f√©ren√ßant les objets n≈ìuds
            const nodeMap = new Map(nodesArray.map(n => [n.id, n]));
            const linksArray = links.map(link => ({
                source: nodeMap.get(link.source),
                target: nodeMap.get(link.target)
            })).filter(l => l.source && l.target);
            
            // Cr√©er la simulation de force avec layout hi√©rarchique
            const simulation = d3.forceSimulation(nodesArray)
                .force('link', d3.forceLink(linksArray).id(d => d.id).distance(120).strength(0.8))
                .force('charge', d3.forceManyBody().strength(-600))
                .force('collision', d3.forceCollide().radius(30))
                .force('x', d3.forceX().x(d => {
                    const depthNodes = nodesByDepth.get(d.depth);
                    const index = depthNodes.indexOf(d);
                    const totalInDepth = depthNodes.length;
                    const spacing = (height - 2 * padding) / Math.max(1, totalInDepth - 1);
                    return padding + d.depth * columnWidth;
                }).strength(0.8))
                .force('y', d3.forceY().y(d => {
                    const depthNodes = nodesByDepth.get(d.depth);
                    const index = depthNodes.indexOf(d);
                    const totalInDepth = depthNodes.length;
                    const spacing = (height - 2 * padding) / Math.max(1, totalInDepth - 1);
                    return padding + index * spacing;
                }).strength(0.8));
            
            // Dessiner les liens
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('line')
                .data(linksArray)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke', '#3B82F6')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 2)
                .attr('marker-end', 'url(#prediction-onramps-arrow)');
            
            // Dessiner les n≈ìuds
            const nodeRadius = 20;
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('circle')
                .data(nodesArray)
                .enter()
                .append('circle')
                .attr('class', 'node')
                .attr('r', nodeRadius)
                .attr('fill', d => communityColors[d.group] || '#d0d0d0')
                .attr('stroke', d => d.isStart ? '#FCD34D' : 'white')
                .attr('stroke-width', d => d.isStart ? 4 : 3)
                .style('cursor', 'pointer');
            
            // Dessiner les labels
            const labels = g.append('g')
                .attr('class', 'labels')
                .selectAll('g')
                .data(nodesArray)
                .enter()
                .append('g');
            
            labels.append('rect')
                .attr('x', -35)
                .attr('y', -10)
                .attr('width', 70)
                .attr('height', 20)
                .attr('rx', 4)
                .attr('fill', d => d.isStart ? 'rgba(234, 179, 8, 0.9)' : 'rgba(0, 0, 0, 0.7)')
                .attr('stroke', d => d.isStart ? 'rgba(234, 179, 8, 1)' : 'rgba(255, 255, 255, 0.3)')
                .attr('stroke-width', d => d.isStart ? 2 : 1);
            
            labels.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '.3em')
                .attr('fill', d => d.isStart ? '#000' : 'white')
                .attr('font-weight', 'bold')
                .attr('font-size', d => d.isStart ? '13px' : '12px')
                .text(d => {
                    const community = idToCommunity[d.id] || 'Unknown';
                    return `${d.id}_${community}`;
                })
                .style('pointer-events', 'none');
            
            // Variable pour suivre le n≈ìud s√©lectionn√©
            let selectedNodeId = null;
            
            // Fonction pour mettre en √©vidence les connexions
            function highlightConnections(nodeId) {
                selectedNodeId = nodeId;
                const connectedIds = new Set([nodeId]);
                
                // Trouver tous les n≈ìuds connect√©s
                linksArray.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    if (sourceId === nodeId) {
                        connectedIds.add(targetId);
                    }
                    if (targetId === nodeId) {
                        connectedIds.add(sourceId);
                    }
                });
                
                // Mettre √† jour les n≈ìuds
                node
                    .classed('highlighted', d => d.id === nodeId)
                    .classed('connected', d => connectedIds.has(d.id) && d.id !== nodeId)
                    .classed('faded', d => !connectedIds.has(d.id))
                    .attr('opacity', d => connectedIds.has(d.id) ? 1 : 0.2)
                    .attr('stroke-width', d => {
                        if (d.id === nodeId) return 5;
                        if (connectedIds.has(d.id)) return 4;
                        return d.isStart ? 4 : 3;
                    });
                
                // Mettre √† jour les labels
                labels
                    .classed('highlighted', d => d.id === nodeId)
                    .classed('connected', d => connectedIds.has(d.id) && d.id !== nodeId)
                    .classed('faded', d => !connectedIds.has(d.id))
                    .attr('opacity', d => connectedIds.has(d.id) ? 1 : 0.2);
                
                // Mettre √† jour les liens
                link
                    .classed('highlighted', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        return sourceId === nodeId || targetId === nodeId;
                    })
                    .classed('faded', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        return sourceId !== nodeId && targetId !== nodeId;
                    })
                    .attr('stroke-opacity', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        return (sourceId === nodeId || targetId === nodeId) ? 1 : 0.1;
                    })
                    .attr('marker-end', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        const isHighlighted = (sourceId === nodeId || targetId === nodeId);
                        // Utiliser le marqueur appropri√© selon l'√©tat
                        // Pour on-ramps, utiliser prediction-onramps-arrow, pour off-ramps utiliser prediction-arrow
                        const isOnRamps = !svg.select('defs marker#prediction-onramps-arrow').empty();
                        const markerBase = isOnRamps ? 'prediction-onramps-arrow' : 'prediction-arrow';
                        return isHighlighted ? `url(#${markerBase})` : `url(#${markerBase}-faded)`;
                    })
                    .attr('stroke-width', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        return (sourceId === nodeId || targetId === nodeId) ? 3 : 1;
                    });
            }
            
            // Fonction pour r√©initialiser la s√©lection
            function resetHighlight() {
                selectedNodeId = null;
                node
                    .classed('highlighted', false)
                    .classed('connected', false)
                    .classed('faded', false)
                    .attr('opacity', 1)
                    .attr('stroke-width', d => d.isStart ? 4 : 3);
                
                labels
                    .classed('highlighted', false)
                    .classed('connected', false)
                    .classed('faded', false)
                    .attr('opacity', 1);
                
                link
                    .classed('highlighted', false)
                    .classed('faded', false)
                    .attr('stroke-opacity', 0.6)
                    .attr('marker-end', function() {
                        // D√©tecter si c'est on-ramps ou off-ramps
                        const isOnRamps = !svg.select('defs marker#prediction-onramps-arrow').empty();
                        const markerBase = isOnRamps ? 'prediction-onramps-arrow' : 'prediction-arrow';
                        return `url(#${markerBase})`;
                    })
                    .attr('stroke-width', 2);
            }
            
            // Ajouter les gestionnaires de clic
            node.on('click', function(event, d) {
                event.stopPropagation();
                if (selectedNodeId === d.id) {
                    resetHighlight();
                } else {
                    highlightConnections(d.id);
                }
            });
            
            labels
                .style('cursor', 'pointer')
                .on('click', function(event, d) {
                    event.stopPropagation();
                    if (selectedNodeId === d.id) {
                        resetHighlight();
                    } else {
                        highlightConnections(d.id);
                    }
                });
            
            // Permettre de r√©initialiser en cliquant sur le fond
            svg.on('click', function(event) {
                if (event.target === svg.node() || event.target === g.node()) {
                    resetHighlight();
                }
            });
            
            // Mettre √† jour la simulation
            const strokeWidth = 3;
            const totalRadius = nodeRadius + strokeWidth;
            
            simulation.on('tick', () => {
                link.each(function(d) {
                    const sourceNode = typeof d.source === 'object' ? d.source : nodesArray.find(n => n.id === d.source);
                    const targetNode = typeof d.target === 'object' ? d.target : nodesArray.find(n => n.id === d.target);
                    if (!sourceNode || !targetNode || !sourceNode.x || !targetNode.x) return;
                    
                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const startX = sourceNode.x + (dx / distance) * totalRadius;
                        const startY = sourceNode.y + (dy / distance) * totalRadius;
                        const arrowOffset = 18;
                        const endX = targetNode.x - (dx / distance) * (totalRadius + arrowOffset);
                        const endY = targetNode.y - (dy / distance) * (totalRadius + arrowOffset);
                        
                        d3.select(this)
                            .attr('x1', startX)
                            .attr('y1', startY)
                            .attr('x2', endX)
                            .attr('y2', endY);
                    }
                });
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                labels
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
            });
            
            // Lib√©rer les positions fixes apr√®s la simulation pour permettre le drag
            simulation.on('end', () => {
                nodesArray.forEach(node => {
                    node.fx = null;
                    node.fy = null;
                });
            });
            
            // Ajouter le zoom
            const zoom = d3.zoom()
                .scaleExtent([0.1, 5])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
        }

        // ========== FONCTIONS POUR S√âLECTION ON-RAMPS ==========
        let onRampsSelectedCenters = new Set(); // OPM-ID s√©lectionn√©s dans center
        let onRampsSelectedOnRamps = new Set(); // Paires "centerNum-rampNum" pour tracker les on-ramps sp√©cifiques s√©lectionn√©s
        let onRampsCurrentZoom = 1;
        let onRampsCircularZoom = 1;
        let onRampsCircularOldZoom = 1;
        let onRampsCircular2Zoom = 1;
        let onRampsCircular2CurveDepth = 0.65;
        let onRampsCircular2CurveSpacing = 0.5;
        let onRampsCircular2MinCurveLength = 100;
        let onRampsCircular2Modulation = 1.0;
        let onRampsCircular2Randomness = 0;
        let onRampsCircularSortOrder = 'by name';
        let onRampsNetworkZoom = 1;
        let onRampsNetworkSimulation = null;
        let onRampsCurrentTab = 'linear';

        function renderOnRampsSelection() {
            const content = document.getElementById('onRampsDetailContent');
            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });

            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };

            let html = '';
            const allOpmNums = Object.keys(niceFramework).sort((a, b) => {
                const aNum = isNaN(parseInt(a)) ? Infinity : parseInt(a);
                const bNum = isNaN(parseInt(b)) ? Infinity : parseInt(b);
                if (aNum === Infinity && bNum === Infinity) return a.localeCompare(b);
                if (aNum === Infinity) return 1;
                if (bNum === Infinity) return -1;
                return aNum - bNum;
            });

            allOpmNums.forEach(num => {
                const data = niceFramework[num];
                if (!data) return;

                const community = idToCommunity[num] || 'Unknown';
                const communityColor = communityColors[community] || '#d0d0d0';

                // Partie gauche: On-Ramps
                let leftHtml = `<div class="ramps-section-title on-ramps">üìà On-Ramps</div><div class="ramps-items-container">`;
                if (data.on_ramps && data.on_ramps.length > 0) {
                    data.on_ramps.forEach(rampNum => {
                        const rampCommunity = idToCommunity[rampNum] || 'Unknown';
                        const rampColor = communityColors[rampCommunity] || '#d0d0d0';
                        // V√©rifier si cette paire sp√©cifique (centerNum-rampNum) est s√©lectionn√©e
                        const pairKey = `${num}-${rampNum}`;
                        const isOnRampSelected = onRampsSelectedOnRamps.has(pairKey);
                        leftHtml += `
                            <div class="ramps-item ${isOnRampSelected ? 'selected' : ''}" style="cursor: pointer; ${isOnRampSelected ? 'background-color: #3B82F6; color: white; border-left-color: #2563EB;' : ''}" onclick="toggleOnRampsOnRamp('${num}', '${rampNum}')">
                                <div style="font-weight: 600; color: ${isOnRampSelected ? 'white' : rampColor};">${rampNum}</div>
                                <div style="font-size: 10px; color: ${isOnRampSelected ? 'rgba(255,255,255,0.7)' : 'var(--color-slate-500)'}; margin-top: 2px;">${rampCommunity}</div>
                            </div>
                        `;
                    });
                } else {
                    leftHtml += `<div style="text-align: center; color: var(--color-slate-500); padding: 16px 0;">Aucun</div>`;
                }
                leftHtml += `</div>`;

                // Partie centrale: OPM-ID
                const isCenterSelected = onRampsSelectedCenters.has(num);
                const centerHtml = `
                    <div class="ramps-center-opm" style="cursor: pointer; ${isCenterSelected ? 'background-color: var(--color-teal-500); padding: 16px; border-radius: 8px; color: white;' : ''}" onclick="toggleOnRampsCenter('${num}')">
                        <div class="ramps-center-dot" style="background-color: ${isCenterSelected ? 'white' : communityColor};"></div>
                        <div class="ramps-center-opm-num" style="color: ${isCenterSelected ? 'white' : 'var(--color-teal-500)'};">${num}</div>
                        <div class="ramps-center-opm-community" style="color: ${isCenterSelected ? 'rgba(255,255,255,0.7)' : 'var(--color-slate-500)'};">${community}</div>
                    </div>
                `;

                html += `
                    <div class="ramps-detail-layout">
                        <div class="ramps-detail-section ramps-detail-left">
                            ${leftHtml}
                        </div>
                        <div class="ramps-detail-section ramps-detail-center">
                            ${centerHtml}
                        </div>
                    </div>
                `;
            });

            content.innerHTML = html;
        }

        function toggleOnRampsCenter(num) {
            if (onRampsSelectedCenters.has(num)) {
                onRampsSelectedCenters.delete(num);
            } else {
                onRampsSelectedCenters.add(num);
            }
            // Ne pas s√©lectionner automatiquement dans left quand on s√©lectionne dans center
            renderOnRampsSelection();
        }

        function toggleOnRampsOnRamp(centerNum, rampNum) {
            const pairKey = `${centerNum}-${rampNum}`;
            if (onRampsSelectedOnRamps.has(pairKey)) {
                onRampsSelectedOnRamps.delete(pairKey);
            } else {
                onRampsSelectedOnRamps.add(pairKey);
                // Si on s√©lectionne un on-ramp, s√©lectionner automatiquement le center parent
                if (!onRampsSelectedCenters.has(centerNum)) {
                    onRampsSelectedCenters.add(centerNum);
                }
                // ET aussi s√©lectionner le center correspondant √† l'on-ramp (car rampNum peut √™tre un OPM-ID dans le center)
                if (!onRampsSelectedCenters.has(rampNum)) {
                    onRampsSelectedCenters.add(rampNum);
                }
            }
            renderOnRampsSelection();
        }

        function validateOnRampsSelection() {
            // Avec miserables.json, on peut afficher m√™me sans s√©lection (toutes les donn√©es)
            // La v√©rification de s√©lection est maintenant optionnelle
            
            document.getElementById('onRampsDetailPanel').style.display = 'none';
            document.getElementById('onRampsVisualization').style.display = 'block';
            
            // Afficher la vue lin√©aire par d√©faut
            document.getElementById('onRampsLinearView').style.display = 'block';
            document.getElementById('onRampsCircularView').style.display = 'none';
            document.getElementById('onRampsCircularOldView').style.display = 'none';
            document.getElementById('onRampsCircular2View').style.display = 'none';
            document.getElementById('onRampsNetworkView').style.display = 'none';
            document.querySelectorAll('#onRampsTabs .tab-button').forEach(btn => btn.classList.remove('active'));
            const firstTab = document.querySelector('#onRampsTabs .tab-button:first-child');
            if (firstTab) firstTab.classList.add('active');
            onRampsCurrentTab = 'linear';
            
            renderOnRampsGraph();
        }

        function resetOnRampsSelection() {
            // R√©initialiser toutes les s√©lections
            onRampsSelectedCenters.clear();
            onRampsSelectedOnRamps.clear();

            // Masquer la carte "principale" dans le header
            const headerSection = document.getElementById('onRampsNetworkHeaderSection');
            if (headerSection) {
                headerSection.style.display = 'none';
            }

            // R√©initialiser les zooms
            onRampsCurrentZoom = 1;
            onRampsCircularZoom = 1;
            onRampsCurrentTab = 'linear';
            
            // Mettre √† jour les labels de zoom
            const zoomLevelEl = document.getElementById('onRampsZoomLevel');
            const circularZoomLevelEl = document.getElementById('onRampsCircularZoomLevel');
            if (zoomLevelEl) zoomLevelEl.textContent = '100';
            if (circularZoomLevelEl) circularZoomLevelEl.textContent = '100';
            
            // R√©afficher le panneau de s√©lection
            document.getElementById('onRampsDetailPanel').style.display = 'block';
            document.getElementById('onRampsVisualization').style.display = 'none';
            
            // R√©initialiser les onglets
            document.querySelectorAll('#onRampsTabs .tab-button').forEach(btn => btn.classList.remove('active'));
            const firstTab = document.querySelector('#onRampsTabs .tab-button:first-child');
            if (firstTab) firstTab.classList.add('active');
            document.getElementById('onRampsLinearView').style.display = 'block';
            document.getElementById('onRampsCircularView').style.display = 'none';
            
            // R√©afficher la s√©lection
            renderOnRampsSelection();
        }

        function switchOnRampsTab(tab) {
            onRampsCurrentTab = tab;
            document.querySelectorAll('#onRampsTabs .tab-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            document.getElementById('onRampsLinearView').style.display = tab === 'linear' ? 'block' : 'none';
            document.getElementById('onRampsCircularView').style.display = tab === 'circular' ? 'block' : 'none';
            document.getElementById('onRampsCircularOldView').style.display = tab === 'circular-old' ? 'block' : 'none';
            document.getElementById('onRampsCircular2View').style.display = tab === 'circular-2' ? 'block' : 'none';
            document.getElementById('onRampsNetworkView').style.display = tab === 'network' ? 'block' : 'none';

            if (tab === 'circular') {
                renderOnRampsCircularGraph();
            } else if (tab === 'circular-old') {
                renderOnRampsCircularOldGraph();
            } else if (tab === 'circular-2') {
                renderOnRampsCircular2Graph();
            } else if (tab === 'network') {
                renderOnRampsNetworkGraph();
            } else {
                renderOnRampsGraph();
            }
        }

        function renderOnRampsGraph() {
            const canvas = document.getElementById('onRampsCanvas');
            canvas.innerHTML = '';

            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });

            // Cr√©er un Set de tous les OPM-ID √† afficher (centers + on-ramps)
            const opmsToShow = new Set();
            onRampsSelectedCenters.forEach(num => opmsToShow.add(num));
            // Extraire les rampNum uniques des paires "centerNum-rampNum"
            onRampsSelectedOnRamps.forEach(pair => {
                const parts = pair.split('-');
                if (parts.length >= 2) {
                    const centerNum = parts[0];
                    const rampNum = parts.slice(1).join('-');
                    opmsToShow.add(centerNum);
                    opmsToShow.add(rampNum);
                }
            });

            // Si aucune s√©lection, inclure tous les OPM-ID
            if (opmsToShow.size === 0) {
                Object.keys(niceFramework).forEach(num => opmsToShow.add(num));
            }

            // Cr√©er la liste tri√©e des OPM-ID √† afficher
            const sortedOpms = Array.from(opmsToShow).sort((a, b) => {
                const aNum = isNaN(parseInt(a)) ? Infinity : parseInt(a);
                const bNum = isNaN(parseInt(b)) ? Infinity : parseInt(b);
                if (aNum === Infinity && bNum === Infinity) return a.localeCompare(b);
                if (aNum === Infinity) return 1;
                if (bNum === Infinity) return -1;
                return aNum - bNum;
            });

            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('data-transform-group', 'true');

            const positionMap = {};
            let xPos = 40;
            sortedOpms.forEach(num => {
                positionMap[num] = { x: xPos, y: 200 };
                xPos += 80;
            });

            const canvasWidth = Math.max(1200, xPos + 40);
            canvas.setAttribute('viewBox', `0 0 ${canvasWidth} 400`);
            canvas.setAttribute('width', canvasWidth);
            canvas.setAttribute('height', 400);

            // Dessiner les connexions on-ramps
            // Pour les on-ramps, trouver tous les OPM-ID qui ont centerNum dans leurs off-ramps
            const connections = [];
            if (onRampsSelectedCenters.size > 0 || onRampsSelectedOnRamps.size > 0) {
                onRampsSelectedCenters.forEach(centerNum => {
                    Object.keys(niceFramework).forEach(sourceId => {
                        const sourceData = niceFramework[sourceId];
                        if (sourceData && sourceData.off_ramps && sourceData.off_ramps.includes(centerNum)) {
                            const pairKey = `${centerNum}-${sourceId}`;
                            if ((onRampsSelectedOnRamps.size === 0 || onRampsSelectedOnRamps.has(pairKey)) && opmsToShow.has(sourceId)) {
                                // Fl√®che de centerNum vers sourceId (centerNum -> sourceId)
                                connections.push({ from: centerNum, to: sourceId, type: 'on-ramp' });
                            }
                        }
                    });
                });
            } else {
                // Si aucune s√©lection, afficher toutes les connexions
                Object.keys(niceFramework).forEach(sourceId => {
                    const sourceData = niceFramework[sourceId];
                    if (sourceData && sourceData.off_ramps) {
                        sourceData.off_ramps.forEach(targetId => {
                            if (opmsToShow.has(sourceId) && opmsToShow.has(targetId)) {
                                // Fl√®che de targetId vers sourceId (targetId -> sourceId)
                                connections.push({ from: targetId, to: sourceId, type: 'on-ramp' });
                            }
                        });
                    }
                });
            }

            connections.forEach((conn, index) => {
                const fromPos = positionMap[conn.from];
                const toPos = positionMap[conn.to];
                if (fromPos && toPos) {
                    drawOnRampsLinearArc(group, fromPos, toPos, conn.type, index, connections);
                }
            });

            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };

            sortedOpms.forEach(num => {
                const community = idToCommunity[num] || 'Unknown';
                const communityColor = communityColors[community] || '#d0d0d0';
                const pos = positionMap[num];
                const isCenter = onRampsSelectedCenters.has(num);
                // V√©rifier si ce num est pr√©sent dans une des paires comme rampNum
                let isOnRamp = false;
                onRampsSelectedOnRamps.forEach(pair => {
                    const rampNum = pair.split('-')[1];
                    if (rampNum === num) {
                        isOnRamp = true;
                    }
                });

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', pos.x);
                circle.setAttribute('cy', pos.y);
                circle.setAttribute('r', isCenter ? 10 : 8);
                circle.setAttribute('fill', communityColor);
                circle.setAttribute('opacity', '1');
                group.appendChild(circle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', pos.x);
                text.setAttribute('y', pos.y + 25);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', isCenter ? '16px' : '14px');
                text.setAttribute('font-weight', '700');
                text.setAttribute('fill', communityColor);
                text.textContent = num;
                group.appendChild(text);
            });

            canvas.appendChild(group);
            initOnRampsArrowMarkers();
            applyOnRampsCanvasTransform();
        }

        function drawOnRampsLinearArc(canvas, fromPos, toPos, rampType, index, allConnections) {
            const color = '#3B82F6';
            const xDiff = Math.abs(toPos.x - fromPos.x);
            const gap = xDiff / 80;
            
            let amplitudeModifier = 1;
            if (gap <= 3) {
                amplitudeModifier = 2 + (3 - gap) * 0.7;
            } else if (gap <= 5) {
                amplitudeModifier = 1.5 + (5 - gap) * 0.3;
            }
            
            const baseHeight = 60 * 0.8;
            const midY = fromPos.y - baseHeight * amplitudeModifier;
            const midX = (fromPos.x + toPos.x) / 2;
            
            const pathData = `M ${fromPos.x} ${fromPos.y} Q ${midX} ${midY} ${toPos.x} ${toPos.y}`;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', 'url(#arrowhead-on-ramp-onramps)');
            path.setAttribute('opacity', '0.7');
            canvas.appendChild(path);
        }

        function initOnRampsArrowMarkers() {
            let defs = document.querySelector('#onRampsCanvas defs');
            if (defs) {
                defs.remove();
            }
            
            const canvas = document.getElementById('onRampsCanvas');
            const newDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            const arrowOn = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            arrowOn.setAttribute('id', 'arrowhead-on-ramp-onramps');
            arrowOn.setAttribute('markerWidth', '10');
            arrowOn.setAttribute('markerHeight', '10');
            arrowOn.setAttribute('refX', '9');
            arrowOn.setAttribute('refY', '3');
            arrowOn.setAttribute('orient', 'auto');
            const polygonOn = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygonOn.setAttribute('points', '0 0, 10 3, 0 6');
            polygonOn.setAttribute('fill', '#3B82F6');
            arrowOn.appendChild(polygonOn);
            newDefs.appendChild(arrowOn);
            
            canvas.insertBefore(newDefs, canvas.firstChild);
        }

        function applyOnRampsCanvasTransform() {
            const canvas = document.getElementById('onRampsCanvas');
            if (canvas) {
                const group = canvas.querySelector('g[data-transform-group]');
                if (group) {
                    group.setAttribute('transform', `scale(${onRampsCurrentZoom})`);
                    group.setAttribute('transform-origin', '0 0');
                }
            }
        }

        function onRampsZoomIn() {
            onRampsCurrentZoom = Math.min(onRampsCurrentZoom + 0.2, 3);
            document.getElementById('onRampsZoomLevel').textContent = Math.round(onRampsCurrentZoom * 100);
            applyOnRampsCanvasTransform();
        }

        function onRampsZoomOut() {
            onRampsCurrentZoom = Math.max(onRampsCurrentZoom - 0.2, 0.5);
            document.getElementById('onRampsZoomLevel').textContent = Math.round(onRampsCurrentZoom * 100);
            applyOnRampsCanvasTransform();
        }

        function onRampsFitToScreen() {
            onRampsCurrentZoom = 1;
            document.getElementById('onRampsZoomLevel').textContent = '100';
            const wrapper = document.getElementById('onRampsCanvasWrapper');
            if (wrapper) {
                wrapper.scrollLeft = 0;
                wrapper.scrollTop = 0;
            }
            applyOnRampsCanvasTransform();
        }

        function renderOnRampsCircularGraph() {
            const canvas = document.getElementById('onRampsCircularCanvas');
            canvas.innerHTML = '';
            
            const baseSize = 800;
            const size = baseSize * onRampsCircularZoom;
            const center = size / 2;
            const radius = size * 0.35;
            
            canvas.setAttribute('width', size);
            canvas.setAttribute('height', size);
            
            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bg.setAttribute('width', size);
            bg.setAttribute('height', size);
            bg.setAttribute('fill', '#fafafa');
            canvas.appendChild(bg);
            
            const allIds = getAllOpmIds();
            const idToCommunity = {};
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
            });

            const opmsToShow = new Set();
            onRampsSelectedCenters.forEach(num => opmsToShow.add(num));
            // Extraire les rampNum uniques des paires "centerNum-rampNum"
            onRampsSelectedOnRamps.forEach(pair => {
                const parts = pair.split('-');
                if (parts.length >= 2) {
                    const centerNum = parts[0];
                    const rampNum = parts.slice(1).join('-');
                    opmsToShow.add(centerNum);
                    opmsToShow.add(rampNum);
                }
            });

            // Si aucune s√©lection, inclure tous les OPM-ID
            if (opmsToShow.size === 0) {
                Object.keys(niceFramework).forEach(num => opmsToShow.add(num));
            }

            // Trier selon l'ordre s√©lectionn√©
            let sortedOpms;
            if (onRampsCircularSortOrder === 'chrono-asc') {
                sortedOpms = Array.from(opmsToShow).sort((a, b) => {
                    const aNum = isNaN(parseInt(a)) ? Infinity : parseInt(a);
                    const bNum = isNaN(parseInt(b)) ? Infinity : parseInt(b);
                    if (aNum === Infinity && bNum === Infinity) return a.localeCompare(b);
                    if (aNum === Infinity) return 1;
                    if (bNum === Infinity) return -1;
                    return aNum - bNum;
                });
            } else if (onRampsCircularSortOrder === 'chrono-desc') {
                sortedOpms = Array.from(opmsToShow).sort((a, b) => {
                    const aNum = isNaN(parseInt(a)) ? Infinity : parseInt(a);
                    const bNum = isNaN(parseInt(b)) ? Infinity : parseInt(b);
                    if (aNum === Infinity && bNum === Infinity) return b.localeCompare(a);
                    if (aNum === Infinity) return -1;
                    if (bNum === Infinity) return 1;
                    return bNum - aNum;
                });
            } else {
                sortedOpms = Array.from(opmsToShow).sort((a, b) => a.localeCompare(b));
            }

            const positions = {};
            sortedOpms.forEach((num, index) => {
                const angle = (index / sortedOpms.length) * 2 * Math.PI - Math.PI / 2;
                const x = center + radius * Math.cos(angle);
                const y = center + radius * Math.sin(angle);
                positions[num] = { x, y, angle };
            });

            const connections = [];
            // Pour les on-ramps, trouver tous les OPM-ID qui ont centerNum dans leurs off-ramps
            // Les fl√®ches doivent partir de centerNum et pointer vers sourceId
            if (onRampsSelectedCenters.size > 0 || onRampsSelectedOnRamps.size > 0) {
                onRampsSelectedCenters.forEach(centerNum => {
                    Object.keys(niceFramework).forEach(sourceId => {
                        const sourceData = niceFramework[sourceId];
                        if (sourceData && sourceData.off_ramps && sourceData.off_ramps.includes(centerNum)) {
                            const pairKey = `${centerNum}-${sourceId}`;
                            if ((onRampsSelectedOnRamps.size === 0 || onRampsSelectedOnRamps.has(pairKey)) && opmsToShow.has(sourceId)) {
                                // Fl√®che de centerNum vers sourceId (centerNum -> sourceId)
                                connections.push({ from: centerNum, to: sourceId, type: 'on-ramp' });
                            }
                        }
                    });
                });
            } else {
                // Si aucune s√©lection, afficher toutes les connexions
                Object.keys(niceFramework).forEach(sourceId => {
                    const sourceData = niceFramework[sourceId];
                    if (sourceData && sourceData.off_ramps) {
                        sourceData.off_ramps.forEach(targetId => {
                            if (opmsToShow.has(sourceId) && opmsToShow.has(targetId)) {
                                // Fl√®che de targetId vers sourceId (targetId -> sourceId)
                                connections.push({ from: targetId, to: sourceId, type: 'on-ramp' });
                            }
                        });
                    }
                });
            }

            connections.forEach(conn => {
                const fromPos = positions[conn.from];
                const toPos = positions[conn.to];
                if (fromPos && toPos) {
                    const color = '#3B82F6';
                    const dx = toPos.x - fromPos.x;
                    const dy = toPos.y - fromPos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const midX = (fromPos.x + toPos.x) / 2;
                    const midY = (fromPos.y + toPos.y) / 2;
                    const perpX = -dy / distance;
                    const perpY = dx / distance;
                    
                    const controlX = midX + perpX * distance * 0.3 * 0.65;
                    const controlY = midY + perpY * distance * 0.3 * 0.65;
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const pathData = `M ${fromPos.x} ${fromPos.y} Q ${controlX} ${controlY} ${toPos.x} ${toPos.y}`;
                    path.setAttribute('d', pathData);
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('opacity', '0.6');
                    path.setAttribute('marker-end', 'url(#arrow-on-ramp-circular)');
                    canvas.appendChild(path);
                }
            });

            let defs = canvas.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                canvas.insertBefore(defs, canvas.firstChild);
            }
            
            if (!canvas.querySelector('#arrow-on-ramp-circular')) {
                const arrowOn = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                arrowOn.setAttribute('id', 'arrow-on-ramp-circular');
                arrowOn.setAttribute('markerWidth', '10');
                arrowOn.setAttribute('markerHeight', '10');
                arrowOn.setAttribute('refX', '7');
                arrowOn.setAttribute('refY', '3');
                arrowOn.setAttribute('orient', 'auto');
                const polyOn = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polyOn.setAttribute('points', '0 0, 10 3, 0 6');
                polyOn.setAttribute('fill', '#3B82F6');
                arrowOn.appendChild(polyOn);
                defs.appendChild(arrowOn);
            }

            const communityColors = {
                'IT': '#3B82F6',
                'CS': '#10B981',
                'EN': '#8B5CF6',
                'CE': '#92400E',
                'CI': '#F59E0B',
                'DA': '#14B8A6',
                'SE': '#EF4444',
                'Cx': '#6B7280'
            };

            sortedOpms.forEach(num => {
                const community = idToCommunity[num] || 'Unknown';
                const communityColor = communityColors[community] || '#d0d0d0';
                const pos = positions[num];
                const isCenter = onRampsSelectedCenters.has(num);

                const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                point.setAttribute('cx', pos.x);
                point.setAttribute('cy', pos.y);
                point.setAttribute('r', isCenter ? 4 : 3);
                point.setAttribute('fill', communityColor);
                point.setAttribute('opacity', '1');
                canvas.appendChild(point);

                const textRadius = radius + 40;
                const textX = center + textRadius * Math.cos(pos.angle);
                const textY = center + textRadius * Math.sin(pos.angle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', textX);
                text.setAttribute('y', textY);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', isCenter ? '14px' : '12px');
                text.setAttribute('font-weight', '700');
                text.setAttribute('fill', communityColor);
                text.textContent = num;
                canvas.appendChild(text);
            });
        }

        function onRampsCircularZoomIn() {
            onRampsCircularZoom = Math.min(onRampsCircularZoom + 0.2, 3);
            document.getElementById('onRampsCircularZoomLevel').textContent = Math.round(onRampsCircularZoom * 100);
            renderOnRampsCircularGraph();
        }

        function onRampsCircularZoomOut() {
            onRampsCircularZoom = Math.max(onRampsCircularZoom - 0.2, 0.5);
            document.getElementById('onRampsCircularZoomLevel').textContent = Math.round(onRampsCircularZoom * 100);
            renderOnRampsCircularGraph();
        }

        function onRampsCircularFitToScreen() {
            onRampsCircularZoom = 1;
            document.getElementById('onRampsCircularZoomLevel').textContent = '100';
            renderOnRampsCircularGraph();
        }

        // Convertir niceFramework en format nodes/links pour les on-ramps
        // Les on-ramps d'un OPM-ID sont les OPM-ID qui ont cet OPM-ID dans leurs off-ramps
        function convertNiceFrameworkToNodesLinksOnRamps() {
            // Obtenir les communaut√©s pour chaque OPM-ID
            const allIds = getAllOpmIds();
            const idToCommunity = {};
            const communityToGroup = {};
            const communities = new Set();
            
            allIds.forEach(item => {
                const num = item.id.split('_')[0];
                idToCommunity[num] = item.community;
                communities.add(item.community);
            });
            
            // Cr√©er un mapping communaut√© -> group (num√©ro)
            const sortedCommunities = Array.from(communities).sort();
            sortedCommunities.forEach((comm, index) => {
                communityToGroup[comm] = index;
            });
            
            // Cr√©er les n≈ìuds
            const nodes = [];
            const nodeSet = new Set();
            
            // Si aucune s√©lection, inclure tous les OPM-ID de niceFramework
            if (onRampsSelectedCenters.size === 0 && onRampsSelectedOnRamps.size === 0) {
                Object.keys(niceFramework).forEach(opmId => {
                    if (!nodeSet.has(opmId)) {
                        const community = idToCommunity[opmId] || 'Unknown';
                        nodes.push({
                            id: opmId,
                            group: communityToGroup[community] !== undefined ? communityToGroup[community] : -1
                        });
                        nodeSet.add(opmId);
                    }
                });
            } else {
                // Cr√©er un Set de tous les n≈ìuds √† inclure
                const nodesToInclude = new Set();
                
                // Ajouter les n≈ìuds s√©lectionn√©s comme centers
                onRampsSelectedCenters.forEach(nodeId => nodesToInclude.add(nodeId));
                
                // Ajouter les n≈ìuds qui sont des sources ou destinations de liens s√©lectionn√©s
                onRampsSelectedOnRamps.forEach(pair => {
                    const parts = pair.split('-');
                    if (parts.length >= 2) {
                        const source = parts[0];
                        const target = parts.slice(1).join('-');
                        nodesToInclude.add(source);
                        nodesToInclude.add(target);
                    }
                });
                
                nodesToInclude.forEach(opmId => {
                    if (!nodeSet.has(opmId)) {
                        const community = idToCommunity[opmId] || 'Unknown';
                        nodes.push({
                            id: opmId,
                            group: communityToGroup[community] !== undefined ? communityToGroup[community] : -1
                        });
                        nodeSet.add(opmId);
                    }
                });
            }
            
            // Cr√©er les liens (on-ramps)
            // Un on-ramp de targetId est un sourceId qui a targetId dans ses off_ramps
            // Visuellement : targetId -> sourceId (pour montrer que sourceId m√®ne √† targetId)
            const links = [];
            const linkSet = new Set();
            
            Object.keys(niceFramework).forEach(sourceId => {
                const data = niceFramework[sourceId];
                if (!data || !data.off_ramps) return;
                
                data.off_ramps.forEach(targetId => {
                    // Si sourceId a targetId dans ses off_ramps, alors sourceId est un on-ramp de targetId
                    // La fl√®che doit partir de targetId et pointer vers sourceId
                    const pairKey = `${targetId}-${sourceId}`;
                    const shouldInclude = 
                        (onRampsSelectedCenters.size === 0 && onRampsSelectedOnRamps.size === 0) ||
                        onRampsSelectedOnRamps.has(pairKey) ||
                        (onRampsSelectedCenters.has(targetId) && nodeSet.has(sourceId));
                    
                    if (shouldInclude && nodeSet.has(sourceId) && nodeSet.has(targetId)) {
                        const linkKey = `${targetId}->${sourceId}`;
                        if (!linkSet.has(linkKey)) {
                            links.push({
                                source: targetId,  // Le center (901) - d√©part de la fl√®che
                                target: sourceId,  // L'on-ramp (801, 802, 803) - arriv√©e de la fl√®che
                                value: 1
                            });
                            linkSet.add(linkKey);
                        }
                    }
                });
            });
            
            console.log('Donn√©es converties (on-ramps):', nodes.length, 'n≈ìuds,', links.length, 'liens');
            return { nodes, links };
        }

        function setOnRampsCircularSort(order) {
            onRampsCircularSortOrder = order;
            renderOnRampsCircularGraph();
        }

        // Vue Circulaire 1 pour On-Ramps
        function renderOnRampsCircularOldGraph() {
            const canvas = document.getElementById('onRampsCircularOldCanvas');
            const wrapper = document.getElementById('onRampsCircularOldCanvasWrapper');
            if (!canvas) {
                console.error('Canvas onRampsCircularOldCanvas introuvable');
                return;
            }
            canvas.innerHTML = '';
            
            try {
                const { nodes, links } = convertNiceFrameworkToNodesLinksOnRamps();
                
                if (!nodes || nodes.length === 0) {
                    canvas.innerHTML = '<text x="400" y="400" text-anchor="middle" fill="#666" font-size="16px">Aucune donn√©e disponible</text>';
                    return;
                }

                const width = 954;
                const radius = width / 2;
                
                const wrapperWidth = wrapper ? wrapper.clientWidth : 800;
                const wrapperHeight = wrapper ? wrapper.clientHeight : 800;
                const baseSize = Math.min(wrapperWidth, wrapperHeight, 800);
                const size = baseSize * onRampsCircularOldZoom;

                canvas.setAttribute('width', '100%');
                canvas.setAttribute('height', '100%');
                canvas.setAttribute('viewBox', `${-width / 2} ${-width / 2} ${width} ${width}`);
                canvas.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                canvas.setAttribute('style', 'max-width: 100%; height: auto; font: 10px sans-serif;');

                // Convertir en format hi√©rarchique pour D3
                const dataArray = [];
                nodes.forEach(node => {
                    const nodeLinks = links.filter(l => l.source === node.id);
                    dataArray.push({
                        name: node.id,
                        imports: nodeLinks.map(l => l.target)
                    });
                });

                // Fonction hierarchy adapt√©e pour OPM-ID
                function hierarchyOPM(data) {
                    const root = { name: "OPM", children: [] };
                    const map = new Map();
                    data.forEach(item => {
                        const node = {
                            name: item.name,
                            imports: item.imports || [],
                            children: []
                        };
                        map.set(item.name, node);
                        root.children.push(node);
                    });
                    return root;
                }

                // Fonction bilink adapt√©e pour OPM-ID
                function bilinkOPM(root) {
                    const map = new Map(root.leaves().map(d => [id(d), d]));
                    for (const d of root.leaves()) d.incoming = [], d.outgoing = d.data.imports.map(i => [d, map.get(i)]);
                    for (const d of root.leaves()) for (const o of d.outgoing) o[1].incoming.push(o);
                    return root;
                }

                function id(node) {
                    return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
                }

                const root = hierarchyOPM(dataArray);
                const tree = bilinkOPM(root);

                // Obtenir les communaut√©s
                const allIds = getAllOpmIds();
                const idToCommunity = {};
                allIds.forEach(item => {
                    const num = item.id.split('_')[0];
                    idToCommunity[num] = item.community;
                });

                const communityColors = {
                    'IT': '#3B82F6',
                    'CS': '#10B981',
                    'EN': '#8B5CF6',
                    'CE': '#92400E',
                    'CI': '#F59E0B',
                    'DA': '#14B8A6',
                    'SE': '#EF4444',
                    'Cx': '#6B7280'
                };

                // Dessiner les liens
                tree.leaves().forEach(d => {
                    d.outgoing.forEach(([source, target]) => {
                        if (target) {
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            const sourceAngle = (source.x / (2 * Math.PI)) * 360 - 90;
                            const targetAngle = (target.x / (2 * Math.PI)) * 360 - 90;
                            const sourceX = radius * Math.cos((sourceAngle - 90) * Math.PI / 180);
                            const sourceY = radius * Math.sin((sourceAngle - 90) * Math.PI / 180);
                            const targetX = radius * Math.cos((targetAngle - 90) * Math.PI / 180);
                            const targetY = radius * Math.sin((targetAngle - 90) * Math.PI / 180);
                            
                            const midX = (sourceX + targetX) / 2;
                            const midY = (sourceY + targetY) / 2;
                            const dist = Math.sqrt((targetX - sourceX) ** 2 + (targetY - sourceY) ** 2);
                            const curveHeight = dist * 0.3;
                            
                            const pathData = `M ${sourceX} ${sourceY} Q ${midX} ${midY - curveHeight} ${targetX} ${targetY}`;
                            path.setAttribute('d', pathData);
                            path.setAttribute('stroke', '#3B82F6');
                            path.setAttribute('stroke-width', '2');
                            path.setAttribute('fill', 'none');
                            path.setAttribute('opacity', '0.6');
                            path.setAttribute('marker-end', 'url(#arrowhead-on-ramp-circular-old)');
                            canvas.appendChild(path);
                        }
                    });
                });

                // Cr√©er les d√©finitions pour les fl√®ches
                let defs = canvas.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    canvas.insertBefore(defs, canvas.firstChild);
                }

                if (!canvas.querySelector('#arrowhead-on-ramp-circular-old')) {
                    const arrowOn = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    arrowOn.setAttribute('id', 'arrowhead-on-ramp-circular-old');
                    arrowOn.setAttribute('markerWidth', '10');
                    arrowOn.setAttribute('markerHeight', '10');
                    arrowOn.setAttribute('refX', '9');
                    arrowOn.setAttribute('refY', '3');
                    arrowOn.setAttribute('orient', 'auto');
                    const polygonOn = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygonOn.setAttribute('points', '0 0, 10 3, 0 6');
                    polygonOn.setAttribute('fill', '#3B82F6');
                    arrowOn.appendChild(polygonOn);
                    defs.appendChild(arrowOn);
                }

                // Dessiner les n≈ìuds
                tree.leaves().forEach(d => {
                    const angle = (d.x / (2 * Math.PI)) * 360 - 90;
                    const x = radius * Math.cos((angle - 90) * Math.PI / 180);
                    const y = radius * Math.sin((angle - 90) * Math.PI / 180);
                    const num = d.data.name;
                    const community = idToCommunity[num] || 'Unknown';
                    const color = communityColors[community] || '#d0d0d0';
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', 5);
                    circle.setAttribute('fill', color);
                    canvas.appendChild(circle);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', y - 10);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '10px');
                    text.setAttribute('fill', color);
                    text.textContent = `${num}_${community}`;
                    canvas.appendChild(text);
                });
            } catch (error) {
                console.error('Erreur lors du rendu de la vue circulaire 1 (on-ramps):', error);
                canvas.innerHTML = `<text x="400" y="400" text-anchor="middle" fill="#f00" font-size="14px">Erreur: ${error.message}</text>`;
            }
        }

        function onRampsCircularOldZoomIn() {
            onRampsCircularOldZoom = Math.min(onRampsCircularOldZoom + 0.2, 3);
            document.getElementById('onRampsCircularOldZoomLevel').textContent = Math.round(onRampsCircularOldZoom * 100);
            renderOnRampsCircularOldGraph();
        }

        function onRampsCircularOldZoomOut() {
            onRampsCircularOldZoom = Math.max(onRampsCircularOldZoom - 0.2, 0.5);
            document.getElementById('onRampsCircularOldZoomLevel').textContent = Math.round(onRampsCircularOldZoom * 100);
            renderOnRampsCircularOldGraph();
        }

        function onRampsCircularOldFitToScreen() {
            onRampsCircularOldZoom = 1;
            document.getElementById('onRampsCircularOldZoomLevel').textContent = '100';
            renderOnRampsCircularOldGraph();
        }

        // Vue Circulaire 2 pour On-Ramps
        function renderOnRampsCircular2Graph() {
            const canvas = document.getElementById('onRampsCircular2Canvas');
            const wrapper = document.getElementById('onRampsCircular2CanvasWrapper');
            if (!canvas) {
                console.error('Canvas onRampsCircular2Canvas introuvable');
                return;
            }
            canvas.innerHTML = '';
            
            try {
                const baseSize = 800;
                const size = baseSize * onRampsCircular2Zoom;
                const center = size / 2;
                const radius = size * 0.35;
                
                canvas.setAttribute('width', size);
                canvas.setAttribute('height', size);
                
                const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bg.setAttribute('width', size);
                bg.setAttribute('height', size);
                bg.setAttribute('fill', '#fafafa');
                canvas.appendChild(bg);
                
                const allIds = getAllOpmIds();
                const positions = {};
                
                allIds.forEach((item, index) => {
                    const angle = (index / allIds.length) * 2 * Math.PI - Math.PI / 2;
                    const x = center + radius * Math.cos(angle);
                    const y = center + radius * Math.sin(angle);
                    const num = item.id.split('_')[0];
                    positions[num] = { x, y, community: item.community, fullId: item.id, angle };
                });
                
                // Utiliser les s√©lections on-ramps
                const selectedArray = Array.from(onRampsSelectedCenters);
                const allRamps = new Set();
                const connections = [];
                
                if (onRampsSelectedCenters.size > 0 || onRampsSelectedOnRamps.size > 0) {
                    selectedArray.forEach(selectedNum => {
                        const data = niceFramework[selectedNum];
                        if (!data) return;
                        
                        allRamps.add(selectedNum);
                        
                        // Trouver les on-ramps (OPM-ID qui ont selectedNum dans leurs off-ramps)
                        Object.keys(niceFramework).forEach(sourceId => {
                            const sourceData = niceFramework[sourceId];
                            if (sourceData && sourceData.off_ramps && sourceData.off_ramps.includes(selectedNum)) {
                                const pairKey = `${selectedNum}-${sourceId}`;
                                if (onRampsSelectedOnRamps.size === 0 || onRampsSelectedOnRamps.has(pairKey)) {
                                    allRamps.add(sourceId);
                                    // Fl√®che de selectedNum vers sourceId (selectedNum -> sourceId)
                                    connections.push({ from: selectedNum, to: sourceId, type: 'on-ramp' });
                                }
                            }
                        });
                    });
                } else {
                    // Si aucune s√©lection, afficher tous les OPM-ID
                    Object.keys(niceFramework).forEach(num => {
                        allRamps.add(num);
                        const data = niceFramework[num];
                        if (data && data.off_ramps) {
                            data.off_ramps.forEach(rampNum => {
                                // Si num a rampNum dans ses off_ramps, alors num est un on-ramp de rampNum
                                // Fl√®che de rampNum vers num (rampNum -> num)
                                connections.push({ from: rampNum, to: num, type: 'on-ramp' });
                            });
                        }
                    });
                }
                
                // Dessiner les connexions
                connections.forEach((conn) => {
                    const fromPos = positions[conn.from];
                    const toPos = positions[conn.to];
                    if (fromPos && toPos) {
                        const color = '#3B82F6'; // Bleu pour on-ramps
                        const dx = toPos.x - fromPos.x;
                        const dy = toPos.y - fromPos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Calculer l'angle angulaire entre les deux points
                        const angleDiff = Math.abs(toPos.angle - fromPos.angle);
                        const normalizedAngleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);
                        
                        // Modulation d'amplitude bas√©e sur la proximit√© angulaire
                        let amplitudeModifier = 1;
                        if (normalizedAngleDiff < 0.1) {
                            amplitudeModifier = 1.5 + (0.1 - normalizedAngleDiff) * onRampsCircular2Modulation * 5;
                        } else if (normalizedAngleDiff < 0.2) {
                            amplitudeModifier = 1.2 + (0.2 - normalizedAngleDiff) * 1.5;
                        }
                        
                        // Appliquer la randomness circulaire
                        const connectionKey = `onramps-circ2-${conn.from}-${conn.to}-${conn.type}`;
                        const randomness = getRandomnessForConnection(connectionKey);
                        
                        if (onRampsCircular2Randomness > 0) {
                            const lengthVariation = (randomness.lengthRand - 0.5) * 2 * onRampsCircular2Randomness;
                            const curveVariation = (randomness.curveRand - 0.5) * 2 * onRampsCircular2Randomness;
                            const ampVariation = (randomness.ampRand - 0.5) * 2 * onRampsCircular2Randomness;
                            
                            amplitudeModifier *= (1 + ampVariation);
                        }
                        
                        let depthMultiplier = 1;
                        if (distance < onRampsCircular2MinCurveLength) {
                            depthMultiplier = 1 + (onRampsCircular2MinCurveLength - distance) / onRampsCircular2MinCurveLength * onRampsCircular2CurveSpacing;
                        }
                        
                        const baseRadius = Math.max(distance * 0.4, 50);
                        const curvatureRadius = baseRadius * depthMultiplier * amplitudeModifier;
                        
                        let midX = (fromPos.x + toPos.x) / 2;
                        let midY = (fromPos.y + toPos.y) / 2;
                        
                        // Appliquer variation al√©atoire aux positions du contr√¥le
                        if (onRampsCircular2Randomness > 0) {
                            const randomness2 = getRandomnessForConnection(connectionKey + '-mid');
                            midX += (randomness2.lengthRand - 0.5) * 2 * onRampsCircular2Randomness * 20;
                            midY += (randomness2.curveRand - 0.5) * 2 * onRampsCircular2Randomness * 20;
                        }
                        
                        const perpX = -dy / distance;
                        const perpY = dx / distance;
                        
                        const midToCenterX = center - midX;
                        const midToCenterY = center - midY;
                        const midToCenter = Math.sqrt(midToCenterX * midToCenterX + midToCenterY * midToCenterY);
                        
                        const normMidToCenterX = midToCenter > 0 ? midToCenterX / midToCenter : 0;
                        const normMidToCenterY = midToCenter > 0 ? midToCenterY / midToCenter : 0;
                        
                        const dotProduct = perpX * normMidToCenterX + perpY * normMidToCenterY;
                        const curveDir = dotProduct > 0 ? 1 : -1;
                        
                        const controlX = midX + perpX * curveDir * curvatureRadius * onRampsCircular2CurveDepth;
                        const controlY = midY + perpY * curveDir * curvatureRadius * onRampsCircular2CurveDepth;
                        
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const pathData = `M ${fromPos.x} ${fromPos.y} Q ${controlX} ${controlY} ${toPos.x} ${toPos.y}`;
                        path.setAttribute('d', pathData);
                        path.setAttribute('stroke', color);
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('opacity', '0.6');
                        path.setAttribute('marker-end', `url(#onramps-circ2-arrow-on-ramp)`);
                        canvas.appendChild(path);
                    }
                });
                
                // Cr√©er les d√©finitions pour les fl√®ches
                let defs = canvas.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    canvas.insertBefore(defs, canvas.firstChild);
                }
                
                if (!canvas.querySelector('#onramps-circ2-arrow-on-ramp')) {
                    const arrowOn = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    arrowOn.setAttribute('id', 'onramps-circ2-arrow-on-ramp');
                    arrowOn.setAttribute('markerWidth', '10');
                    arrowOn.setAttribute('markerHeight', '10');
                    arrowOn.setAttribute('refX', '7');
                    arrowOn.setAttribute('refY', '3');
                    arrowOn.setAttribute('orient', 'auto');
                    const polyOn = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polyOn.setAttribute('points', '0 0, 10 3, 0 6');
                    polyOn.setAttribute('fill', '#3B82F6');
                    arrowOn.appendChild(polyOn);
                    defs.appendChild(arrowOn);
                }
                
                // Dessiner les n≈ìuds
                const communityColors = {
                    'IT': '#3B82F6',
                    'CS': '#10B981',
                    'EN': '#8B5CF6',
                    'CE': '#92400E',
                    'CI': '#F59E0B',
                    'DA': '#14B8A6',
                    'SE': '#EF4444',
                    'Cx': '#6B7280'
                };
                
                allIds.forEach((item) => {
                    const num = item.id.split('_')[0];
                    const pos = positions[num];
                    if (!pos) return;
                    
                    const isSelected = onRampsSelectedCenters.has(num);
                    const isRamp = allRamps.has(num);
                    const community = item.community;
                    const baseColor = communityColors[community] || '#d0d0d0';
                    
                    let pointColor = baseColor;
                    let pointSize = 2;
                    let opacity = 0.5;
                    
                    if (isSelected) {
                        pointSize = 3;
                        opacity = 1;
                    } else if (isRamp) {
                        pointSize = 2.5;
                        opacity = 0.9;
                    }
                    
                    const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    point.setAttribute('cx', pos.x);
                    point.setAttribute('cy', pos.y);
                    point.setAttribute('r', pointSize);
                    point.setAttribute('fill', pointColor);
                    point.setAttribute('opacity', opacity);
                    canvas.appendChild(point);
                    
                    const textRadius = radius + 40;
                    const angle = pos.angle;
                    const textX = center + textRadius * Math.cos(angle);
                    const textY = center + textRadius * Math.sin(angle);
                    
                    const textSize = isSelected ? '13px' : isRamp ? '11px' : '10px';
                    const textWeight = isSelected ? '700' : isRamp ? '600' : '400';
                    const textOpacity = isSelected || isRamp ? '1' : '0.7';
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', textSize);
                    text.setAttribute('font-weight', textWeight);
                    text.setAttribute('fill', baseColor);
                    text.setAttribute('opacity', textOpacity);
                    text.textContent = `${num}_${community}`;
                    canvas.appendChild(text);
                });
            } catch (error) {
                console.error('Erreur lors du rendu de la vue circulaire 2 (on-ramps):', error);
                canvas.innerHTML = `<text x="400" y="400" text-anchor="middle" fill="#f00" font-size="14px">Erreur: ${error.message}</text>`;
            }
        }

        function toggleOnRampsCircular2CurveSettings() {
            const panel = document.getElementById('onRampsCircular2CurveSettingsPanel');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }

        function updateOnRampsCircular2CurveSettings() {
            onRampsCircular2CurveDepth = parseFloat(document.getElementById('onRampsCircular2CurveDepthSlider').value);
            onRampsCircular2CurveSpacing = parseFloat(document.getElementById('onRampsCircular2CurveSpacingSlider').value);
            onRampsCircular2MinCurveLength = parseFloat(document.getElementById('onRampsCircular2MinCurveLengthSlider').value);
            onRampsCircular2Modulation = parseFloat(document.getElementById('onRampsCircular2ModulationSlider').value);
            onRampsCircular2Randomness = parseFloat(document.getElementById('onRampsCircular2RandomnessSlider').value);
            
            document.getElementById('onRampsCircular2CurveDepthValue').textContent = onRampsCircular2CurveDepth.toFixed(2);
            document.getElementById('onRampsCircular2CurveSpacingValue').textContent = onRampsCircular2CurveSpacing.toFixed(1);
            document.getElementById('onRampsCircular2MinCurveLengthValue').textContent = Math.round(onRampsCircular2MinCurveLength);
            document.getElementById('onRampsCircular2ModulationValue').textContent = onRampsCircular2Modulation.toFixed(1);
            document.getElementById('onRampsCircular2RandomnessValue').textContent = onRampsCircular2Randomness.toFixed(1);
            
            renderOnRampsCircular2Graph();
        }

        function onRampsCircular2ZoomIn() {
            onRampsCircular2Zoom = Math.min(onRampsCircular2Zoom + 0.2, 3);
            document.getElementById('onRampsCircular2ZoomLevel').textContent = Math.round(onRampsCircular2Zoom * 100);
            renderOnRampsCircular2Graph();
        }

        function onRampsCircular2ZoomOut() {
            onRampsCircular2Zoom = Math.max(onRampsCircular2Zoom - 0.2, 0.5);
            document.getElementById('onRampsCircular2ZoomLevel').textContent = Math.round(onRampsCircular2Zoom * 100);
            renderOnRampsCircular2Graph();
        }

        function onRampsCircular2FitToScreen() {
            onRampsCircular2Zoom = 1;
            document.getElementById('onRampsCircular2ZoomLevel').textContent = '100';
            renderOnRampsCircular2Graph();
        }

        // Vue R√©seau pour On-Ramps
        function renderOnRampsNetworkGraph() {
            const canvasWrapper = document.getElementById('onRampsNetworkCanvasWrapper');
            const canvasId = 'onRampsNetworkCanvas';
            if (!canvasWrapper) {
                console.error('Wrapper onRampsNetworkCanvasWrapper introuvable');
                return;
            }
            
            // Nettoyer le wrapper
            canvasWrapper.innerHTML = '';
            if (onRampsNetworkSimulation) {
                onRampsNetworkSimulation.stop();
            }
            
            try {
                // Obtenir les dimensions
                const width = canvasWrapper.clientWidth || 1200;
                const height = canvasWrapper.clientHeight || 600;
                
                // Convertir niceFramework en format nodes/links pour on-ramps
                const { nodes: dataNodes, links: dataLinks } = convertNiceFrameworkToNodesLinksOnRamps();
                
                if (!dataNodes || dataNodes.length === 0) {
                    const errorText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    errorText.setAttribute('x', width / 2);
                    errorText.setAttribute('y', height / 2);
                    errorText.setAttribute('text-anchor', 'middle');
                    errorText.setAttribute('fill', '#666');
                    errorText.setAttribute('font-size', '16px');
                    errorText.textContent = 'Aucune donn√©e disponible';
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('id', canvasId);
                    svg.setAttribute('width', width);
                    svg.setAttribute('height', height);
                    svg.appendChild(errorText);
                    canvasWrapper.appendChild(svg);
                    return;
                }
                
                // Obtenir les communaut√©s
                const allIds = getAllOpmIds();
                const idToCommunity = {};
                allIds.forEach(item => {
                    const num = item.id.split('_')[0];
                    idToCommunity[num] = item.community;
                });
                
                const communityColors = {
                    'IT': '#3B82F6',
                    'CS': '#10B981',
                    'EN': '#8B5CF6',
                    'CE': '#92400E',
                    'CI': '#F59E0B',
                    'DA': '#14B8A6',
                    'SE': '#EF4444',
                    'Cx': '#6B7280'
                };
                
                // Cr√©er les n≈ìuds pour D3
                const nodes = dataNodes.map(node => ({
                    id: node.id,
                    group: idToCommunity[node.id] || 'Unknown',
                    num: node.id
                }));
                
                // Cr√©er les liens pour D3 (s'assurer que source et target sont des objets)
                const links = dataLinks.map(link => ({
                    source: link.source,
                    target: link.target
                }));
                
                // Cr√©er le SVG avec D3
                const svg = d3.select(canvasWrapper)
                    .append('svg')
                    .attr('id', canvasId)
                    .attr('width', width)
                    .attr('height', height);
                
                const g = svg.append('g');
                
                // Cr√©er les d√©finitions pour les fl√®ches (bleu pour on-ramps)
                const defs = svg.append('defs');
                
                // Fl√®che normale (bleue)
                const arrowMarker = defs.append('marker')
                    .attr('id', 'onramps-network-arrow')
                    .attr('markerWidth', 12)
                    .attr('markerHeight', 12)
                    .attr('refX', 10)
                    .attr('refY', 6)
                    .attr('orient', 'auto')
                    .attr('markerUnits', 'userSpaceOnUse');
                arrowMarker.append('polygon')
                    .attr('points', '0 0, 12 6, 0 12')
                    .attr('fill', '#3B82F6')
                    .attr('opacity', 1);
                
                // Fl√®che estomp√©e (bleue avec faible opacit√©)
                const arrowMarkerFaded = defs.append('marker')
                    .attr('id', 'onramps-network-arrow-faded')
                    .attr('markerWidth', 12)
                    .attr('markerHeight', 12)
                    .attr('refX', 10)
                    .attr('refY', 6)
                    .attr('orient', 'auto')
                    .attr('markerUnits', 'userSpaceOnUse');
                arrowMarkerFaded.append('polygon')
                    .attr('points', '0 0, 12 6, 0 12')
                    .attr('fill', '#3B82F6')
                    .attr('opacity', 0.1);
                
                // Cr√©er la simulation de force (sans confinement pour permettre aux n≈ìuds de sortir du cadre)
                const nodeRadius = 18; // Taille augment√©e des n≈ìuds
                
                onRampsNetworkSimulation = d3.forceSimulation(nodes)
                    .force('link', d3.forceLink(links).id(d => d.id).distance(120).strength(0.3))
                    .force('charge', d3.forceManyBody().strength(-500))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(nodeRadius + 5));
                
                // Dessiner les liens avec fl√®ches directionnelles
                const link = g.append('g')
                    .attr('class', 'links')
                    .selectAll('line')
                    .data(links)
                    .enter()
                    .append('line')
                    .attr('class', 'link')
                    .attr('stroke', '#3B82F6')
                    .attr('stroke-opacity', 0.7)
                    .attr('stroke-width', 1.5)
                    .attr('marker-end', 'url(#onramps-network-arrow)')
                    .style('pointer-events', 'none');
                
                // Variable pour suivre le n≈ìud s√©lectionn√©
                let selectedNodeId = null;
                
                // Fonction pour mettre en √©vidence les connexions
                function highlightConnections(nodeId) {
                    selectedNodeId = nodeId;
                    const connectedIds = new Set([nodeId]);
                    
                    // Afficher la carte "principale" dans le header
                    const headerSection = document.getElementById('onRampsNetworkHeaderSection');
                    const selectedRoleSpan = document.getElementById('onRampsNetworkSelectedRole');
                    if (headerSection && selectedRoleSpan) {
                        selectedRoleSpan.textContent = nodeId;
                        headerSection.style.display = 'flex';
                    }
                    
                    // Trouver tous les n≈ìuds connect√©s
                    links.forEach(link => {
                        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                        
                        if (sourceId === nodeId) {
                            connectedIds.add(targetId);
                        }
                        if (targetId === nodeId) {
                            connectedIds.add(sourceId);
                        }
                    });
                    
                    // Mettre √† jour les n≈ìuds
                    node
                        .classed('highlighted', d => d.id === nodeId)
                        .classed('connected', d => connectedIds.has(d.id) && d.id !== nodeId)
                        .classed('faded', d => !connectedIds.has(d.id))
                        .attr('opacity', d => connectedIds.has(d.id) ? 1 : 0.2)
                        .attr('stroke-width', d => {
                            if (d.id === nodeId) return 5;
                            if (connectedIds.has(d.id)) return 4;
                            return 3;
                        });
                    
                    // Mettre √† jour les labels
                    labels
                        .classed('highlighted', d => d.id === nodeId)
                        .classed('connected', d => connectedIds.has(d.id) && d.id !== nodeId)
                        .classed('faded', d => !connectedIds.has(d.id))
                        .attr('opacity', d => connectedIds.has(d.id) ? 1 : 0.2);
                    
                    // Mettre √† jour les liens
                    link
                        .classed('highlighted', d => {
                            const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                            const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                            return sourceId === nodeId || targetId === nodeId;
                        })
                        .classed('faded', d => {
                            const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                            const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                            return sourceId !== nodeId && targetId !== nodeId;
                        })
                        .attr('stroke-opacity', d => {
                            const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                            const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                            return (sourceId === nodeId || targetId === nodeId) ? 1 : 0.1;
                        })
                        .attr('marker-end', d => {
                            const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                            const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                            const isHighlighted = (sourceId === nodeId || targetId === nodeId);
                            return isHighlighted ? 'url(#onramps-network-arrow)' : 'url(#onramps-network-arrow-faded)';
                        })
                        .attr('stroke-width', d => {
                            const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                            const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                            return (sourceId === nodeId || targetId === nodeId) ? 3 : 1;
                        });
                }
                
                // Fonction pour r√©initialiser la s√©lection
                function resetHighlight() {
                    selectedNodeId = null;
                    
                    // Masquer la carte "principale" dans le header
                    const headerSection = document.getElementById('onRampsNetworkHeaderSection');
                    if (headerSection) {
                        headerSection.style.display = 'none';
                    }
                    
                    node
                        .classed('highlighted', false)
                        .classed('connected', false)
                        .classed('faded', false)
                        .attr('opacity', 1)
                        .attr('stroke-width', 3);
                    
                    labels
                        .classed('highlighted', false)
                        .classed('connected', false)
                        .classed('faded', false)
                        .attr('opacity', 1);
                    
                    link
                        .classed('highlighted', false)
                        .classed('faded', false)
                        .attr('stroke-opacity', 0.7)
                        .attr('marker-end', 'url(#onramps-network-arrow)')
                        .attr('stroke-width', 1.5);
                }
                
                // Dessiner les n≈ìuds (taille augment√©e)
                const node = g.append('g')
                    .attr('class', 'nodes')
                    .selectAll('circle')
                    .data(nodes)
                    .enter()
                    .append('circle')
                    .attr('class', 'node')
                    .attr('r', nodeRadius)
                    .attr('fill', d => communityColors[d.group] || '#d0d0d0')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 3)
                    .style('cursor', 'pointer')
                    .on('click', function(event, d) {
                        event.stopPropagation();
                        if (selectedNodeId === d.id) {
                            resetHighlight();
                        } else {
                            highlightConnections(d.id);
                        }
                    });
                
                // Dessiner les labels avec fond pour meilleure lisibilit√©
                const labels = g.append('g')
                    .attr('class', 'labels')
                    .selectAll('g')
                    .data(nodes)
                    .enter()
                    .append('g')
                    .style('cursor', 'pointer')
                    .on('click', function(event, d) {
                        event.stopPropagation();
                        if (selectedNodeId === d.id) {
                            resetHighlight();
                        } else {
                            highlightConnections(d.id);
                        }
                    });
                
                labels.append('rect')
                    .attr('x', -35)
                    .attr('y', -10)
                    .attr('width', 70)
                    .attr('height', 20)
                    .attr('rx', 4)
                    .attr('fill', 'rgba(0, 0, 0, 0.7)')
                    .attr('stroke', 'rgba(255, 255, 255, 0.3)')
                    .attr('stroke-width', 1);
                
                labels.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '.3em')
                    .attr('fill', 'white')
                    .attr('font-weight', 'bold')
                    .attr('font-size', '11px')
                    .text(d => {
                        const community = idToCommunity[d.id] || 'Unknown';
                        return `${d.id}_${community}`;
                    })
                    .style('pointer-events', 'none');
                
                // Permettre de r√©initialiser en cliquant sur le fond
                svg.on('click', function(event) {
                    if (event.target === svg.node() || event.target === g.node()) {
                        resetHighlight();
                    }
                });
                
                // Mettre √† jour la simulation
                const strokeWidth = 3;
                const totalRadius = nodeRadius + strokeWidth;
                
                onRampsNetworkSimulation.on('tick', () => {
                    link.each(function(d) {
                        const sourceNode = typeof d.source === 'object' ? d.source : nodes.find(n => n.id === d.source);
                        const targetNode = typeof d.target === 'object' ? d.target : nodes.find(n => n.id === d.target);
                        if (!sourceNode || !targetNode || !sourceNode.x || !targetNode.x) return;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            const startX = sourceNode.x + (dx / distance) * totalRadius;
                            const startY = sourceNode.y + (dy / distance) * totalRadius;
                            const arrowOffset = 15;
                            const endX = targetNode.x - (dx / distance) * (totalRadius + arrowOffset);
                            const endY = targetNode.y - (dy / distance) * (totalRadius + arrowOffset);
                            
                            d3.select(this)
                                .attr('x1', startX)
                                .attr('y1', startY)
                                .attr('x2', endX)
                                .attr('y2', endY);
                        }
                    });
                    
                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                    
                    labels
                        .attr('transform', d => `translate(${d.x}, ${d.y})`);
                });
                
                // Ajouter le zoom
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 5])
                    .on('zoom', function(event) {
                        onRampsNetworkZoom = event.transform.k;
                        document.getElementById('onRampsNetworkZoomLevel').textContent = Math.round(onRampsNetworkZoom * 100);
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                
            } catch (error) {
                console.error('Erreur lors du rendu de la vue r√©seau (on-ramps):', error);
                const errorText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                errorText.setAttribute('x', '400');
                errorText.setAttribute('y', '300');
                errorText.setAttribute('text-anchor', 'middle');
                errorText.setAttribute('fill', '#f00');
                errorText.setAttribute('font-size', '14px');
                errorText.textContent = `Erreur: ${error.message}`;
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('id', canvasId);
                svg.setAttribute('width', '800');
                svg.setAttribute('height', '600');
                svg.appendChild(errorText);
                canvasWrapper.appendChild(svg);
            }
        }
        
        function applyOnRampsNetworkZoom() {
            const canvasWrapper = document.getElementById('onRampsNetworkCanvasWrapper');
            if (!canvasWrapper) return;
            const svg = d3.select(canvasWrapper).select('svg');
            if (svg.empty()) return;
            
            // Appliquer la transformation de zoom via d3.zoom
            const currentTransform = d3.zoomTransform(svg.node());
            const newTransform = d3.zoomIdentity
                .translate(currentTransform.x, currentTransform.y)
                .scale(onRampsNetworkZoom);
            
            svg.call(d3.zoom().transform, newTransform);
        }

        function onRampsNetworkZoomIn() {
            onRampsNetworkZoom = Math.min(onRampsNetworkZoom * 1.2, 5);
            document.getElementById('onRampsNetworkZoomLevel').textContent = Math.round(onRampsNetworkZoom * 100);
            applyOnRampsNetworkZoom();
        }

        function onRampsNetworkZoomOut() {
            onRampsNetworkZoom = Math.max(onRampsNetworkZoom / 1.2, 0.1);
            document.getElementById('onRampsNetworkZoomLevel').textContent = Math.round(onRampsNetworkZoom * 100);
            applyOnRampsNetworkZoom();
        }

        function onRampsNetworkResetZoom() {
            onRampsNetworkZoom = 1;
            document.getElementById('onRampsNetworkZoomLevel').textContent = '100';
            applyOnRampsNetworkZoom();
        }

        function onRampsNetworkFitToScreen() {
            // Ajuster automatiquement le zoom pour que tous les n≈ìuds soient visibles
            const canvasWrapper = document.getElementById('onRampsNetworkCanvasWrapper');
            if (!canvasWrapper || !onRampsNetworkSimulation) return;
            
            const svg = canvasWrapper.querySelector('svg');
            if (!svg) return;
            
            const nodes = onRampsNetworkSimulation.nodes();
            if (!nodes || nodes.length === 0) return;
            
            // Trouver les limites de tous les n≈ìuds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            nodes.forEach(d => {
                if (d.x !== undefined && d.y !== undefined) {
                    const nodeRadius = 18;
                    minX = Math.min(minX, d.x - nodeRadius);
                    maxX = Math.max(maxX, d.x + nodeRadius);
                    minY = Math.min(minY, d.y - nodeRadius);
                    maxY = Math.max(maxY, d.y + nodeRadius);
                }
            });
            
            if (minX === Infinity) return; // Aucun n≈ìud valide
            
            // Ajouter un padding
            const padding = 80;
            const boundsWidth = maxX - minX + padding * 2;
            const boundsHeight = maxY - minY + padding * 2;
            
            const svgWidth = parseFloat(svg.getAttribute('width'));
            const svgHeight = parseFloat(svg.getAttribute('height'));
            
            // Calculer le zoom n√©cessaire pour que tout soit visible
            const scaleX = svgWidth / boundsWidth;
            const scaleY = svgHeight / boundsHeight;
            const optimalZoom = Math.min(scaleX, scaleY) * 0.95; // 0.95 pour un peu de marge
            
            if (optimalZoom > 0) {
                onRampsNetworkZoom = optimalZoom;
                document.getElementById('onRampsNetworkZoomLevel').textContent = Math.round(onRampsNetworkZoom * 100);
                applyOnRampsNetworkZoom();
            }
        }
    </script>
</body>
</html>
