{% extends "web_app/template/base.html" %}
{% load work_role_tags %}
{% load ksat_tags %}
{% load select_options_tags %}
{% load modal_info_tags %}

{% block script %}
<style>
  /* Style pour mettre en évidence la première lettre de chaque catégorie KSAT */
  .tab-button::first-letter {
    font-weight: bold;
    color: #3b82f6; /* Couleur bleue (blue-500 en tailwind) */
    font-size: 1.2em;
  }
  
  /* Styles pour grouper visuellement les colonnes du même work_role */
  /* Les couleurs seront définies dynamiquement en fonction des couleurs de la catégorie */
  
  /* Style pour les cellules correspondantes dans le corps du tableau (copier le style pour tous les groups) */
  tr td:nth-child(n+2) {
    border-top: none;
    border-bottom: none;
  }
  
  /* Styles de l'animation de chargement */
  .loading-spinner {
    position: relative;
    width: 80px;
    height: 80px;
  }
  
  .spinner-ring {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 4px solid transparent;
    border-top-color: #3b82f6;
    animation: spin 1.5s linear infinite;
  }
  
  .spinner-ring:nth-child(2) {
    width: 80%;
    height: 80%;
    top: 10%;
    left: 10%;
    border-top-color: transparent;
    border-right-color: #3b82f6;
    animation: spin 2s linear infinite reverse;
  }
  
  .spinner-dot {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 15px;
    height: 15px;
    background-color: #3b82f6;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    animation: pulse 1s ease-in-out infinite alternate;
  }
  
  .progress-bar {
    width: 0%;
    animation: progress 15s linear forwards;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  @keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(0.8); }
    100% { transform: translate(-50%, -50%) scale(1.2); }
  }
  
  @keyframes progress {
    0% { width: 5%; }
    20% { width: 25%; }
    50% { width: 50%; }
    70% { width: 70%; }
    100% { width: 95%; }
  }
  
  /* Styles pour la grille de contrôle global */
  .control-grid {
    min-width: 200px;
    max-width: 250px;
  }
  
  .control-grid button:hover {
    transform: scale(1.05);
  }
  
  .control-grid select:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
  }
  
  /* Animation pour les notifications */
  .notification-enter {
    animation: slideInRight 0.3s ease-out;
  }
  
  .notification-exit {
    animation: slideOutRight 0.3s ease-in;
  }
  
  /* z-index pour les selects globaux pour que les dropdowns s'affichent correctement */
  #global-pertinence-select,
  #global-niveau-attendu-select,
  #global-niveau-tolere-select {
    position: relative;
    z-index: 1000;
  }
  @keyframes slideInRight {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
  
  @keyframes slideOutRight {
    from {
      transform: translateX(0);
      opacity: 1;
    }
    to {
      transform: translateX(100%);
      opacity: 0;
    }
  }

</style>
{% endblock script %}

{% block content %}
<!-- Overlay de chargement (visible par défaut) -->
<div id="loading-overlay" class="fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-70">
  <div class="bg-white p-8 rounded-lg shadow-xl text-center max-w-md">
    <div class="flex flex-col items-center">
      <!-- Animation améliorée -->
      <div class="loading-spinner">
        <div class="spinner-ring"></div>
        <div class="spinner-ring"></div>
        <div class="spinner-dot"></div>
      </div>
      <h2 class="text-2xl font-bold mb-2 mt-4">Chargement en cours</h2>
      <p class="text-gray-600">Veuillez patienter, cette opération peut prendre quelques instants...</p>
      <div class="w-full bg-gray-200 h-2 mt-4 rounded-full overflow-hidden">
        <div class="progress-bar h-full bg-blue-500 rounded-full"></div>
      </div>
      <p class="text-sm text-gray-500 mt-4">Traitement d'une grande quantité de données (KSAT)</p>
    </div>
  </div>
</div>

<main class="mx-auto max-w-7xl p-6">
  <h1 class="text-3xl font-bold mb-6">
  Comparison of KSATs for
  {% for role in formatted_roles %}
    <span class="font-medium">{{ role.title }} <span class="text-gray-500">({{ role.framework }})</span></span>{% if not forloop.last %}, {% endif %}
  {% endfor %}
  </h1>
    <!-- Onglets -->
  <div class="flex justify-between items-center mb-4">
    <div id="tab-buttons" class="flex border-b">
      {% for key in ksat_dict.keys %}
        <button data-tab="{{ key }}"
                class="tab-button px-4 py-2 text-gray-600 hover:text-blue-600 border-b-2">
          <span style="font-weight: bold; color: #3b82f6; font-size: 1.2em;">{{ key|title|slice:":1" }}</span>{{ key|title|slice:"1:" }}{% if key != 'knowledge' %}s{% endif %}
        </button>
      {% endfor %}
    </div>
    
    <div class="flex items-center space-x-5">
      <!-- Bouton retour au menu -->
      <a href="{% url 'main' %}" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition">
        Retour au menu
      </a>
      
      <!-- Compteur actif -->
      <div id="selection-counter" class="text-sm px-2 py-1">
        <span id="current-tab-name" class="text-gray-500 mr-1">Catégorie :</span>
        <span id="current-tab-counter" class="font-medium">0/0</span>
      </div>
      
      <!-- Compteur global -->
      <div id="global-selection-counter" class="text-sm px-2 py-1">
        <span class="text-gray-500 mr-1">Total :</span>
        <span id="global-counter" class="font-medium">0/0</span>
      </div>
      
      <button id="compare-button" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
        Comparer
      </button>
      
      <button id="save-selection-button" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition">
        Sauvegarder
      </button>
    </div>
  </div>

  <!-- Conteneur pour les contrôles globaux (déplacé par JS) -->
  <div id="global-controls-wrapper" style="display: none;">
    <div id="global-controls-content" class="flex items-center space-x-4 p-2 bg-blue-50 border border-blue-200 rounded-lg ml-4">
      <!-- P - Pertinence -->
                        <div class="flex flex-col items-center">
        <div class="flex items-center space-x-1 mb-1">
          <span class="text-sm text-blue-700 font-medium">P</span>
          <button type="button" class="bg-blue-500 text-white rounded-full w-4 h-4 flex items-center justify-center hover:bg-blue-600 transition-colors text-xs" title="Pertinence : Indique l'importance de cette compétence pour le poste" onclick="showLevelInfoModal('pertinence')">?</button>
                        </div>
        <select id="global-pertinence-select" class="text-sm border border-blue-300 rounded px-2 py-1 w-16 bg-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500" onchange="updateAllSelects('primary', this.value); handleGlobalPertinenceChange(this.value);" title="Modifier toutes les valeurs de pertinence">
          <option value="">--</option><option value="0">0</option><option value="1">1</option><option value="2">2</option><option value="3">3</option>
        </select>
                        </div>
      <!-- A - Niveau attendu -->
                        <div class="flex flex-col items-center">
        <div class="flex items-center space-x-1 mb-1">
          <span class="text-sm text-blue-700 font-medium">A</span>
          <button type="button" class="bg-blue-500 text-white rounded-full w-4 h-4 flex items-center justify-center hover:bg-blue-600 transition-colors text-xs" title="Niveau normalement attendu" onclick="showLevelInfoModal('niveau-attendu')">?</button>
                        </div>
        <select id="global-niveau-attendu-select" class="text-sm border border-blue-300 rounded px-2 py-1 w-16 bg-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500" onchange="updateAllSelects('secondary', this.value); updateGlobalTolereOptions(this.value);" title="Modifier toutes les valeurs de niveau attendu">
                            <option value="">--</option>
                          </select>
                        </div>
      <!-- T - Niveau toléré -->
      <div class="flex flex-col items-center">
        <div class="flex items-center space-x-1 mb-1">
          <span class="text-sm text-blue-700 font-medium">T</span>
          <button type="button" class="bg-blue-500 text-white rounded-full w-4 h-4 flex items-center justify-center hover:bg-blue-600 transition-colors text-xs" title="Niveau toléré au recrutement" onclick="showLevelInfoModal('niveau-tolere')">?</button>
                        </div>
        <select id="global-niveau-tolere-select" class="text-sm border border-blue-300 rounded px-2 py-1 w-16 bg-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500" onchange="updateAllSelects('tertiary', this.value)" title="Modifier toutes les valeurs de niveau toléré">
                            <option value="">--</option>
                          </select>
                        </div>
                      </div>
                    </div>

  <!-- Contenus -->
  <div id="tab-contents">
    {% for key, ksats in ksat_dict.items %}
      <div id="{{ key }}" class="tab-content hidden">
        <table class="min-w-full table-auto border-collapse mb-6">
          <thead>

            
            <!-- Ligne principale du tableau -->
            <tr class="bg-gray-100">
              <th class="px-3 py-2 border text-left bg-white">
                <span class="font-medium">Description / ID</span>
              </th>
              {% for role in formatted_roles %}
                <th class="px-3 py-2 border {% if role.group_id %}{{ role.group_id }} work-role-group{% endif %}" 
                    data-framework="{{ role.framework }}" 
                    data-role-id="{{ role.id }}"
                    data-model-type="{{ role.model_type }}"
                    data-group-id="{{ role.group_id }}"
                    data-category-color="{{ role.category_color }}">
                  

                  <div>
                    <div class="text-xs text-center mb-1 font-normal">{% if role.opm_id %}{{ role.opm_id }}{% else %}&nbsp;{% endif %}</div>
                    <div class="text-center">
                      {{ role.title }}
                    </div>
                    <div class="text-center">
                      <span class="text-xs text-gray-600">({{ role.framework }})</span>
                    </div>
                  </div>
                </th>
              {% endfor %}
            </tr>
          </thead>
          <tbody>
            {% for ksat in ksats %}
              <tr class="hover:bg-gray-50">
                <td class="px-3 py-2 border align-top">
                  <p class="font-medium">{{ ksat.description }}</p>
                  <div class="mt-1 text-sm text-gray-600 space-x-2">
                      {% dcwf_url ksat %}
                      {% ncwf_2017_url ksat %}
                      <div class="mt-2 text-xs text-gray-500">ID: {{ ksat.id }}</div>
                  {% if key == 'skill' %}
                  <!-- DÉBUT DES SELECTS POUR SKILLS -->
                  <div class="mt-2 flex space-x-2 select-group">
                    <!-- Premier select pour Skills -->
                    <div class="relative select-container">
                      {% render_select_options 'Skill' 'Importance' 'text-sm border rounded px-1 py-0.5 primary-select' 'handleSkillSelectChange(this); showInfoTooltip(this);' %}
                    </div>
                    <!-- Deuxième select pour Skills -->
                    <div class="relative select-container">
                      {% render_select_options 'Skill' 'Type de maîtrise 2' 'text-sm border rounded px-1 py-0.5 secondary-select' 'handleSkillSecondarySelectChange(this); showInfoTooltip(this);' %}
                    </div>
                    <!-- Troisième select pour Skills -->
                    <div class="relative select-container">
                      {% render_select_options 'Skill' 'Type de maîtrise 3' 'text-sm border rounded px-1 py-0.5 secondary-select' 'showInfoTooltip(this);' %}
                    </div>
                  </div>
                  <!-- FIN DES SELECTS POUR SKILLS -->
                  
                  {% elif key == 'abilitie' %}
                  <!-- DÉBUT DES SELECTS POUR ABILITIES -->
                  <div class="mt-2 flex space-x-2 select-group">
                    <!-- Premier select pour Abilities -->
                    <div class="relative select-container">
                      {% render_select_options 'Ability' 'Importance' 'text-sm border rounded px-1 py-0.5 primary-select' 'handleAbilitySelectChange(this); showInfoTooltip(this);' %}
                    </div>
                    <!-- Deuxième select pour Abilities -->
                    <div class="relative select-container">
                      {% render_select_options 'Ability' 'Type de maîtrise 2' 'text-sm border rounded px-1 py-0.5 secondary-select' 'handleAbilitySecondarySelectChange(this); showInfoTooltip(this);' %}
                    </div>
                    <!-- Troisième select pour Abilities -->
                    <div class="relative select-container">
                      {% render_select_options 'Ability' 'Type de maîtrise 3' 'text-sm border rounded px-1 py-0.5 secondary-select' 'showInfoTooltip(this);' %}
                    </div>
                  </div>
                  <!-- FIN DES SELECTS POUR ABILITIES -->
                  
                  {% elif key == 'task' %}
                  <!-- DÉBUT DES SELECTS POUR TASK -->
                  <div class="mt-2 flex space-x-2 select-group">
                    <!-- Premier select pour Task -->
                    <div class="relative select-container">
                      {% render_select_options 'Task' 'Importance' 'text-sm border rounded px-1 py-0.5 primary-select' 'handleSelectChange(this); showInfoTooltip(this);' %}
                    </div>
                    <!-- Deuxième select pour Task -->
                    <div class="relative select-container">
                      {% render_select_options 'Task' 'Type de maîtrise 1' 'text-sm border rounded px-1 py-0.5 secondary-select' 'handleSecondarySelectChange(this); showInfoTooltip(this);' %}
                    </div>
                    <!-- Troisième select pour Task -->
                    <div class="relative select-container">
                      {% render_select_options 'Task' 'Type de maîtrise 2' 'text-sm border rounded px-1 py-0.5 secondary-select' 'showInfoTooltip(this);' %}
                    </div>
                  </div>
                  <!-- FIN DES SELECTS POUR TASK -->
                  {% endif %}
                  
                  {% if key == 'knowledge' %}
                  <div class="mt-2 flex space-x-2 select-group">
                    <div class="relative select-container">
                      {% render_select_options 'Knowledge' 'Importance' 'text-sm border rounded px-1 py-0.5 primary-select knowledge-select' 'handleKnowledgeSelectChange(this); showInfoTooltip(this);' %}
                    </div>
                    <div class="relative select-container">
                      {% render_select_options 'Knowledge' 'Type de maîtrise 1' 'text-sm border rounded px-1 py-0.5 secondary-select' 'handleKnowledgeSecondarySelectChange(this); showInfoTooltip(this);' "knowledge-second-select" %}
                    </div>
                    <div class="relative select-container">
                      {% render_select_options 'Knowledge' 'Type de maîtrise 2' 'text-sm border rounded px-1 py-0.5 secondary-select' 'showInfoTooltip(this);' "knowledge-third-select" %}
                    </div>
                  </div>
                  {% endif %}
                </td>
                {% for role in formatted_roles %}
                  <td class="px-3 py-2 border text-center align-middle">
                    {% if role.model_obj|has_ksat:ksat %}✅{% else %}❌{% endif %}
                  </td>
                {% endfor %}
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    {% endfor %}
  </div>
</main>

<script>
// Variables qui seront initialisées au chargement pour éviter le hardcoding
let allSelectValues = {};

// Stockage des compteurs de sélection pour chaque onglet
let selectionCounters = {
  'task': { selected: 0, total: 0 },
  'knowledge': { selected: 0, total: 0 },
  'skill': { selected: 0, total: 0 },
  'abilitie': { selected: 0, total: 0 }
};

// Compteur global pour toutes les catégories
let globalCounter = { selected: 0, total: 0 };

// Onglet actif actuel
let currentActiveTab = '';

// Fonction pour gérer la dépendance entre le deuxième et le troisième select pour Task
function handleSecondarySelectChange(select) {
  const selectedValue = select.value;
  const selectGroup = select.closest('.select-group');
  const thirdSelect = selectGroup.querySelectorAll('.secondary-select')[1];
  const primarySelect = selectGroup.querySelector('.primary-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = select.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Vérifier si nous sommes dans un onglet Task
  const isTaskTab = selectGroup.closest('#task') !== null;
  
  // Ne pas modifier le troisième select si c'est un événement déclenché par le contrôle global
  // Cette vérification permet d'éviter les interférences entre les contrôles A et T
  const isGlobalEvent = select.hasAttribute('data-global-change');
  if (isGlobalEvent) {
    return;
  }
  
  // Réinitialiser le troisième select
  thirdSelect.innerHTML = '';
  
  // Fonction pour cloner une option
  function cloneOption(sourceOption) {
    const option = document.createElement('option');
    option.value = sourceOption.value;
    option.text = sourceOption.text || sourceOption.value;
    option.title = sourceOption.title || '';
    return option;
  }
  
  // Fonction pour trouver l'option avec une valeur spécifique
  function findOptionByValue(selectElement, value) {
    return Array.from(selectElement.options).find(opt => opt.value === value);
  }
  
  // Pour Task: Si le premier select n'est pas 2, désactiver le troisième select indépendamment de la valeur du second select
  if (isTaskTab && primarySelect && primarySelect.value !== '2') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50');
    return;
  }
  
  // Traitement spécifique pour l'onglet Task
  if (isTaskTab) {
    // Trouver tous les selects dans Task pour récupérer les options
    const allSelects = document.querySelectorAll('#task select');
    let thirdSelectSource = null;
    
    // Trouver le select source qui contient les options originales pour le troisième select
    allSelects.forEach(selectEl => {
      if (selectEl !== thirdSelect && 
          selectEl.parentElement.closest('.select-container') && 
          selectEl.parentElement.nextElementSibling && 
          selectEl.parentElement.nextElementSibling.nextElementSibling) {
        thirdSelectSource = selectEl.parentElement.nextElementSibling.nextElementSibling.querySelector('select');
      }
    });
    
    // Utiliser le select que l'on vient de réinitialiser comme source de secours
    if (!thirdSelectSource) {
      thirdSelectSource = thirdSelect;
    }
    
    // Pour Task: Quand le select n2 est sur B, désactiver le select n3
    if (selectedValue === 'B') {
      thirdSelect.disabled = true;
      thirdSelect.classList.add('opacity-50');
      return;
    }
    
    // Pour Task: Quand le select n2 est sur S, activer select n3 avec option B uniquement
    if (selectedValue === 'S') {
      thirdSelect.disabled = false;
      thirdSelect.classList.remove('opacity-50');
      
      // Chercher l'option B mais n'en ajouter qu'une seule
      let optionBAdded = false;
      for (const selectEl of allSelects) {
        if (optionBAdded) break;
        
        for (const opt of selectEl.options) {
          if (opt.value === 'B' && !optionBAdded) {
            thirdSelect.appendChild(cloneOption(opt));
            optionBAdded = true;
            break;
          }
        }
      }
      return;
    }
    
    // Pour Task: Quand le select n2 est sur M, activer select n3 avec options B et S
    if (selectedValue === 'M') {
      thirdSelect.disabled = false;
      thirdSelect.classList.remove('opacity-50');
      
      // Chercher et ajouter l'option B (une seule fois)
      let optionBAdded = false;
      let optionSAdded = false;
      
      // Parcourir tous les selects pour trouver les options B et S
      for (const selectEl of allSelects) {
        // Si on a déjà trouvé les deux options, on peut arrêter la recherche
        if (optionBAdded && optionSAdded) break;
        
        for (const opt of selectEl.options) {
          // Ajouter l'option B si elle n'a pas encore été ajoutée
          if (opt.value === 'B' && !optionBAdded) {
            thirdSelect.appendChild(cloneOption(opt));
            optionBAdded = true;
          }
          // Ajouter l'option S si elle n'a pas encore été ajoutée
          else if (opt.value === 'S' && !optionSAdded) {
            thirdSelect.appendChild(cloneOption(opt));
            optionSAdded = true;
          }
          
          // Si on a trouvé les deux options, on peut sortir de la boucle
          if (optionBAdded && optionSAdded) break;
        }
      }
      return;
    }
  } 
  
  // Si ce n'est pas un onglet Task ou si la valeur du select n2 n'est pas reconnue, garder le comportement d'origine
  if (selectedValue === '1') { // Option B (Basic)
    // Désactiver le troisième select
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50');
  } else {
    // Réactiver le troisième select
    thirdSelect.disabled = false;
    thirdSelect.classList.remove('opacity-50');
    
    // Pour les autres onglets (non-Task), chercher les options existantes
    const otherSelects = document.querySelectorAll('select');
    
    // Ajouter l'option correspondant à la valeur 1 (B)
    otherSelects.forEach(selectEl => {
      selectEl.querySelectorAll('option').forEach(opt => {
        if (opt.value === '1') {
          thirdSelect.appendChild(cloneOption(opt));
        }
      });
    });
    
    // Si option value 3 (M - Master) est sélectionnée, ajouter également l'option value 2 (S - Senior)
    if (selectedValue === '3') {
      otherSelects.forEach(selectEl => {
        selectEl.querySelectorAll('option').forEach(opt => {
          if (opt.value === '2' && !findOptionByValue(thirdSelect, '2')) {
            thirdSelect.appendChild(cloneOption(opt));
          }
        });
      });
    }
  }
}
// Fonction pour gérer la dépendance entre le premier et les autres selects pour Knowledge
function handleKnowledgeSelectChange(select) {
  const selectedValue = select.value;
  const container = select.closest('.select-group');
  const secondSelect = container.querySelector('#knowledge-second-select');
  const thirdSelect = container.querySelector('#knowledge-third-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = select.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  if (selectedValue === '0') {
    // Désactiver les deux selects secondaires
    secondSelect.disabled = true;
    thirdSelect.disabled = true;
    secondSelect.classList.add('opacity-50');
    thirdSelect.classList.add('opacity-50');
  } else {
    // Activer le second select
    secondSelect.disabled = false;
    secondSelect.classList.remove('opacity-50');
    
    // Si le premier select n'est pas égal à 2, désactiver le troisième select
    if (selectedValue !== '2') {
      thirdSelect.disabled = true;
      thirdSelect.classList.add('opacity-50');
      thirdSelect.innerHTML = ''; // Vider le troisième select
    } else {
      // Activer le troisième select seulement si le premier select est 2
      thirdSelect.disabled = false;
      thirdSelect.classList.remove('opacity-50');
      // Gérer l'état du troisième select seulement si le premier select est 2
      handleKnowledgeSecondarySelectChange(secondSelect);
    }
  }
}

// Fonction pour gérer la dépendance entre le deuxième et troisième select pour Knowledge
function handleKnowledgeSecondarySelectChange(select) {
  const selectedValue = select.value;
  const selectGroup = select.closest('.select-group');
  const secondarySelects = Array.from(selectGroup.querySelectorAll('.secondary-select'));
  const thirdSelect = secondarySelects[1]; // Le troisième select est le deuxième des secondary-select
  const primarySelect = selectGroup.querySelector('.primary-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = select.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Ne pas modifier le troisième select si c'est un événement déclenché par le contrôle global
  // Cette vérification permet d'éviter les interférences entre les contrôles A et T
  const isGlobalEvent = select.hasAttribute('data-global-change');
  if (isGlobalEvent) {
    return;
  }
  
  // Réinitialiser le troisième select
  thirdSelect.innerHTML = '';
  
  // Pour Knowledge: Vérifier si nous sommes dans l'onglet Knowledge
  const isKnowledgeTab = selectGroup.closest('#knowledge') !== null;
  
  // Si nous ne sommes pas dans l'onglet Knowledge, laisser les autres fonctions gérer le comportement
  if (!isKnowledgeTab) return;
  
  // Pour Knowledge: Vérifier si le premier select a la valeur "2"
  if (primarySelect && primarySelect.value !== '2') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50');
    return;
  }
  
  // Règles spécifiques pour Knowledge
  
  // Si select n2 a la valeur A, désactiver le select n3
  if (selectedValue === 'A') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50');
    return;
  }
  
  // Activer le select n3 pour les autres cas
  thirdSelect.disabled = false;
  thirdSelect.classList.remove('opacity-50');
  
  // Trouver toutes les options existantes pour Knowledge dans le DOM
  // pour éviter le hardcoding
  const allSelects = document.querySelectorAll('select');
  let knowledgeOptions = [];
  
  // Collecter toutes les options des selects de Type de maîtrise 2 dans Knowledge
  allSelects.forEach(selectEl => {
    if (selectEl.closest('#knowledge') && 
        Array.from(selectEl.classList).includes('secondary-select')) {
      Array.from(selectEl.options).forEach(opt => {
        if (!knowledgeOptions.some(ko => ko.value === opt.value && ko.text === opt.text)) {
          knowledgeOptions.push({
            value: opt.value,
            text: opt.text,
            title: opt.title
          });
        }
      });
    }
  });
  
  // Filtrer et ajouter les options appropriées selon la valeur du select n2
  const optionA = knowledgeOptions.find(opt => opt.text === 'A') || {
    value: '1',
    text: 'A',
    title: "Level A: Can identify basic facts and terms about the subject."
  };
  
  const optionB = knowledgeOptions.find(opt => opt.text === 'B') || {
    value: '2',
    text: 'B',
    title: "Level B: Can identify relationships of basic facts and state general principles about the subject."
  };
  
  const optionC = knowledgeOptions.find(opt => opt.text === 'C') || {
    value: '3',
    text: 'C',
    title: "Level C: Can analyze facts and principals and draw conclusions about the subject."
  };
  
  // Ajouter l'option A pour tous les cas (B, C, D)
  const newOptA = document.createElement('option');
  newOptA.value = optionA.value;
  newOptA.text = optionA.text;
  newOptA.title = optionA.title;
  thirdSelect.appendChild(newOptA);
  
  // Ajouter l'option B pour les cas C et D
  if (selectedValue === 'C' || selectedValue === 'D') {
    const newOptB = document.createElement('option');
    newOptB.value = optionB.value;
    newOptB.text = optionB.text;
    newOptB.title = optionB.title;
    thirdSelect.appendChild(newOptB);
  }
  
  // Ajouter l'option C uniquement pour le cas D
  if (selectedValue === 'D') {
    const newOptC = document.createElement('option');
    newOptC.value = optionC.value;
    newOptC.text = optionC.text;
    newOptC.title = optionC.title;
    thirdSelect.appendChild(newOptC);
  }
}

// Déclaration des variables globales pour les données modales
let modalInfoData = null;
let modalDataLoaded = false;

// Fonction pour charger les données modales via une requête AJAX
function initModalData() {
  return new Promise((resolve, reject) => {
    console.log('Chargement des données modales via AJAX...');
    
    // Créer une requête XMLHttpRequest
    const xhr = new XMLHttpRequest();
    xhr.open('GET', '/api/modal-info/', true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.setRequestHeader('Accept', 'application/json');
    
    // Gérer la réponse
    xhr.onload = function() {
      if (xhr.status === 200) {
        try {
          modalInfoData = JSON.parse(xhr.responseText);
          modalDataLoaded = true;
          console.log('Données modales chargées avec succès via AJAX');
          resolve(true);
        } catch(e) {
          console.error('Erreur lors du parsing des données modales:', e);
          modalDataLoaded = false;
          reject(e);
        }
      } else {
        console.error('Erreur lors du chargement des données modales:', xhr.status);
        modalDataLoaded = false;
        reject(new Error('Erreur HTTP: ' + xhr.status));
      }
    };
    
    // Gérer les erreurs
    xhr.onerror = function() {
      console.error('Erreur réseau lors du chargement des données modales');
      modalDataLoaded = false;
      reject(new Error('Erreur réseau'));
    };
    
    // Envoyer la requête
    xhr.send();
  });
}

// Fonction pour afficher la fenêtre modale avec les informations des niveaux pour la catégorie active
function showLevelInfoModal(infoType) {
  console.log('Affichage du modal des niveaux pour:', infoType);
  
  // Détecter la catégorie KSAT active
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) {
    console.error('Aucun onglet actif trouvé');
    return;
  }
  
  const activeTabId = activeTab.id;
  console.log('Onglet actif:', activeTabId);
  
  // Mapping des onglets vers les noms de catégories
  // Note: le nom doit correspondre exactement au nom dans la base de données
  const categoryMapping = {
    'task': { name: 'Task', displayName: 'Tasks (Tâches)', color: 'blue', letter: 'T' },
    'knowledge': { name: 'Knowledge', displayName: 'Knowledge (Connaissances)', color: 'green', letter: 'K' },
    'skill': { name: 'Skill', displayName: 'Skills (Compétences)', color: 'orange', letter: 'S' },
    'abilitie': { name: 'Ability', displayName: 'Abilities (Aptitudes)', color: 'purple', letter: 'A' }
  };
  
  const currentCategory = categoryMapping[activeTabId];
  if (!currentCategory) {
    console.error('Catégorie non reconnue pour l\'onglet:', activeTabId);
    return;
  }
  
  // Créer le modal
  const modal = document.createElement('div');
  modal.id = 'level-info-modal';
  modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4';
  
  const modalContent = document.createElement('div');
  modalContent.className = 'bg-white rounded-lg shadow-xl max-w-3xl w-full max-h-[90vh] overflow-auto';
  
  // Définir les titres et descriptions selon le type d'information
  let modalTitle = '';
  let modalDescription = '';
  
  switch(infoType) {
    case 'pertinence':
      modalTitle = `Pertinence (P) - ${currentCategory.displayName}`;
      modalDescription = `Indique l'importance de ces ${currentCategory.displayName.toLowerCase()} pour le poste`;
      break;
    case 'niveau-attendu':
      modalTitle = `Niveau Attendu (A) - ${currentCategory.displayName}`;
      modalDescription = `Le niveau de compétence requis pour ces ${currentCategory.displayName.toLowerCase()} dans des conditions normales`;
      break;
    case 'niveau-tolere':
      modalTitle = `Niveau Toléré (T) - ${currentCategory.displayName}`;
      modalDescription = `Le niveau minimum acceptable pour ces ${currentCategory.displayName.toLowerCase()} lors du recrutement`;
      break;
  }
  
  // En-tête
  const header = document.createElement('div');
  header.className = 'border-b px-6 py-4 flex justify-between items-center sticky top-0 bg-white rounded-t-lg';
  header.innerHTML = `
    <div>
      <h3 class="font-bold text-xl text-gray-800">${modalTitle}</h3>
      <p class="text-sm text-gray-600 mt-1">${modalDescription}</p>
    </div>
    <button type="button" id="close-level-modal" class="text-gray-500 hover:text-gray-700 text-2xl font-bold">&times;</button>
  `;
  
  // Corps du modal
  const body = document.createElement('div');
  body.className = 'p-6';
  
  // Créer le tableau avec les informations des niveaux pour la catégorie active
  const tableHTML = `
    <div class="overflow-x-auto">
      <table class="w-full border-collapse border border-gray-300">
        <thead>
          <tr class="bg-gray-100">
            <th class="border border-gray-300 px-4 py-3 text-left font-semibold">Catégorie KSAT</th>
            <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Niveau 0</th>
            <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Niveau 1</th>
            <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Niveau 2</th>
            <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Niveau 3</th>
          </tr>
        </thead>
        <tbody>
          <tr class="hover:bg-gray-50">
            <td class="border border-gray-300 px-4 py-3 font-medium ${currentCategory.color === 'blue' ? 'bg-blue-50' : currentCategory.color === 'green' ? 'bg-green-50' : currentCategory.color === 'orange' ? 'bg-orange-50' : 'bg-purple-50'}">
              <span class="${currentCategory.color === 'blue' ? 'text-blue-600' : currentCategory.color === 'green' ? 'text-green-600' : currentCategory.color === 'orange' ? 'text-orange-600' : 'text-purple-600'} font-bold">${currentCategory.letter}</span>${currentCategory.displayName.substring(1)}
            </td>
            <td class="border border-gray-300 px-4 py-3 text-center text-gray-500 italic">
              ${currentCategory.letter} non pertinant pour le poste
            </td>
            <td class="border border-gray-300 px-4 py-3 text-center" id="${activeTabId}-level-1">
              Chargement...
            </td>
            <td class="border border-gray-300 px-4 py-3 text-center" id="${activeTabId}-level-2">
              Chargement...
            </td>
            <td class="border border-gray-300 px-4 py-3 text-center" id="${activeTabId}-level-3">
              Chargement...
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <div class="mt-6 p-4 ${currentCategory.color === 'blue' ? 'bg-blue-50' : currentCategory.color === 'green' ? 'bg-green-50' : currentCategory.color === 'orange' ? 'bg-orange-50' : 'bg-purple-50'} rounded-lg">
      <h4 class="font-semibold ${currentCategory.color === 'blue' ? 'text-blue-800' : currentCategory.color === 'green' ? 'text-green-800' : currentCategory.color === 'orange' ? 'text-orange-800' : 'text-purple-800'} mb-2">Information importante :</h4>
      <p class="text-sm ${currentCategory.color === 'blue' ? 'text-blue-700' : currentCategory.color === 'green' ? 'text-green-700' : currentCategory.color === 'orange' ? 'text-orange-700' : 'text-purple-700'}">
        ${infoType === 'pertinence' ? `Les niveaux de pertinence indiquent l'importance relative de ces ${currentCategory.displayName.toLowerCase()} pour le poste.` : 
          infoType === 'niveau-attendu' ? `Les niveaux attendus représentent le niveau de maîtrise requis pour ces ${currentCategory.displayName.toLowerCase()} dans des conditions normales de travail.` :
          `Les niveaux tolérés représentent le niveau minimum acceptable pour ces ${currentCategory.displayName.toLowerCase()} lors du recrutement, permettant une montée en compétence progressive.`}
      </p>
    </div>
  `;
  
  body.innerHTML = tableHTML;
  
  // Assembler le modal
  modalContent.appendChild(header);
  modalContent.appendChild(body);
  modal.appendChild(modalContent);
  
  // Ajouter au DOM
  document.body.appendChild(modal);
  
  // Charger les données des select options
  loadSelectOptionsData(infoType, activeTabId, currentCategory);
  
  // Gestionnaire de fermeture
  const closeButton = document.getElementById('close-level-modal');
  closeButton.addEventListener('click', () => {
    document.body.removeChild(modal);
  });
  
  // Fermeture en cliquant sur l'overlay
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
  
  // Fermeture avec la touche Escape
  const handleEscape = (e) => {
    if (e.key === 'Escape') {
      document.body.removeChild(modal);
      document.removeEventListener('keydown', handleEscape);
    }
  };
  document.addEventListener('keydown', handleEscape);
}

// Fonction pour charger les données des select options
function loadSelectOptionsData(infoType, activeTabId, currentCategory) {
  // Afficher un message de chargement dans les cellules
  for (let level = 1; level <= 3; level++) {
    const cellId = `${activeTabId}-level-${level}`;
    const cell = document.getElementById(cellId);
    if (cell) {
      cell.innerHTML = `
        <div class="flex items-center justify-center">
          <div class="animate-pulse flex space-x-1">
            <div class="h-2 w-2 bg-blue-400 rounded-full"></div>
            <div class="h-2 w-2 bg-blue-400 rounded-full"></div>
            <div class="h-2 w-2 bg-blue-400 rounded-full"></div>
          </div>
        </div>
      `;
    }
  }

  console.log(`Chargement des données pour ${currentCategory.name}...`);
  
  // Créer la requête AJAX pour récupérer les données des select options
  const xhr = new XMLHttpRequest();
  xhr.open('GET', '/api/select-options/', true);
  xhr.setRequestHeader('Content-Type', 'application/json');
  xhr.setRequestHeader('Accept', 'application/json');
  
  xhr.onload = function() {
    console.log(`Réponse reçue (statut ${xhr.status})`);
    
    if (xhr.status === 200) {
      try {
        console.log('Contenu de la réponse:', xhr.responseText.substring(0, 200) + '...');
        const data = JSON.parse(xhr.responseText);
        populateModalTable(data, infoType, activeTabId, currentCategory);
      } catch(e) {
        console.error('Erreur lors du parsing des données des select options:', e);
        showLoadingError(activeTabId);
      }
    } else {
      console.error('Erreur lors du chargement des données des select options:', xhr.status);
      showLoadingError(activeTabId);
    }
  };
  
  xhr.onerror = function() {
    console.error('Erreur réseau lors du chargement des données des select options');
    showLoadingError(activeTabId);
  };
  
  xhr.send();
}

// Fonction pour populer le tableau du modal avec les données
function populateModalTable(data, infoType, activeTabId, currentCategory) {
  // Déterminer la catégorie de select selon le type d'information et la catégorie KSAT active
  let selectCategory = '';
  switch(infoType) {
    case 'pertinence':
      selectCategory = 'Importance';
      break;
    case 'niveau-attendu':
      // Pour Skills et Abilities, utiliser Type de maîtrise 2 car Type de maîtrise 1 n'existe pas
      if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
        selectCategory = 'Type de maîtrise 2';
      } else {
        selectCategory = 'Type de maîtrise 1';
      }
      break;
    case 'niveau-tolere':
      // Pour Task, utiliser Type de maîtrise 2 ou Type de maîtrise 3 selon disponibilité
      if (currentCategory.name === 'Task') {
        selectCategory = 'Type de maîtrise 2';
      } else if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
        selectCategory = 'Type de maîtrise 3';
      } else {
        selectCategory = 'Type de maîtrise 2';
      }
      break;
  }
  
  // Debug pour voir les données reçues
  console.log("Données reçues:", data);
  console.log("Catégorie courante:", currentCategory);
  console.log("Catégorie de select:", selectCategory);
  
  // Récupérer les options pour la catégorie active et ce type de select
  if (!data || Object.keys(data).length === 0) {
    console.error("Aucune donnée n'a été reçue");
    showLoadingError(activeTabId);
    return;
  }
  
  // Vérifier si le type KSAT existe dans les données
  if (!data[currentCategory.name]) {
    console.error(`Le type KSAT '${currentCategory.name}' n'existe pas dans les données`);
    console.log("Types KSAT disponibles:", Object.keys(data));
    showLoadingError(activeTabId);
    return;
  }
  
  const categoryData = data[currentCategory.name];
  
  // Vérifier si la catégorie de select existe pour ce type KSAT
  if (!categoryData[selectCategory]) {
    console.warn(`La catégorie de select '${selectCategory}' n'existe pas pour le type KSAT '${currentCategory.name}'`);
    console.log("Catégories disponibles:", Object.keys(categoryData));
    
    // Essayer une catégorie alternative
    let alternativeCategory = '';
    if (selectCategory === 'Type de maîtrise 1' && categoryData['Type de maîtrise 2']) {
      alternativeCategory = 'Type de maîtrise 2';
    } else if (selectCategory === 'Type de maîtrise 2' && categoryData['Type de maîtrise 1']) {
      alternativeCategory = 'Type de maîtrise 1';
    } else if (selectCategory === 'Type de maîtrise 3' && categoryData['Type de maîtrise 2']) {
      alternativeCategory = 'Type de maîtrise 2';
    }
    
    if (alternativeCategory) {
      console.log(`Utilisation de la catégorie alternative '${alternativeCategory}'`);
      selectCategory = alternativeCategory;
    } else {
      // Si aucune alternative n'est disponible
      showLoadingError(activeTabId);
      return;
    }
  }
  
  const options = categoryData[selectCategory];
  
  // Vérifier si des options sont disponibles
  if (!options || options.length === 0) {
    console.error(`Aucune option disponible pour '${currentCategory.name}' et '${selectCategory}'`);
    showLoadingError(activeTabId);
    return;
  }
  console.log(`Options pour ${currentCategory.name} et ${selectCategory}:`, options);
  
  // Populer les niveaux 1, 2, 3
  for (let level = 1; level <= 3; level++) {
    const cellId = `${activeTabId}-level-${level}`;
    const cell = document.getElementById(cellId);
    
    if (cell) {
      // Trouver l'option correspondant au niveau
      // Mapping des valeurs selon le type de catégorie et le niveau
      let option;
      
      if (currentCategory.name === 'Task' && (selectCategory === 'Type de maîtrise 1' || selectCategory === 'Type de maîtrise 2')) {
        // Pour Tasks, les niveaux sont B, S, M
        if (level === 1) option = options.find(opt => opt.value === 'B');
        else if (level === 2) option = options.find(opt => opt.value === 'S');
        else if (level === 3) option = options.find(opt => opt.value === 'M');
        
        // Vérification supplémentaire pour toutes les catégories au niveau 3
        if (level === 3 && !option) {
          // Recherches supplémentaires selon la catégorie
          if (currentCategory.name === 'Task') {
            // Pour Task, chercher M avec insensibilité à la casse
            option = options.find(opt => opt.value.toUpperCase() === 'M');
          } 
          else if (currentCategory.name === 'Knowledge') {
            // Pour Knowledge, chercher D ou 3 ou 4
            option = options.find(opt => ['D', '3', '4'].includes(opt.value));
          }
          else if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
            // Pour Skill/Ability, chercher 3 ou des variations
            option = options.find(opt => ['3', 'HIGH', 'EXPERT', 'ADVANCED'].includes(opt.value.toUpperCase()));
          }
          
          // Si toujours pas trouvé, afficher une description par défaut
          if (!option) {
            // Descriptions spécifiques selon la catégorie
            let title = '';
            let description = '';
            
            if (currentCategory.name === 'Task') {
              title = "Proficiency level MASTER";
              description = "Capable de former et d'encadrer les autres. Niveau le plus élevé de maîtrise.";
            } 
            else if (currentCategory.name === 'Knowledge') {
              title = "Level D (Analysis & Evaluation)";
              description = "Capacité à analyser et évaluer les connaissances à un niveau expert. Niveau le plus élevé.";
            }
            else if (currentCategory.name === 'Skill') {
              title = "Niveau 3 (Expert)";
              description = "Capable de gérer indépendamment une grande variété de tâches complexes. Niveau le plus élevé.";
            }
            else if (currentCategory.name === 'Ability') {
              title = "Niveau 3 (Expert)";
              description = "Maîtrise complète et capacité à résoudre des problèmes complexes. Niveau le plus élevé.";
            }
            
            cell.innerHTML = `
              <div class="text-sm">
                <div class="font-medium">${title}</div>
                <div class="text-xs text-gray-600 mt-1">${description}</div>
              </div>
            `;
            continue; // Passer à l'itération suivante
          }
        }
      } 
      else if ((currentCategory.name === 'Skill' || currentCategory.name === 'Ability') && 
               (selectCategory === 'Type de maîtrise 2' || selectCategory === 'Type de maîtrise 3')) {
        // Pour Skills et Abilities, les niveaux sont numériques 1, 2, 3
        option = options.find(opt => opt.value === level.toString());
      }
      else if (currentCategory.name === 'Knowledge') {
        // Pour Knowledge, les niveaux peuvent être A, B, C, D ou 1, 2, 3
        if (level === 1) option = options.find(opt => opt.value === '1' || opt.value === 'A');
        else if (level === 2) option = options.find(opt => opt.value === '2' || opt.value === 'B' || opt.value === 'C');
        else if (level === 3) option = options.find(opt => opt.value === '3' || opt.value === 'D');
      }
      else {
        // Fallback général
        option = options.find(opt => {
          return opt.value === level.toString() || 
                (level === 1 && (opt.value === 'A' || opt.value === '1' || opt.value === 'B')) ||
                (level === 2 && (opt.value === 'B' || opt.value === '2' || opt.value === 'C' || opt.value === 'S')) ||
                (level === 3 && (opt.value === 'C' || opt.value === '3' || opt.value === 'D' || opt.value === 'M'));
        });
      }
      
      if (option) {
        cell.innerHTML = `
          <div class="text-sm">
            <div class="font-medium">${option.title || `Niveau ${level}`}</div>
            <div class="text-xs text-gray-600 mt-1">${option.description || 'Aucune description disponible'}</div>
          </div>
        `;
        
        // Pour le débogage
        console.log(`Option trouvée pour ${currentCategory.name}, niveau ${level}:`, option);
              } else {
          // Pour le débogage
          console.warn(`Aucune option trouvée pour ${currentCategory.name}, niveau ${level}, catégorie ${selectCategory}`);
          console.log('Options disponibles:', options.map(o => `${o.value}: ${o.title}`));
          
          // Fallback pour tous les niveaux dans toutes les catégories
          if (level === 3) {
            // Fallback spécifique pour le niveau 3
            let title = '';
            let description = '';
            
            if (currentCategory.name === 'Task') {
              title = "Proficiency level MASTER";
              description = "Capable de former et d'encadrer les autres. Niveau le plus élevé de maîtrise.";
            } 
            else if (currentCategory.name === 'Knowledge') {
              title = "Level D (Analysis & Evaluation)";
              description = "Capacité à analyser et évaluer les connaissances à un niveau expert. Niveau le plus élevé.";
            }
            else if (currentCategory.name === 'Skill') {
              title = "Niveau 3 (Expert)";
              description = "Capable de gérer indépendamment une grande variété de tâches complexes. Niveau le plus élevé.";
            }
            else if (currentCategory.name === 'Ability') {
              title = "Niveau 3 (Expert)";
              description = "Maîtrise complète et capacité à résoudre des problèmes complexes. Niveau le plus élevé.";
            }
            
            cell.innerHTML = `
              <div class="text-sm">
                <div class="font-medium">${title}</div>
                <div class="text-xs text-gray-600 mt-1">${description}</div>
              </div>
            `;
          } 
          else if (level === 2) {
            // Fallback pour le niveau 2
            let title = '';
            let description = '';
            
            if (currentCategory.name === 'Task') {
              title = "Proficiency level SENIOR";
              description = "Autonome au quotidien. Peut accomplir les tâches sans supervision.";
            } 
            else if (currentCategory.name === 'Knowledge') {
              title = "Level C (Application)";
              description = "Capable d'appliquer les connaissances dans différentes situations.";
            }
            else if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
              title = "Niveau 2 (Intermédiaire)";
              description = "Capable de traiter de manière autonome certaines tâches complexes.";
            }
            
            cell.innerHTML = `
              <div class="text-sm">
                <div class="font-medium">${title}</div>
                <div class="text-xs text-gray-600 mt-1">${description}</div>
              </div>
            `;
          }
          else if (level === 1) {
            // Fallback pour le niveau 1
            let title = '';
            let description = '';
            
            if (currentCategory.name === 'Task') {
              title = "Proficiency level BASIC";
              description = "Notions, pas encore autonome. Nécessite une supervision.";
            } 
            else if (currentCategory.name === 'Knowledge') {
              title = "Level A/B (Familiarity/Comprehension)";
              description = "Connaissance de base et compréhension des concepts fondamentaux.";
            }
            else if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
              title = "Niveau 1 (Base)";
              description = "Doit être familier avec cette compétence, notions de base.";
            }
            
            cell.innerHTML = `
              <div class="text-sm">
                <div class="font-medium">${title}</div>
                <div class="text-xs text-gray-600 mt-1">${description}</div>
              </div>
            `;
          }
          else {
            cell.innerHTML = `<span class="text-gray-400 text-sm">Non défini</span>`;
          }
        }
    }
  }
}

// Fonction pour afficher une erreur de chargement
function showLoadingError(activeTabId) {
  for (let level = 1; level <= 3; level++) {
    const cellId = `${activeTabId}-level-${level}`;
    const cell = document.getElementById(cellId);
    if (cell) {
      cell.innerHTML = `
        <div class="text-center">
          <span class="text-red-500 text-sm">Erreur de chargement</span>
          <button 
            class="ml-2 px-2 py-0.5 text-xs bg-gray-200 hover:bg-gray-300 rounded" 
            onclick="retryLoadingData('${activeTabId}')">
            Réessayer
          </button>
        </div>
      `;
    }
  }
}

// Fonction pour réessayer de charger les données
function retryLoadingData(activeTabId) {
  const currentCategory = categoryMapping[activeTabId];
  if (!currentCategory) return;
  
  // Déterminer le type d'information actif
  let infoType = '';
  const infoButtons = document.querySelectorAll('[id^="info-"]');
  for (const button of infoButtons) {
    if (button.getAttribute('onclick').includes('pertinence')) {
      infoType = 'pertinence';
      break;
    } else if (button.getAttribute('onclick').includes('niveau-attendu')) {
      infoType = 'niveau-attendu';
      break;
    } else if (button.getAttribute('onclick').includes('niveau-tolere')) {
      infoType = 'niveau-tolere';
      break;
    }
  }
  
  // Recharger les données
  loadSelectOptionsData(infoType, activeTabId, currentCategory);
}

// Fonction pour afficher la fenêtre modale d'information
function showModalInfo(buttonId) {
  console.log('Affichage du modal pour le bouton:', buttonId);
  
  // Vérifier si les données sont chargées
  if (!modalDataLoaded || !modalInfoData || !modalInfoData.categories) {
    console.log('Les données ne sont pas encore chargées, on essaie de les charger...');
    
    // Afficher un message d'attente
    const waitingModal = document.createElement('div');
    waitingModal.style.position = 'fixed';
    waitingModal.style.top = '0';
    waitingModal.style.left = '0';
    waitingModal.style.width = '100%';
    waitingModal.style.height = '100%';
    waitingModal.style.backgroundColor = 'rgba(0,0,0,0.5)';
    waitingModal.style.display = 'flex';
    waitingModal.style.justifyContent = 'center';
    waitingModal.style.alignItems = 'center';
    waitingModal.style.zIndex = '9999';
    
    const messageBox = document.createElement('div');
    messageBox.style.backgroundColor = 'white';
    messageBox.style.padding = '20px';
    messageBox.style.borderRadius = '5px';
    messageBox.innerHTML = 'Chargement des informations détaillées...';
    
    waitingModal.appendChild(messageBox);
    document.body.appendChild(waitingModal);
    
    // Essayer de charger les données via AJAX
    initModalData()
      .then(() => {
        // Supprimer le message d'attente
        document.body.removeChild(waitingModal);
        
        // Rappeler cette fonction maintenant que les données sont chargées
        showModalInfo(buttonId);
      })
      .catch(error => {
        // Supprimer le message d'attente
        document.body.removeChild(waitingModal);
        
        // Afficher un message d'erreur
        alert('Impossible de charger les informations détaillées. Veuillez réessayer ultérieurement.');
        console.error('Erreur lors du chargement des données modales:', error);
      });
    
    return;
  }
  
  console.log('Données modales disponibles:', modalInfoData);
  
  // Déterminer le type de KSAT actif
  const isKnowledgeTab = document.getElementById('knowledge').classList.contains('hidden') === false;
  const isSkillTab = document.getElementById('skill').classList.contains('hidden') === false;
  const isAbilitieTab = document.getElementById('abilitie').classList.contains('hidden') === false;
  
  let ksatType = 'task'; // Par défaut
  if (isKnowledgeTab) ksatType = 'knowledge';
  if (isSkillTab) ksatType = 'skill';
  if (isAbilitieTab) ksatType = 'ability';
  
  console.log('Type KSAT actif:', ksatType);
  
  // Déterminer le titre et les options en fonction du bouton
  let modalTitle = '';
  let options = [];
  
  // Récupérer les données du modal depuis l'objet modalInfoData
  if (modalInfoData.categories[buttonId] &&
      modalInfoData.categories[buttonId].infos && 
      modalInfoData.categories[buttonId].infos[ksatType]) {
    const modalInfo = modalInfoData.categories[buttonId].infos[ksatType];
    modalTitle = modalInfo.title || getDefaultTitle(buttonId);
    options = modalInfo.options || [];
    console.log('Données trouvées pour', buttonId, 'et', ksatType, ':', modalInfo);
  } else {
    console.warn('Aucune donnée trouvée pour', buttonId, 'et', ksatType);
    modalTitle = getDefaultTitle(buttonId);
  }
  
  // Fonction pour obtenir un titre par défaut en fonction du bouton
  function getDefaultTitle(buttonId) {
    switch(buttonId) {
      case 'info-button-1':
        return 'Importance (0-3)';
      case 'info-button-2':
        return 'Type de maîtrise (B, S, M)';
      case 'info-button-3':
        return 'Type de maîtrise simplifié (B, S)';
      default:
        return 'Information';
    }
  }
  
  // Créer le modal
  const modal = document.createElement('div');
  modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4';
  
  const modalContent = document.createElement('div');
  modalContent.className = 'bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-auto';
  
  // En-tête
  const header = document.createElement('div');
  header.className = 'border-b px-4 py-3 flex justify-between items-center sticky top-0 bg-white';
  header.innerHTML = `
    <h3 class="font-bold text-lg">${modalTitle}</h3>
    <button type="button" class="text-gray-500 hover:text-white text-xl">&times;</button>
  `;
  
  // Corps
  const body = document.createElement('div');
  body.className = 'p-4';
  
  // Si aucune option n'est disponible, afficher un message
  if (!options.length) {
    const message = document.createElement('p');
    message.textContent = 'Aucune information disponible pour cette section.';
    message.className = 'text-gray-600 italic';
    body.appendChild(message);
  }
  
  // Créer le contenu pour chaque option
  options.forEach(option => {
    const optionDiv = document.createElement('div');
    optionDiv.className = 'mb-4 pb-4 border-b last:border-0';
    
    // Titre avec badge
    const title = document.createElement('h4');
    title.className = 'font-bold text-md mb-2 flex items-center';
    const badge = document.createElement('span');
    badge.className = 'inline-block w-6 h-6 rounded-full bg-blue-600 text-white flex items-center justify-center mr-2';
    badge.textContent = option.text || '';
    
    title.appendChild(badge);
    
    // Extraire le titre principal (avant le premier saut de ligne)
    const titleText = option.title ? option.title.split('\n')[0].trim() : '';
    title.appendChild(document.createTextNode(titleText));
    optionDiv.appendChild(title);
    
    // Contenu formaté (après le premier saut de ligne)
    if (option.title && option.title.includes('\n')) {
      const content = document.createElement('div');
      content.className = 'text-sm text-gray-700 pl-8';
      
      const formattedText = option.title
        .substring(option.title.indexOf('\n'))
        .replace(/---/g, '<hr class="my-2 border-gray-200">')
        .replace(/\n/g, '<br>');
      
      content.innerHTML = formattedText;
      optionDiv.appendChild(content);
    }
    
    body.appendChild(optionDiv);
  });
  
  // Assembler le modal
  modalContent.appendChild(header);
  modalContent.appendChild(body);
  modal.appendChild(modalContent);
  
  // Ajouter au DOM
  document.body.appendChild(modal);
  
  // Gestionnaires d'événements pour fermer le modal
  const closeBtn = header.querySelector('button');
  closeBtn.addEventListener('click', () => document.body.removeChild(modal));
  modal.addEventListener('click', (e) => {
    if (e.target === modal) document.body.removeChild(modal);
  });
}

// Cette fonction sera appelée une fois le DOM chargé pour récupérer les données JSON
function loadModalData() {
  console.log('Tentative de chargement des données modales...');
  try {
    const modalInfoElement = document.getElementById('modal-info-data');
    console.log('Elément modal-info-data:', modalInfoElement);
    
    if (modalInfoElement && modalInfoElement.textContent.trim()) {
      console.log('Contenu JSON brut:', modalInfoElement.textContent.substring(0, 100) + '...');
      modalInfoData = JSON.parse(modalInfoElement.textContent);
      console.log('Données modales chargées avec succès', modalInfoData);
      modalDataLoaded = true;
      return true;
    } else {
      console.warn('Script JSON des modals vide ou introuvable - vérifiez que populate_modal_infos.py a été exécuté');
      modalDataLoaded = false;
      return false;
    }
  } catch(e) {
    console.error('Erreur lors du chargement des données modales:', e);
    modalDataLoaded = false;
    return false;
  }
}

// Fonction pour regrouper visuellement les colonnes du même work_role selon la couleur de leur catégorie
function colorizeColumns() {
  console.log('Application des styles aux colonnes selon la couleur de la catégorie...');
  
  try {
    // Sélectionner tous les tableaux dans tous les onglets (visibles ou non)
    const tables = document.querySelectorAll('.tab-content table');
    if (!tables.length) {
      console.error('Aucun tableau trouvé dans la page');
      return;
    }
    
    // Appliquer les styles à chaque tableau
    tables.forEach(table => {
      // Sélectionner les en-têtes de colonnes (sans compter la première colonne qui est la description)
      const headers = table.querySelectorAll('thead th');
      const numColumns = headers.length - 1; // -1 pour exclure la colonne de description
      
      if (numColumns <= 0) return;
      
      // Parcourir chaque colonne et appliquer les styles
      for (let i = 1; i <= numColumns; i++) { // Commencer à 1 pour sauter la colonne de description
        const header = headers[i];
        if (!header) continue;
        
        // Récupérer les attributs data pour déterminer le work_role
        const roleId = header.getAttribute('data-role-id');
        const groupId = header.getAttribute('data-group-id');
        
        // Récupérer la couleur de la catégorie via un attribut data
        const categoryColor = header.getAttribute('data-category-color');
        
        if (categoryColor) {
          // Créer les couleurs à partir de la couleur de la catégorie
          const bgColor = `rgba(${categoryColor}, 0.15)`;
          const borderColor = `rgba(${categoryColor}, 1)`;
          
          // Appliquer un style à l'en-tête
          header.style.backgroundColor = bgColor;
          header.style.borderTop = `3px solid ${borderColor}`;
          
          // Si c'est la première colonne du groupe ou qu'il n'y a pas de groupe
          if (!groupId || i % 2 === 1) {
            header.style.borderLeft = `3px solid ${borderColor}`;
          }
          // Si c'est la dernière colonne du groupe ou la dernière colonne du tableau
          if (!groupId || i % 2 === 0 || i === numColumns) {
            header.style.borderRight = `3px solid ${borderColor}`;
          }
          
          // Appliquer le même style à toutes les cellules de cette colonne
          const rows = table.querySelectorAll('tbody tr');
          rows.forEach(row => {
            if (row.cells.length <= i) return;
            
            const cell = row.cells[i];
            if (cell) {
              cell.style.backgroundColor = `rgba(${categoryColor}, 0.05)`; // Plus léger pour les cellules
              
              // Si c'est la première colonne du groupe ou qu'il n'y a pas de groupe
              if (!groupId || i % 2 === 1) {
                cell.style.borderLeft = `3px solid ${borderColor}`;
              }
              // Si c'est la dernière colonne du groupe ou la dernière colonne du tableau
              if (!groupId || i % 2 === 0 || i === numColumns) {
                cell.style.borderRight = `3px solid ${borderColor}`;
              }
            }
          });
        } else {
          console.warn(`Pas de couleur de catégorie définie pour la colonne ${i}`);
        }
      }
    });
    
    console.log('Styles appliqués avec succès aux colonnes des tableaux');
  } catch (error) {
    console.error('Erreur lors de l\'application des styles:', error);
  }
}


document.addEventListener("DOMContentLoaded", () => {
  console.log('DOM chargé, initialisation de l\'interface...');
  
  // Initialiser les données modales via AJAX (asynchrone)
  initModalData()
    .then(success => {
      console.log('Initialisation des données modales réussie!');
      // Appeler la fonction pour colorier les colonnes par groupes
      colorizeColumns();
      // Initialiser les compteurs de sélection
      setTimeout(() => {
        initializeSelectionCounters();
      }, 500); // Délai plus long pour s'assurer que tous les éléments sont prêts
    })
    .catch(error => {
      console.error('Impossible d\'initialiser les données modales:', error);
      const errorDiv = document.createElement('div');
      errorDiv.style.backgroundColor = '#ffeeee';
      errorDiv.style.color = '#cc0000';
      errorDiv.style.padding = '10px';
      errorDiv.style.margin = '10px';
      errorDiv.style.borderRadius = '5px';
      errorDiv.innerHTML = '<strong>Erreur:</strong> Impossible de charger les informations détaillées. Contactez l\'administrateur.';
      document.body.prepend(errorDiv);
    });
  
  // Attachement direct des gestionnaires d'événements aux boutons d'information
  console.log('Attachement des événements aux boutons d\'information...');
  document.querySelectorAll('[id^="info-button-"]').forEach(button => {
    console.log('Attachement événement au bouton:', button.id);
    button.onclick = function(e) {
      console.log('Clic sur le bouton d\'information:', this.id);
      e.preventDefault();
      e.stopPropagation();
      showModalInfo(this.id);
    };
  });
  
  const tabs = document.querySelectorAll(".tab-button");
  const contents = document.querySelectorAll(".tab-content");

  function activate(btn) {
    tabs.forEach(b => {
      b.classList.toggle("border-blue-500", b===btn);
      b.classList.toggle("text-blue-600", b===btn);
    });
    contents.forEach(c => c.classList.add("hidden"));
    const activeTabContent = document.getElementById(btn.dataset.tab);
    activeTabContent.classList.remove("hidden");

    // Déplacer les contrôles globaux dans l'en-tête du tableau de l'onglet actif
    const controlsContent = document.getElementById('global-controls-content');
    const headerCell = activeTabContent.querySelector('thead th:first-child');
    
    if (controlsContent && headerCell) {
        // S'assurer que le contenu de la cellule est dans un conteneur flex
        let flexWrapper = headerCell.querySelector('.header-flex-wrapper');
        if (!flexWrapper) {
            flexWrapper = document.createElement('div');
            flexWrapper.className = 'flex items-center header-flex-wrapper';
            // Déplacer le contenu existant de la cellule dans le wrapper
            while (headerCell.firstChild) {
                flexWrapper.appendChild(headerCell.firstChild);
            }
            headerCell.appendChild(flexWrapper);
        }
        // Ajouter les contrôles au wrapper
        flexWrapper.appendChild(controlsContent);
    }
    
    // Afficher/masquer les boutons d'information selon l'onglet actif
    const isActiveTab = btn.dataset.tab === 'task' || btn.dataset.tab === 'knowledge';
    document.querySelectorAll('.info-buttons').forEach(buttons => {
      if (isActiveTab) {
        buttons.classList.remove('hidden');
      } else {
        buttons.classList.add('hidden');
      }
    });
    
    // Mettre à jour l'onglet actif et le compteur
    currentActiveTab = btn.dataset.tab;
    
    // S'assurer que les compteurs sont à jour pour cet onglet
    updateSelectionCountersForTab(btn.dataset.tab);
    updateSelectionCounter(btn.dataset.tab);
    
    // RESTAURATION CRITIQUE DES OPTIONS DES SELECTS POUR LE NOUVEL ONGLET ACTIF
    console.log(`Restauration des options pour l'onglet ${btn.dataset.tab}`);
    try {
      // Vérifier si la fonction existe (ajoutée plus tard dans le code)
      if (typeof restaurerOptionsSelects === 'function') {
        restaurerOptionsSelects();
      } else {
        // Fallback si la fonction n'existe pas encore
        console.log("La fonction restaurerOptionsSelects n'existe pas encore, restauration manuelle");
        const tab = document.getElementById(btn.dataset.tab);
        if (tab) {
          const selectGroups = tab.querySelectorAll('.select-group');
          selectGroups.forEach(group => {
            const selects = group.querySelectorAll('select');
            selects.forEach((select, selectIndex) => {
              if (select.options.length <= 1) {
                // Restaurer les options selon la position du select
                if (selectIndex === 0) {  // Premier select (pertinence)
                  select.innerHTML = '';
                  select.appendChild(new Option('--', ''));
                  select.appendChild(new Option('0', '0'));
                  select.appendChild(new Option('1', '1'));
                  select.appendChild(new Option('2', '2'));
                  select.appendChild(new Option('3', '3'));
                }
                else if (selectIndex === 1) {  // Deuxième select
                  select.innerHTML = '';
                  select.appendChild(new Option('--', ''));
                  
                  if (btn.dataset.tab === 'task') {
                    select.appendChild(new Option('B', 'B'));
                    select.appendChild(new Option('S', 'S'));
                    select.appendChild(new Option('M', 'M'));
                  } 
                  else if (btn.dataset.tab === 'knowledge') {
                    select.appendChild(new Option('A', 'A'));
                    select.appendChild(new Option('B', 'B'));
                    select.appendChild(new Option('C', 'C'));
                    select.appendChild(new Option('D', 'D'));
                  } 
                  else {  // skill et abilitie
                    select.appendChild(new Option('1', '1'));
                    select.appendChild(new Option('2', '2'));
                    select.appendChild(new Option('3', '3'));
                  }
                }
                else if (selectIndex === 2) {  // Troisième select
                  select.innerHTML = '';
                  select.appendChild(new Option('--', ''));
                  
                  if (btn.dataset.tab === 'task') {
                    select.appendChild(new Option('B', 'B'));
                    select.appendChild(new Option('S', 'S'));
                  } 
                  else if (btn.dataset.tab === 'knowledge') {
                    select.appendChild(new Option('A', 'A'));
                    select.appendChild(new Option('B', 'B'));
                    select.appendChild(new Option('C', 'C'));
                  } 
                  else {  // skill et abilitie
                    select.appendChild(new Option('1', '1'));
                    select.appendChild(new Option('2', '2'));
                  }
                }
              }
            });
          });
        }
      }
    } catch (error) {
      console.error("Erreur lors de la restauration des options:", error);
    }
    
    // Observer les selects dans le nouvel onglet actif et mettre à jour l'état des selects globaux
    setTimeout(() => {
      observeSelectChanges();
      // Mettre à jour les options des contrôles globaux en fonction de la catégorie active
      updateGlobalSelectOptions(btn.dataset.tab);
      
      // Mettre à jour les dépendances des contrôles globaux
      const globalPertinenceSelect = document.getElementById('global-pertinence-select');
      const globalAttenduSelect = document.getElementById('global-niveau-attendu-select');
      if (globalPertinenceSelect) {
          handleGlobalPertinenceChange(globalPertinenceSelect.value);
      }
      if (globalAttenduSelect) {
          updateGlobalTolereOptions(globalAttenduSelect.value);
      }
    }, 100);
  }

  tabs.forEach(btn => btn.addEventListener("click", () => activate(btn)));
  if (tabs.length) {
    activate(tabs[0]);
    // S'assurer que les contrôles globaux sont correctement initialisés
    setTimeout(() => {
      updateGlobalSelectOptions(tabs[0].dataset.tab);
    }, 200);
  }
  
  // Initialiser immédiatement les contrôles globaux avec force
  setTimeout(() => {
    // Forcer l'initialisation manuelle des contrôles globaux  
    const globalSecondary = document.getElementById('global-niveau-attendu-select');
    const globalTertiary = document.getElementById('global-niveau-tolere-select');
    
    if (globalSecondary && globalTertiary) {
      console.log('Force initialisation des contrôles globaux...');
      
      // Par défaut, commencer avec les options de Task (premier onglet)
      globalSecondary.innerHTML = '<option value="">--</option>' +
                                  '<option value="B" title="Basic">B</option>' +
                                  '<option value="S" title="Senior">S</option>' +
                                  '<option value="M" title="Master">M</option>';
      
      globalTertiary.innerHTML = '<option value="">--</option>' +
                                '<option value="B" title="Basic">B</option>' +
                                '<option value="S" title="Senior">S</option>';
      
      console.log('Options par défaut ajoutées aux contrôles globaux');
      
      // Ensuite appeler la fonction normale
      const firstActiveTab = document.querySelector('.tab-button.text-blue-600') || tabs[0];
      if (firstActiveTab) {
        setTimeout(() => {
          updateGlobalSelectOptions(firstActiveTab.dataset.tab);
          console.log('Contrôles globaux mis à jour pour:', firstActiveTab.dataset.tab);
        }, 100);
      }
    } else {
      console.error('Contrôles globaux non trouvés lors de l\'initialisation!');
    }
  }, 100);
  
  // Initialiser les selects au chargement
  document.querySelectorAll('.primary-select').forEach(select => {
    if (select.classList.contains('knowledge-select')) {
      handleKnowledgeSelectChange(select);
    } else if (select.closest('#skill')) {
      handleSkillSelectChange(select);
    } else if (select.closest('#abilitie')) {
      handleAbilitySelectChange(select);
    } else {
      handleSelectChange(select);
    }
  });
  
  // Initialiser la dépendance entre les selects pour toutes les catégories
  document.querySelectorAll('.select-group').forEach(group => {
    const secondarySelects = group.querySelectorAll('.secondary-select');
    if (secondarySelects.length >= 1) {
      const secondSelect = secondarySelects[0];
      
      // Si c'est un groupe de selects de Knowledge
      if (group.querySelector('.knowledge-select')) {
        handleKnowledgeSecondarySelectChange(secondSelect);
      } 
      // Si c'est un groupe de selects de Skills
      else if (group.closest('#skill')) {
        handleSkillSecondarySelectChange(secondSelect);
      }
      // Si c'est un groupe de selects d'Abilities
      else if (group.closest('#abilitie')) {
        handleAbilitySecondarySelectChange(secondSelect);
      }
      // Sinon c'est un groupe de selects de Task
      else {
        handleSecondarySelectChange(secondSelect);
      }
    }
  });
  
  // Initialiser l'observation des selects et l'état des selects globaux
  setTimeout(() => {
    observeSelectChanges();
    // Initialiser les options des contrôles globaux pour l'onglet actif au chargement
    if (currentActiveTab) {
      updateGlobalSelectOptions(currentActiveTab);
    }
  }, 200);
  
  // Les données des modals sont déjà chargées au début du script
  console.log('Configuration des modals terminée');
  
  // Ajouter un écouteur d'événement pour tous les selects dans tous les onglets
  document.querySelectorAll('#skill select, #abilitie select, #task select, #knowledge select').forEach(select => {
    select.addEventListener('change', function() {
      // Récupérer l'identifiant de l'onglet parent
      const tabContent = this.closest('.tab-content');
      if (tabContent) {
        const tabId = tabContent.id;
        console.log(`Select changé dans l'onglet ${tabId}`); 
        // Mettre à jour le compteur pour cet onglet
        updateSelectionCountersForTab(tabId);
      }
    });
  });
});

// Fonction pour initialiser les compteurs de sélection pour tous les onglets
function initializeSelectionCounters() {
  const tabIds = ['task', 'knowledge', 'skill', 'abilitie'];
  
  console.log('Initialisation des compteurs pour tous les onglets');
  tabIds.forEach(tabId => {
    updateSelectionCountersForTab(tabId);
  });
  
  // Mettre à jour le compteur pour l'onglet actif
  if (currentActiveTab) {
    updateSelectionCounter(currentActiveTab);
  } else {
    // Si aucun onglet actif n'est défini, utiliser le premier
    const firstTab = document.querySelector('.tab-button');
    if (firstTab) {
      currentActiveTab = firstTab.getAttribute('data-tab');
      updateSelectionCounter(currentActiveTab);
    }
  }
  
  // Débug pour vérifier les compteurs
  console.log('Compteurs initialisés:', selectionCounters);
}

// Fonction pour mettre à jour les compteurs de sélection pour un onglet spécifique
function updateSelectionCountersForTab(tabId) {
  const tabContent = document.getElementById(tabId);
  if (!tabContent) {
    console.log('Tab content non trouvé pour ' + tabId);
    return; 
  }
  
  // Réinitialiser les compteurs pour cet onglet
  selectionCounters[tabId] = { selected: 0, total: 0 };
  
  // Récupérer toutes les lignes dans ce tableau
  const rows = tabContent.querySelectorAll('tbody tr');
  
  // Ne compter que les lignes qui ont des selects (lignes avec des données)
  let validRows = 0;
  rows.forEach(row => {
    const selectGroup = row.querySelector('.select-group');
    if (selectGroup) {
      validRows++;
      
      // Adapter la recherche en fonction du type d'onglet
      let firstSelect = null;
      
      // Rechercher le premier select (n1) selon la structure spécifique à chaque onglet
      if (tabId === 'knowledge') {
        firstSelect = selectGroup.querySelector('.knowledge-select');
      } else if (tabId === 'skill' || tabId === 'abilitie') {
        // Pour Skills et Abilities, prendre explicitement le premier select de la sélection
        const allSelects = selectGroup.querySelectorAll('select');
        if (allSelects.length > 0) {
          firstSelect = allSelects[0];
        }
      } else {
        // Pour task et autres
        firstSelect = selectGroup.querySelectorAll('select')[0];
      }
      
      if (firstSelect && firstSelect.value && firstSelect.value !== '0') {
        selectionCounters[tabId].selected++;
      }
    }
  });
  
  // Mettre à jour le total avec seulement les lignes valides
  selectionCounters[tabId].total = validRows;
  
  console.log(`Compteur mis à jour pour ${tabId}: ${selectionCounters[tabId].selected}/${selectionCounters[tabId].total} (lignes valides: ${validRows})`);
  
  // Si c'est l'onglet actif, mettre à jour le compteur affiché
  if (tabId === currentActiveTab) {
    updateSelectionCounter(tabId);
  }
}

// Fonction pour mettre à jour l'affichage du compteur par onglet
function updateSelectionCounter(tabId) {
  // Mettre à jour le compteur
  const counterElement = document.getElementById('current-tab-counter');
  if (counterElement && selectionCounters[tabId]) {
    counterElement.textContent = `${selectionCounters[tabId].selected}/${selectionCounters[tabId].total}`;
  }
  
  // Mettre à jour le nom de la catégorie
  const tabNameElement = document.getElementById('current-tab-name');
  if (tabNameElement) {
    // Formater le nom de la catégorie avec majuscule et pluriel si nécessaire
    let categoryName = tabId;
    if (categoryName === 'task') {
      categoryName = 'Tasks';
    } else if (categoryName === 'knowledge') {
      categoryName = 'Knowledge';
    } else if (categoryName === 'skill') {
      categoryName = 'Skills';
    } else if (categoryName === 'abilitie') {
      categoryName = 'Abilities';
    }
    tabNameElement.textContent = `${categoryName} :`;
  }
  
  // Mettre à jour le compteur global
  updateGlobalCounter();
}

// Fonction pour mettre à jour le compteur global
function updateGlobalCounter() {
  let globalSelected = 0;
  let globalTotal = 0;
  
  // Calculer les totaux globaux
  Object.keys(selectionCounters).forEach(tabId => {
    globalSelected += selectionCounters[tabId].selected || 0;
    globalTotal += selectionCounters[tabId].total || 0;
  });
  
  // Mettre à jour l'affichage du compteur global
  const globalCounterElement = document.getElementById('global-counter');
  if (globalCounterElement) {
    globalCounterElement.textContent = `${globalSelected}/${globalTotal}`;
  }
  
  console.log(`Compteur global mis à jour: ${globalSelected}/${globalTotal}`);
}

// Fonction pour gérer le changement du premier select pour les Tasks et Knowledge
function handleSelectChange(primarySelect) {
  const selectGroup = primarySelect.closest('.select-group');
  const secondarySelects = Array.from(selectGroup.querySelectorAll('.secondary-select'));
  const select2 = secondarySelects[0];
  const select3 = secondarySelects[1];
  
  // Mise à jour du compteur après changement de select
  const tabContent = primarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Gérer le select 2
  if (primarySelect.value === '0') {
    // Si le premier select est 0, désactiver le select 2
    select2.disabled = true;
    select2.classList.add('opacity-50', 'cursor-not-allowed');
    select2.selectedIndex = 0;
  } else {
    // Sinon, activer le select 2
    select2.disabled = false;
    select2.classList.remove('opacity-50', 'cursor-not-allowed');
  }
  
  // Gérer le select 3
  if (primarySelect.value === '2') {
    // Si le premier select est 2, activer le select 3
    select3.disabled = false;
    select3.classList.remove('opacity-50', 'cursor-not-allowed');
  } else {
    // Sinon, désactiver le select 3
    select3.disabled = true;
    select3.classList.add('opacity-50', 'cursor-not-allowed');
    select3.selectedIndex = 0;
  }
}

// Fonction pour gérer le changement du premier select pour les Skills
function handleSkillSelectChange(primarySelect) {
  const selectGroup = primarySelect.closest('.select-group');
  const secondarySelects = Array.from(selectGroup.querySelectorAll('.secondary-select'));
  const select2 = secondarySelects[0];
  const select3 = secondarySelects[1];
  
  // Mise à jour du compteur après changement de select
  const tabContent = primarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Gérer le select 2
  if (primarySelect.value === '0') {
    // Si le premier select est 0, désactiver le select 2
    select2.disabled = true;
    select2.classList.add('opacity-50', 'cursor-not-allowed');
    select2.selectedIndex = 0;
    
    // Désactiver aussi le select 3
    select3.disabled = true;
    select3.classList.add('opacity-50', 'cursor-not-allowed');
    select3.selectedIndex = 0;
  } else {
    // Sinon, activer le select 2
    select2.disabled = false;
    select2.classList.remove('opacity-50', 'cursor-not-allowed');
    
    // Vérifier si le premier select est 2, seul cas où le select 3 peut être activé
    if (primarySelect.value === '2') {
      // Le select 3 pourra être activé en fonction du select 2
      handleSkillSecondarySelectChange(select2);
    } else {
      // Pour les valeurs 1 et 3 du premier select, désactiver toujours le select 3
      select3.disabled = true;
      select3.classList.add('opacity-50', 'cursor-not-allowed');
      select3.selectedIndex = 0;
    }
  }
}

// Fonction pour gérer le changement du premier select pour les Abilities
function handleAbilitySelectChange(primarySelect) {
  const selectGroup = primarySelect.closest('.select-group');
  const secondarySelects = Array.from(selectGroup.querySelectorAll('.secondary-select'));
  const select2 = secondarySelects[0];
  const select3 = secondarySelects[1];
  
  // Mise à jour du compteur après changement de select
  const tabContent = primarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Gérer le select 2
  if (primarySelect.value === '0') {
    // Si le premier select est 0, désactiver le select 2
    select2.disabled = true;
    select2.classList.add('opacity-50', 'cursor-not-allowed');
    select2.selectedIndex = 0;
    
    // Désactiver aussi le select 3
    select3.disabled = true;
    select3.classList.add('opacity-50', 'cursor-not-allowed');
    select3.selectedIndex = 0;
  } else {
    // Sinon, activer le select 2
    select2.disabled = false;
    select2.classList.remove('opacity-50', 'cursor-not-allowed');
    
    // Vérifier si le premier select est 2, seul cas où le select 3 peut être activé
    if (primarySelect.value === '2') {
      // Le select 3 pourra être activé en fonction du select 2
      handleAbilitySecondarySelectChange(select2);
    } else {
      // Pour les valeurs 1 et 3 du premier select, désactiver toujours le select 3
      select3.disabled = true;
      select3.classList.add('opacity-50', 'cursor-not-allowed');
      select3.selectedIndex = 0;
    }
  }
}

// Fonction pour gérer le changement du deuxième select pour les Skills
function handleSkillSecondarySelectChange(secondarySelect) {
  const selectGroup = secondarySelect.closest('.select-group');
  const thirdSelect = selectGroup.querySelectorAll('.secondary-select')[1];
  const primarySelect = selectGroup.querySelector('.primary-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = secondarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Vérifier si nous sommes dans l'onglet Skills
  const isSkillTab = selectGroup.closest('#skill') !== null;
  
  // Si nous ne sommes pas dans Skills, sortir de la fonction
  if (!isSkillTab) return;
  
  // Ne pas modifier le troisième select si c'est un événement déclenché par le contrôle global
  const isGlobalEvent = secondarySelect.hasAttribute('data-global-change');
  if (isGlobalEvent) {
    return;
  }
  
  // Réinitialiser le troisième select
  thirdSelect.innerHTML = '';
  thirdSelect.selectedIndex = 0;
  
  // Vérifier d'abord si le premier select a l'option 2 sélectionnée
  // C'est la seule valeur du premier select qui permet d'activer le troisième select
  if (primarySelect.value !== '2') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50', 'cursor-not-allowed');
    return;
  }
  
  // Pour Skills: récupérer dynamiquement les options 1 et 2 depuis les selects existants
  const allSelects = document.querySelectorAll('select');
  let options = [];
  
  // Collecter les options des selects dans l'onglet Skills
  allSelects.forEach(selectEl => {
    if (selectEl.closest('#skill')) {
      Array.from(selectEl.options).forEach(opt => {
        // Ajouter uniquement les options avec les valeurs 1, 2 et éviter les doublons
        if (['1', '2'].includes(opt.value) && 
            !options.some(so => so.value === opt.value)) {
          options.push({
            value: opt.value,
            text: opt.text || opt.value,
            title: opt.title || ''
          });
        }
      });
    }
  });
  
  // Trier les options par valeur
  options.sort((a, b) => parseInt(a.value) - parseInt(b.value));
  
  // Si aucune option n'a été trouvée dans le DOM, utiliser des valeurs par défaut
  if (options.length === 0) {
    options = [
      { value: '1', text: '1', title: "Must be familiar with this competency" },
      { value: '2', text: '2', title: "Must be capable of independently handling some complex tasks" }
    ];
  }
  
  // Gérer les options et l'état du troisième select en fonction de la valeur du deuxième select
  thirdSelect.disabled = false;
  thirdSelect.classList.remove('opacity-50', 'cursor-not-allowed');
  
  // Ajouter les options appropriées
  options.forEach(option => {
    const newOpt = document.createElement('option');
    newOpt.value = option.value;
    newOpt.text = option.text;
    newOpt.title = option.title;
    thirdSelect.appendChild(newOpt);
    
    // Si le deuxième select est 2, désactiver l'option 2
    if (secondarySelect.value === '2' && option.value === '2') {
      newOpt.disabled = true;
    }
    // Si le deuxième select est 1, désactiver tout le select n3
    else if (secondarySelect.value === '1') {
      thirdSelect.disabled = true;
      thirdSelect.classList.add('opacity-50', 'cursor-not-allowed');
    }
  });
  
  // Forçage de la sélection à 1 si le select n2 est 2
  if (secondarySelect.value === '2') {
    thirdSelect.value = '1';
  }
}

// Fonction pour gérer le changement du deuxième select pour les Abilities
function handleAbilitySecondarySelectChange(secondarySelect) {
  const selectGroup = secondarySelect.closest('.select-group');
  const thirdSelect = selectGroup.querySelectorAll('.secondary-select')[1];
  const primarySelect = selectGroup.querySelector('.primary-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = secondarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Vérifier si nous sommes dans l'onglet Abilities
  const isAbilitieTab = selectGroup.closest('#abilitie') !== null;
  
  // Si nous ne sommes pas dans Abilities, sortir de la fonction
  if (!isAbilitieTab) return;
  
  // Ne pas modifier le troisième select si c'est un événement déclenché par le contrôle global
  const isGlobalEvent = secondarySelect.hasAttribute('data-global-change');
  if (isGlobalEvent) {
    return;
  }
  
  // Réinitialiser le troisième select
  thirdSelect.innerHTML = '';
  thirdSelect.selectedIndex = 0;
  
  // Vérifier d'abord si le premier select a l'option 2 sélectionnée
  // C'est la seule valeur du premier select qui permet d'activer le troisième select
  if (primarySelect.value !== '2') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50', 'cursor-not-allowed');
    return;
  }
  
  // Pour Abilities: récupérer dynamiquement les options 1 et 2 depuis les selects existants
  const allSelects = document.querySelectorAll('select');
  let options = [];
  
  // Collecter les options des selects dans l'onglet Abilities
  allSelects.forEach(selectEl => {
    if (selectEl.closest('#abilitie')) {
      Array.from(selectEl.options).forEach(opt => {
        // Ajouter uniquement les options avec les valeurs 1, 2 et éviter les doublons
        if (['1', '2'].includes(opt.value) && 
            !options.some(so => so.value === opt.value)) {
          options.push({
            value: opt.value,
            text: opt.text || opt.value,
            title: opt.title || ''
          });
        }
      });
    }
  });
  
  // Trier les options par valeur
  options.sort((a, b) => parseInt(a.value) - parseInt(b.value));
  
  // Si aucune option n'a été trouvée dans le DOM, utiliser des valeurs par défaut
  if (options.length === 0) {
    options = [
      { value: '1', text: '1', title: "Must be familiar with this competency" },
      { value: '2', text: '2', title: "Must be capable of independently handling some complex tasks" }
    ];
  }
  
  // Gérer les options et l'état du troisième select en fonction de la valeur du deuxième select
  thirdSelect.disabled = false;
  thirdSelect.classList.remove('opacity-50', 'cursor-not-allowed');
  
  // Ajouter les options appropriées
  options.forEach(option => {
    const newOpt = document.createElement('option');
    newOpt.value = option.value;
    newOpt.text = option.text;
    newOpt.title = option.title;
    thirdSelect.appendChild(newOpt);
    
    // Si le deuxième select est 2, désactiver l'option 2
    if (secondarySelect.value === '2' && option.value === '2') {
      newOpt.disabled = true;
    }
    // Si le deuxième select est 1, désactiver tout le select n3
    else if (secondarySelect.value === '1') {
      thirdSelect.disabled = true;
      thirdSelect.classList.add('opacity-50', 'cursor-not-allowed');
    }
  });
  
  // Forçage de la sélection à 1 si le select n2 est 2
  if (secondarySelect.value === '2') {
    thirdSelect.value = '1';
  }
}

// Fonction pour collecter les données de comparaison et ouvrir la fenêtre de détails
function openComparisonWindow() {
  // Activer l'étape 2 uniquement pour l'utilisateur actuel
  // Récupérer le nom d'utilisateur de manière fiable
  let currentUser = '{% if user.is_authenticated %}{{ user.username }}{% else %}anonymous{% endif %}';
  
  if (!currentUser || currentUser === 'anonymous') {
    // Tenter de récupérer depuis une balise meta
    currentUser = document.querySelector('meta[name="username"]')?.content || 'anonymous';
  }
  
  console.log('Activating Etape 2 for user:', currentUser);
  
  // Ne pas utiliser de valeur globale qui serait partagée entre tous les utilisateurs
  // Utiliser uniquement un stockage spécifique à l'utilisateur
  try {
    // Utiliser serverStorage au lieu de localStorage
    serverStorage.getItem('etapeActivations').then(activationsStr => {
      const etapeActivations = JSON.parse(activationsStr || '{}');
      
      // Activer l'étape 2 pour cet utilisateur uniquement
      etapeActivations[currentUser] = {
        ...etapeActivations[currentUser] || {},
        etape2Activated: true
      };
      
      // Sauvegarder les activations mises à jour
      serverStorage.setItem('etapeActivations', JSON.stringify(etapeActivations));
      console.log('Saved etape2 activation state for user ' + currentUser + ':', etapeActivations[currentUser]);
    }).catch(error => {
      console.error('Error loading etape activations:', error);
    });
  } catch (error) {
    console.error('Error saving etape activation:', error);
  }
  
  // Collecter les données des différentes catégories
  const comparisonData = {
    task: [],
    knowledge: [],
    skill: [],
    abilitie: []
  };
  
  // Sauvegarder les totaux par catégorie pour comparer avec les OPM IDs par la suite
  const categoryTotals = {
    task: selectionCounters['task'].total,
    knowledge: selectionCounters['knowledge'].total,
    skill: selectionCounters['skill'].total,
    abilitie: selectionCounters['abilitie'].total
  };
  
  // Sauvegarder dans serverStorage pour accès dans compare_details.html
  Promise.all([
    serverStorage.setItem('totalTaskCount', categoryTotals.task),
    serverStorage.setItem('totalKnowledgeCount', categoryTotals.knowledge),
    serverStorage.setItem('totalSkillCount', categoryTotals.skill),
    serverStorage.setItem('totalAbilitieCount', categoryTotals.abilitie)
  ]).then(() => {
    console.log('Category totals saved to serverStorage');
  }).catch(error => {
    console.error('Error saving category totals:', error);
  });
  
  // Collecter les informations sur les OPM IDs
  const opmIds = [];
  const opmIdsData = {};
  
  // Créer un mapping des colonnes par OPM ID (car un même OPM ID peut avoir plusieurs colonnes)
  const opmIdColumnMap = {};
  const thElements = document.querySelectorAll('thead tr:first-of-type th:not(:first-child)');
  
  thElements.forEach((th, columnIndex) => {
    const opmIdElement = th.querySelector('div div:first-child');
    if (opmIdElement) {
      const opmId = opmIdElement.textContent.trim();
      if (opmId && opmId !== '\xa0') { // \xa0 est un espace insécable
        // Ajouter cette colonne à la liste des colonnes de cet OPM ID
        if (!opmIdColumnMap[opmId]) {
          opmIdColumnMap[opmId] = [];
          // Aussi ajouter à la liste des OPM IDs si pas déjà présent
          if (!opmIds.includes(opmId)) {
            opmIds.push(opmId);
          }
        }
        opmIdColumnMap[opmId].push(columnIndex);
        
        // Initialiser les compteurs pour cet OPM ID si pas déjà fait
        if (!opmIdsData[opmId]) {
          opmIdsData[opmId] = {
            task: { selected: 0, total: 0, validRows: [] },
            knowledge: { selected: 0, total: 0, validRows: [] },
            skill: { selected: 0, total: 0, validRows: [] },
            abilitie: { selected: 0, total: 0, validRows: [] }
          };
        }
      }
    }
  });
  
  console.log('OPM IDs et leurs colonnes:', opmIdColumnMap);
  
  // Parcourir tous les onglets
  document.querySelectorAll('.tab-content').forEach(tabContent => {
    const ksatType = tabContent.id;  // par ex. "task", "knowledge", etc.
    
    // Parcourir tous les éléments qui ont une importance supérieure à 0
    tabContent.querySelectorAll('tbody tr').forEach((row, rowIndex) => {
      const descriptionCell = row.querySelector('td:first-child');
      if (!descriptionCell) return;
      
      // Vérifier si au moins un des selects a une valeur > 0
      const selects = descriptionCell.querySelectorAll('select');
      if (selects.length === 0) return;
      
      const importanceSelect = selects[0];
      // Vérifier si le premier select est différent de 0
      const isImportant = importanceSelect && importanceSelect.value !== "0";
      
      // Vérifier les colonnes de chaque OPM ID
      const opmIdColumns = row.querySelectorAll('td:not(:first-child)');
      
      // Extraire le texte de description
      const descriptionElement = descriptionCell.querySelector('p');
      if (!descriptionElement) return;
      const description = descriptionElement.textContent.trim();
      
      // Extraire les valeurs des selects
      const importanceText = selects[0]?.options[selects[0].selectedIndex]?.text || '';
      const type1Text = selects[1]?.options[selects[1].selectedIndex]?.text || '';
      const type2Text = selects[2]?.options[selects[2].selectedIndex]?.text || '';
      
      // Récupérer les URLs
      const urlElements = descriptionCell.querySelectorAll('.text-sm.text-gray-600.space-x-2 a');
      let dcwfUrl = '';
      let ncwfUrl = '';
      let ksatId = '';
      
      // Chercher l'ID du KSAT
      const idElement = descriptionCell.querySelector('.text-xs.text-gray-500');
      if (idElement) {
        ksatId = idElement.textContent.replace('ID: ', '').trim();
      }
      
      // Extraire les URLs
      urlElements.forEach(url => {
        const href = url.getAttribute('href') || '';
        const text = url.textContent.trim();
        
        if (href.includes('dcwf')) {
          dcwfUrl = { href: href, text: text };
        } else if (href.includes('ncwf') || href.includes('nist')) {
          ncwfUrl = { href: href, text: text };
        }
      });
      
      // Préparer l'objet de données pour cet élément
      const itemData = {
        description: description,
        importance: importanceText,
        type1: type1Text,
        type2: type2Text,
        dcwfUrl: dcwfUrl,
        ncwfUrl: ncwfUrl,
        id: ksatId,
        opmIdStatus: {}
      };
      
      // Pour chaque OPM ID, vérifier si au moins une des colonnes associées a un 
      Object.keys(opmIdColumnMap).forEach(opmId => {
        // Récupérer les indices des colonnes pour cet OPM ID
        const columnIndices = opmIdColumnMap[opmId];
        
        // Vérifier si au moins une colonne de cet OPM ID a un 
        let hasAnyCheckmark = false;
        
        // Pour chaque indice de colonne associé à cet OPM ID
        for (let i = 0; i < columnIndices.length; i++) {
          const columnIndex = columnIndices[i];
          // Vérifier si l'indice est valide pour cette ligne
          if (columnIndex < opmIdColumns.length) {
            const column = opmIdColumns[columnIndex];
            if (column.textContent.includes('')) {
              hasAnyCheckmark = true;
              break; // Si on trouve au moins un , pas besoin de continuer
            }
          }
        }
        
        // Stocker l'état pour cet OPM ID dans les données de l'élément
        itemData.opmIdStatus[opmId] = hasAnyCheckmark;
        
        // Mettre à jour les compteurs pour cet OPM ID
        // Ne compter dans le total que les lignes qui ont au moins un  dans l'une des colonnes de l'OPM ID
        if (hasAnyCheckmark) {
          opmIdsData[opmId][ksatType].total++;
          
          // Si la ligne a au moins un  et est importante, l'ajouter aux lignes valides pour cet OPM ID
          if (isImportant) {
            opmIdsData[opmId][ksatType].selected++;
            opmIdsData[opmId][ksatType].validRows.push(rowIndex);
          }
        }
      });
      
      // N'ajouter à la liste des éléments à comparer que si le select d'importance est > 0
      if (isImportant) {
        comparisonData[ksatType].push(itemData);
      }
    });
  });
  
  // Stocker les données dans serverStorage pour y accéder depuis la nouvelle fenêtre
  Promise.all([
    serverStorage.setItem('comparisonData', JSON.stringify(comparisonData)),
    serverStorage.setItem('opmIdsData', JSON.stringify(opmIdsData))
  ]).then(() => {
    // Ouvrir la nouvelle fenêtre seulement après avoir sauvegardé les données
    window.open("{% url 'ksat_compare_details' %}", "_blank", "width=1200,height=800");
  }).catch(error => {
    console.error('Error saving comparison data:', error);
    // Fallback en cas d'erreur
    localStorage.setItem('comparisonData', JSON.stringify(comparisonData));
    localStorage.setItem('opmIdsData', JSON.stringify(opmIdsData));
    window.open("{% url 'ksat_compare_details' %}", "_blank", "width=1200,height=800");
  });
}

// Fonction pour sauvegarder la sélection actuelle
function saveCurrentSelection() {
  // Collecter les données de tous les selects
  const allSelects = document.querySelectorAll('select');
  const selectValues = {};
  
  allSelects.forEach((select, index) => {
    // Sauvegarder l'ID de l'élément et sa valeur
    const selectId = select.id || `select_${index}`;
    selectValues[selectId] = select.value;
  });
  
  // Obtenir les informations sur les onglets et leur état actif
  const activeTab = document.querySelector('.tab-button.text-blue-600');
  const activeTabId = activeTab ? activeTab.getAttribute('data-tab') : null;
  
  // Collecter des informations sur les work roles pour le titre
  const roles = [];
  document.querySelectorAll('thead tr:first-of-type th:not(:first-child)').forEach(th => {
    const titleDiv = th.querySelector('div div:nth-child(2)');
    const frameworkDiv = th.querySelector('div div:nth-child(3) span');
    const opmIdDiv = th.querySelector('div div:first-child');
    
    if (titleDiv && frameworkDiv) {
      roles.push({
        title: titleDiv.textContent.trim(),
        framework: frameworkDiv.textContent.replace(/[\(\)]/g, '').trim(),
        opmId: opmIdDiv ? opmIdDiv.textContent.trim() : ''
      });
    }
  });
  
  // Sauvegarder l'URL actuelle pour pouvoir la restaurer
  const currentUrl = window.location.href;
  
  // Collecter toutes les données des KSAT pour chaque onglet
  const ksatData = {};
  
  // Parcourir tous les onglets
  document.querySelectorAll('.tab-content').forEach(tabContent => {
    const tabId = tabContent.id; // 'task', 'knowledge', 'skill', 'abilitie'
    ksatData[tabId] = [];
    
    // Parcourir toutes les lignes de cet onglet
    tabContent.querySelectorAll('tbody tr').forEach(row => {
      const firstCell = row.querySelector('td:first-child');
      if (!firstCell) return;
      
      // Extraire la description et l'ID
      const description = firstCell.querySelector('p.font-medium')?.textContent.trim() || '';
      const ksatId = firstCell.querySelector('.text-xs.text-gray-500')?.textContent.trim() || '';
      
      // Extraire les URLs DCWF et NCWF
      const dcwfUrl = firstCell.querySelector('a[href*="dcwf"]');
      const ncwfUrl = firstCell.querySelector('a[href*="ncwf"]') || firstCell.querySelector('a[href*="nist"]');
      
      // Extraire les valeurs des selects pour cette ligne
      const lineSelects = {};
      firstCell.querySelectorAll('select').forEach((select, idx) => {
        const selectId = select.id || `${tabId}_select_${idx}`;
        lineSelects[selectId] = {
          value: select.value,
          disabled: select.disabled,
          options: Array.from(select.options).map(opt => ({
            value: opt.value,
            text: opt.text,
            disabled: opt.disabled
          }))
        };
      });
      
      // Collecter les statuts () pour chaque rôle
      const roleStatuses = {};
      const roleCells = row.querySelectorAll('td:not(:first-child)');
      roleCells.forEach((cell, idx) => {
        if (roles[idx]) {
          roleStatuses[roles[idx].title] = cell.textContent.includes('');
        }
      });
      
      // Créer un objet représentant cette ligne KSAT
      const ksatItem = {
        description: description,
        id: ksatId.replace('ID: ', ''),
        dcwfUrl: dcwfUrl ? { href: dcwfUrl.href, text: dcwfUrl.textContent.trim() } : null,
        ncwfUrl: ncwfUrl ? { href: ncwfUrl.href, text: ncwfUrl.textContent.trim() } : null,
        selects: lineSelects,
        roleStatuses: roleStatuses
      };
      
      // Ajouter à la liste des KSAT pour cet onglet
      ksatData[tabId].push(ksatItem);
    });
  });
  
  // Récupérer le numéro de poste du localStorage
  const currentJobNumber = localStorage.getItem('currentJobNumber') || '';
  
  // Générer un identifiant unique pour cette sauvegarde
  const saveId = `save_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
  
  // Demander un nom pour cette sauvegarde
  let saveName = prompt("Donnez un nom à cette sauvegarde (optionnel):", "");
  if (saveName === null) {
    // L'utilisateur a annulé
    return;
  }
  
  // Si aucun nom n'est fourni, utiliser un nom par défaut avec la date
  if (!saveName.trim()) {
    const now = new Date();
    const dateStr = `${now.getDate()}/${now.getMonth() + 1}/${now.getFullYear()} ${now.getHours()}:${now.getMinutes()}`;
    saveName = `Sauvegarde du ${dateStr}`;
  }
  
  // Créer un objet de sauvegarde
  const saveData = {
    id: saveId,
    name: saveName,
    timestamp: new Date().toISOString(),
    jobNumber: currentJobNumber,  // Ajouter le numéro de poste
    selectValues: selectValues,
    activeTab: activeTabId,
    roles: roles,
    ksatData: ksatData,  // Ajouter les données complètes des KSAT
    counters: {
      task: selectionCounters['task'],
      knowledge: selectionCounters['knowledge'],
      skill: selectionCounters['skill'],
      abilitie: selectionCounters['abilitie']
    },
    currentUrl: currentUrl,  // Ajouter l'URL actuelle
    globalControls: {
      pertinence: document.getElementById('global-pertinence-select')?.value || '',
      attendu: document.getElementById('global-niveau-attendu-select')?.value || '',
      tolere: document.getElementById('global-niveau-tolere-select')?.value || ''
    }
  };

  // Enregistrer dans sessionStorage pour la persistance au F5
  sessionStorage.setItem('ksatLastSavedState', JSON.stringify(saveData));

  // Utiliser l'API du serveur pour sauvegarder les données au lieu du localStorage
  fetch('/api/ksat-selections/save/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // Pas besoin de CSRF token car nous utilisons @csrf_exempt
    },
    body: JSON.stringify({
      key: `ksat_selection_${saveId}`,
      value: saveData
    })
  })
  .then(response => {
    if (response.status === 403) {
      throw new Error('Vous devez être connecté pour sauvegarder des données sur le serveur. Veuillez vous connecter.');
    }
    else if (!response.ok) {
      throw new Error(`Erreur réseau lors de la sauvegarde (${response.status} ${response.statusText})`);
    }
    return response.json();
  })
  .then(data => {
    // Garder une copie dans localStorage pour compatibilité avec le code existant
    try {
      // Charger les sauvegardes existantes
      let savedSelections = JSON.parse(localStorage.getItem('ksatSavedSelections') || '[]');
      
      // Ajouter la nouvelle sauvegarde
      savedSelections.push(saveData);
      
      // Limiter à 50 sauvegardes maximum
      if (savedSelections.length > 50) {
        savedSelections = savedSelections.slice(savedSelections.length - 50);
      }
      
      // Sauvegarder dans localStorage (comme avant)
      localStorage.setItem('ksatSavedSelections', JSON.stringify(savedSelections));
    } catch (error) {
      console.error('Erreur localStorage:', error);
      // Continuer malgré l'erreur localStorage car les données sont sur le serveur
    }
    
    // Afficher un message de confirmation
    alert('Sélection sauvegardée avec succès!');
  })
  .catch(error => {
    console.error('Error saving selection:', error);
    alert('Erreur lors de la sauvegarde de la sélection: ' + error.message);
  });
}

// Ajouter fonction pour récupérer le token CSRF
function getCsrfToken() {
  // Récupérer le token CSRF des cookies
  const csrfTokenMatch = document.cookie.match(/csrftoken=([^;]+)/);
  return csrfTokenMatch ? csrfTokenMatch[1] : '';
}

// Ajouter les événements de clic aux boutons
document.addEventListener('DOMContentLoaded', function() {
  // Initialiser serverStorage
  initServerStorage();
  
  // Vérifier si l'utilisateur est connecté
  fetch('/api/ksat-selections/')
    .then(response => {
      if (response.status === 403) {
        console.warn("Vous n'êtes pas connecté. Les sauvegardes ne seront disponibles que dans ce navigateur.");
        // Afficher un message à l'utilisateur
        const saveButton = document.getElementById('save-selection-button');
        if (saveButton) {
          const warningIcon = document.createElement('span');
          warningIcon.className = 'ml-1 text-yellow-500';
          warningIcon.innerHTML = '⚠️';
          warningIcon.title = "Vous n'êtes pas connecté. Les sauvegardes ne seront disponibles que dans ce navigateur.";
          saveButton.appendChild(warningIcon);
        }
      } else {
        console.log("Utilisateur connecté, les sauvegardes seront disponibles sur tous les appareils.");
      }
    })
    .catch(error => {
      console.error("Erreur lors de la vérification de l'authentification:", error);
    });
  
  const compareButton = document.getElementById('compare-button');
  if (compareButton) {
    compareButton.addEventListener('click', openComparisonWindow);
  }
  
  
  const saveButton = document.getElementById('save-selection-button');
  if (saveButton) {
    saveButton.addEventListener('click', saveCurrentSelection);
  }
  
  // Lancer la restauration au chargement
  restoreStateOnLoad();
  
  // Charger les sauvegardes depuis le serveur pour la liste des sauvegardes
  loadSavedSelectionsFromServer();
});

// Nouvelle fonction pour charger les sauvegardes depuis le serveur
function loadSavedSelectionsFromServer() {
  // Vérifier si l'utilisateur est authentifié
  fetch('/api/ksat-selections/')
    .then(response => {
      if (!response.ok) {
        throw new Error('Erreur réseau lors du chargement des sauvegardes');
      }
      return response.json();
    })
    .then(data => {
      if (data && data.status === "success" && data.data && Array.isArray(data.data)) {
        console.log('Sauvegardes chargées depuis le serveur:', data.data.length);
        
        if (data.data.length > 0) {
          // Fusionner avec les sauvegardes locales existantes
          try {
            let localSelections = JSON.parse(localStorage.getItem('ksatSavedSelections') || '[]');
            
            // Créer un ensemble d'IDs locaux pour éviter les doublons
            const localIds = new Set(localSelections.map(item => item.id));
            
            // Nombre d'éléments ajoutés
            let addedCount = 0;
            
            // Ajouter les sauvegardes du serveur qui ne sont pas déjà présentes localement
            data.data.forEach(serverItem => {
              if (serverItem && serverItem.value && !localIds.has(serverItem.value.id)) {
                localSelections.push(serverItem.value);
                addedCount++;
              }
            });
            
            if (addedCount > 0) {
              // Limiter à 50 sauvegardes maximum et trier par date
              localSelections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
              if (localSelections.length > 50) {
                localSelections = localSelections.slice(0, 50);
              }
              
              // Mettre à jour le localStorage
              localStorage.setItem('ksatSavedSelections', JSON.stringify(localSelections));
              console.log(`localStorage mis à jour avec ${addedCount} nouvelles sauvegardes du serveur`);
            } else {
              console.log('Aucune nouvelle sauvegarde à ajouter.');
            }
          } catch (error) {
            console.error('Erreur lors de la fusion des sauvegardes:', error);
          }
        }
      } else {
        console.log('Aucune sauvegarde trouvée sur le serveur ou format de réponse incorrect');
      }
    })
    .catch(error => {
      console.error('Erreur lors du chargement des sauvegardes depuis le serveur:', error);
  });
}

// Fonctions pour la grille de contrôle global
function showTooltip(type) {
  let message = '';
  switch(type) {
    case 'pertinence':
      message = `PERTINENCE (P) :\n\n` +
                `• 0 - Aucune compétence requise\n` +
                `• 1 - Critique, 'Must have'\n` +
                `• 2 - Important mais acquis rapidement\n` +
                `• 3 - Secondaire / Complémentaire\n\n` +
                `Cette valeur indique l'importance de la compétence pour le poste.`;
      break;
    case 'niveau-attendu':
      message = `NIVEAU NORMALEMENT ATTENDU (A) :\n\n` +
                `• 1 - Niveau de base requis\n` +
                `• 2 - Niveau intermédiaire requis\n` +
                `• 3 - Niveau expert requis\n\n` +
                `Ce niveau représente les compétences attendues dans des conditions normales d'exercice du poste.`;
      break;
    case 'niveau-tolere':
      message = `NIVEAU TOLÉRÉ AU RECRUTEMENT (T) :\n\n` +
                `• 1 - Niveau minimum acceptable\n` +
                `• 2 - Niveau intermédiaire acceptable\n` +
                `• 3 - Niveau expert souhaité\n\n` +
                `Ce niveau représente le minimum acceptable lors du recrutement, en tenant compte de la formation possible après l'embauche.`;
      break;
  }
  
  if (message) {
    alert(message);
  }
}

function updateAllSelects(selectType, value) {
  try {
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  const tabId = activeTab.id;
    const allSelectGroups = activeTab.querySelectorAll('.select-group');
    let updatedCount = 0;

    allSelectGroups.forEach(group => {
          const selects = group.querySelectorAll('select');
      let targetSelect = null;

      if (selectType === 'primary' && selects.length > 0) {
        targetSelect = selects[0];
      } else if (selectType === 'secondary' && selects.length > 1) {
        targetSelect = selects[1];
      } else if (selectType === 'tertiary' && selects.length > 2) {
        targetSelect = selects[2];
      }
      
      if (!targetSelect) return;

      // Si la valeur est vide ("--"), on réinitialise le select s'il n'est pas désactivé
      if (value === "") {
        if (!targetSelect.disabled) {
          targetSelect.value = "";
          const changeEvent = new Event('change', { bubbles: true });
          targetSelect.dispatchEvent(changeEvent);
          updatedCount++;
        }
        return; // Passe à la ligne suivante
      }

      // Si la valeur n'est pas vide, on applique les validations
      if (targetSelect.disabled) {
        return; // Ne pas modifier les selects désactivés
      }

      const optionExists = Array.from(targetSelect.options).some(opt => opt.value === value && !opt.disabled);
      if (!optionExists) {
        return; // Ne pas modifier si l'option n'est pas valide/disponible
      }
      
      targetSelect.value = value;
          const changeEvent = new Event('change', { bubbles: true });
      targetSelect.dispatchEvent(changeEvent);
      updatedCount++;
    });

    const tabNames = { 'skill': 'Skills', 'abilitie': 'Abilities', 'task': 'Tasks', 'knowledge': 'Knowledge' };
    const typeNames = { 'primary': 'Pertinence', 'secondary': 'Niveau attendu', 'tertiary': 'Niveau toléré' };
    
    if (value === "") {
        showNotification(`${updatedCount} sélection(s) pour '${typeNames[selectType]}' réinitialisée(s)`, 'info');
    } else {
        showNotification(`${updatedCount} ligne(s) pour '${typeNames[selectType]}' mise(s) à jour`, 'success');
    }

    setTimeout(() => {
        const globalPertinenceSelect = document.getElementById('global-pertinence-select');
        const globalAttenduSelect = document.getElementById('global-niveau-attendu-select');
        if (globalPertinenceSelect) handleGlobalPertinenceChange(globalPertinenceSelect.value);
        if (globalAttenduSelect) updateGlobalTolereOptions(globalAttenduSelect.value);
    }, 100);

  } catch(error) {
    console.error("Erreur dans updateAllSelects:", error);
  }
}

function showNotification(message, type = 'info') {
  // Créer l'élément de notification
  const notification = document.createElement('div');
  notification.className = `fixed top-4 right-4 z-50 px-4 py-2 rounded shadow-lg text-white transition-all duration-300 transform translate-x-full`;
  
  // Appliquer le style selon le type
  switch(type) {
    case 'success':
      notification.classList.add('bg-green-500');
      break;
    case 'warning':
      notification.classList.add('bg-yellow-500');
      break;
    case 'error':
      notification.classList.add('bg-red-500');
      break;
    default:
      notification.classList.add('bg-blue-500');
  }
  
  notification.textContent = message;
  document.body.appendChild(notification);
  
  // Animation d'entrée
  setTimeout(() => {
    notification.classList.remove('translate-x-full');
  }, 100);
  
  // Suppression automatique après 3 secondes
  setTimeout(() => {
    notification.classList.add('translate-x-full');
    setTimeout(() => {
      document.body.removeChild(notification);
    }, 300);
  }, 3000);
}

// Fonction pour mettre à jour l'état des selects de contrôle global
function updateGlobalSelectsState() {
  try {
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  const tabId = activeTab.id;
  const globalPrimary = document.getElementById('global-pertinence-select');
  const globalSecondary = document.getElementById('global-niveau-attendu-select');
  const globalTertiary = document.getElementById('global-niveau-tolere-select');
  
  if (!globalPrimary || !globalSecondary || !globalTertiary) return;
  
    // Activer tous les selects par défaut
    globalPrimary.disabled = false;
    globalSecondary.disabled = false;
    globalTertiary.disabled = false;
    
    globalPrimary.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
    globalSecondary.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
    globalTertiary.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
    
    // Désactiver les selects selon les conditions spécifiques
    if (tabId === 'knowledge' || tabId === 'task' || tabId === 'skill' || tabId === 'abilitie') {
      // Si aucune sélection n'est active, désactiver tous les selects
      if (selectionCounters[tabId].selected === 0) {
        globalSecondary.disabled = true;
        globalTertiary.disabled = true;
        globalSecondary.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
        globalTertiary.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
      }
    }
  } catch(e) {
    console.error("Erreur updateGlobalSelectsState:", e);
  }
}

// Fonction modifiée pour observer les changements et mettre à jour l'état des selects globaux
function observeSelectChanges() {
  try {
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  // Observer tous les selects dans l'onglet actuel
  const allSelects = activeTab.querySelectorAll('select');
  allSelects.forEach(select => {
    // Supprimer l'ancien listener s'il existe
    select.removeEventListener('change', updateGlobalSelectsState);
    // Ajouter le nouveau listener
    select.addEventListener('change', updateGlobalSelectsState);
  });
  
  // Mettre à jour l'état initial
  updateGlobalSelectsState();
  } catch(e) {
    console.error("Erreur observeSelectChanges:", e);
  }
}

// Ce script s'exécute immédiatement
document.addEventListener('DOMContentLoaded', function() {
  // Attendre que la page soit complètement chargée
  setTimeout(() => {
    // Créer un tableau des onglets à activer manuellement pour forcer la mise à jour
    const tabsToForceUpdate = ['skill', 'abilitie'];
    
    // Sauvegarder l'onglet actif initial
    let activeTabButton = null;
    document.querySelectorAll('.tab-button').forEach(button => {
      if (button.classList.contains('text-blue-600')) {
        activeTabButton = button;
      }
    });
    
    // Parcourir chaque onglet à forcer
    let currentIndex = 0;
    
    function processNextTab() {
      if (currentIndex < tabsToForceUpdate.length) {
        const tabId = tabsToForceUpdate[currentIndex];
        currentIndex++;
        
        // Trouver le bouton d'onglet
        const tabButton = Array.from(document.querySelectorAll('.tab-button')).find(button => {
          return button.getAttribute('data-tab') === tabId;
        });
        
        if (tabButton) {
          console.log('Force updating tab: ' + tabId);
          tabButton.click();
          
          // Traiter le prochain onglet après un court délai
          setTimeout(processNextTab, 100);
        } else {
          processNextTab(); // Passer au suivant si l'onglet n'est pas trouvé
        }
      } else {
        // Une fois tous les onglets traités, revenir à l'onglet initial
        if (activeTabButton) {
          console.log('Returning to initial tab');
          activeTabButton.click();
          
          // Masquer l'overlay de chargement une fois tout le traitement terminé
          setTimeout(() => {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
              loadingOverlay.classList.add('hidden');
            }
          }, 500);
          
        } else {
          // Si aucun onglet actif n'a été trouvé, cliquer sur le premier
          const firstTab = document.querySelector('.tab-button');
          if (firstTab) {
            console.log('Clicking first tab as fallback');
            firstTab.click();
            
            // Masquer l'overlay de chargement
            setTimeout(() => {
              const loadingOverlay = document.getElementById('loading-overlay');
              if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
              }
            }, 500);
          } else {
            // Masquer l'overlay de chargement même si aucun onglet n'est trouvé
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
              loadingOverlay.classList.add('hidden');
            }
          }
        }
      }
    }
    
    // Démarrer le traitement des onglets
    processNextTab();
  }, 500);
});

// Fonction de secours pour masquer l'overlay en cas de problème
window.addEventListener('load', function() {
  // Masquer l'overlay après 20 secondes maximum quoi qu'il arrive
  setTimeout(() => {
    const loadingOverlay = document.getElementById('loading-overlay');
    if (loadingOverlay && !loadingOverlay.classList.contains('hidden')) {
      console.log('Masquage forcé de l\'overlay après délai maximum');
      loadingOverlay.classList.add('hidden');
    }
  }, 20000);
  

  
  // RESTAURATION URGENTE DES SELECTS DANS TOUTES LES CATÉGORIES
  console.log("RESTAURATION URGENTE DES SELECTS DANS TOUTES LES CATÉGORIES");
  
  // Restaurer les options pour chaque catégorie
  function restaurerOptionsSelects() {
    console.log("Début de la restauration des options pour tous les selects");
    
    // Parcourir toutes les catégories
    ['task', 'knowledge', 'skill', 'abilitie'].forEach(tabId => {
      console.log(`Restauration des options pour la catégorie ${tabId}`);
      const tab = document.getElementById(tabId);
      if (!tab) return;
      
      // Trouver tous les groupes de selects dans cette catégorie
      const selectGroups = tab.querySelectorAll('.select-group');
      console.log(`Nombre de groupes de selects trouvés dans ${tabId}: ${selectGroups.length}`);
      
      selectGroups.forEach((group, groupIndex) => {
        // Trouver tous les selects dans ce groupe
        const selects = group.querySelectorAll('select');
        console.log(`Groupe ${groupIndex}: ${selects.length} selects trouvés`);
        
        // Pour chaque select, vérifier et restaurer les options si nécessaire
        selects.forEach((select, selectIndex) => {
          // Si le select n'a pas d'options ou seulement l'option vide
          if (select.options.length <= 1) {
            console.log(`Restauration des options pour le select ${selectIndex} du groupe ${groupIndex} dans ${tabId}`);
            
            // Déterminer quelles options ajouter selon la catégorie et la position du select
            if (selectIndex === 0) {  // Premier select (pertinence)
              select.innerHTML = '';
              select.appendChild(new Option('--', ''));
              select.appendChild(new Option('0', '0'));
              select.appendChild(new Option('1', '1'));
              select.appendChild(new Option('2', '2'));
              select.appendChild(new Option('3', '3'));
            } 
            else if (selectIndex === 1) {  // Deuxième select (niveau attendu)
              select.innerHTML = '';
              select.appendChild(new Option('--', ''));
              
              if (tabId === 'task') {
                select.appendChild(new Option('B', 'B'));
                select.appendChild(new Option('S', 'S'));
                select.appendChild(new Option('M', 'M'));
              } 
              else if (tabId === 'knowledge') {
                select.appendChild(new Option('A', 'A'));
                select.appendChild(new Option('B', 'B'));
                select.appendChild(new Option('C', 'C'));
                select.appendChild(new Option('D', 'D'));
              } 
              else {  // skill et abilitie
                select.appendChild(new Option('1', '1'));
                select.appendChild(new Option('2', '2'));
                select.appendChild(new Option('3', '3'));
              }
            } 
            else if (selectIndex === 2) {  // Troisième select (niveau toléré)
              select.innerHTML = '';
              select.appendChild(new Option('--', ''));
              
              if (tabId === 'task') {
                select.appendChild(new Option('B', 'B'));
                select.appendChild(new Option('S', 'S'));
              } 
              else if (tabId === 'knowledge') {
                select.appendChild(new Option('A', 'A'));
                select.appendChild(new Option('B', 'B'));
                select.appendChild(new Option('C', 'C'));
              } 
              else {  // skill et abilitie
                select.appendChild(new Option('1', '1'));
                select.appendChild(new Option('2', '2'));
              }
            }
            
            console.log(`Options restaurées pour le select ${selectIndex}: ${select.options.length} options`);
          }
        });
      });
    });
    
         console.log("Restauration des options terminée");
   }
   
   // Exécuter la restauration immédiatement
   restaurerOptionsSelects();
   
   // Puis à nouveau après un court délai pour s'assurer que tout est bien chargé
   setTimeout(() => {
     restaurerOptionsSelects();
     
     // Mise à jour des contrôles globaux après restauration
     const activeTab = document.querySelector('.tab-button.text-blue-600');
     if (activeTab) {
       const tabId = activeTab.getAttribute('data-tab');
       console.log("Mise à jour des contrôles globaux après restauration pour:", tabId);
       updateGlobalSelectOptions(tabId);
     }
   }, 1000);
  
  // Attendre que tout soit chargé
  setTimeout(() => {
    // Remplacer le gestionnaire d'événements du select tertiaire
    const tertiaryGlobalSelect = document.getElementById('global-niveau-tolere-select');
    if (tertiaryGlobalSelect) {
      tertiaryGlobalSelect.onchange = function(e) {
        const value = this.value;
        if (value) {
          // Restaurer les options avant de mettre à jour
          restaurerOptionsSelects();
          // Puis forcer la mise à jour
          setTimeout(() => {
            forceUpdateAllTertiarySelects(value);
          }, 100);
          e.stopPropagation(); // Empêcher la propagation pour éviter que l'ancien gestionnaire s'exécute
        }
      };
      console.log("Nouveau gestionnaire d'événements installé pour le contrôle tertiaire");
    }
  }, 1500);
});

// Fonction pour forcer la mise à jour de tous les selects tertiaires
function forceUpdateAllTertiarySelects(value) {
  console.log("FORÇAGE de mise à jour des selects tertiaires avec la valeur:", value);
  
  // Obtenir l'onglet actif
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  const tabId = activeTab.id;
  console.log("Onglet actif:", tabId);
  
  // S'assurer que les options sont correctes pour la valeur sélectionnée
  let optionsValides = [];
  if (tabId === 'task') {
    optionsValides = ['B', 'S'];
  } else if (tabId === 'knowledge') {
    optionsValides = ['A', 'B', 'C'];
  } else { // skill et abilitie
    optionsValides = ['1', '2'];
  }
  
  // Vérifier si la valeur est valide pour cette catégorie
  if (!optionsValides.includes(value)) {
    console.warn(`La valeur ${value} n'est pas valide pour la catégorie ${tabId}. Options valides: ${optionsValides.join(', ')}`);
    showNotification(`La valeur ${value} n'est pas compatible avec la catégorie ${tabId}`, 'warning');
    return;
  }
  
  // Trouver tous les groupes de selects
  const selectGroups = activeTab.querySelectorAll('.select-group');
  console.log(`Nombre de groupes trouvés: ${selectGroups.length}`);
  
  // Compter les succès
  let successCount = 0;
  
  // Pour chaque groupe
  selectGroups.forEach((group, index) => {
    // Trouver tous les selects dans ce groupe
    const selects = group.querySelectorAll('select');
    
    // S'il y a au moins 3 selects (ou au moins 2 pour être sûr)
    if (selects.length >= 2) {
      // Prendre le dernier select
      const lastSelectIndex = selects.length - 1;
      const tertiarySelect = selects[lastSelectIndex];
      
      if (tertiarySelect) {
        console.log(`Groupe ${index}: Modification du select tertiaire (index ${lastSelectIndex})`, tertiarySelect);
        
        // Sauvegarder l'état actuel
        const wasDisabled = tertiarySelect.disabled;
        const oldValue = tertiarySelect.value;
        
        try {
          // Activer le select s'il est désactivé
          if (wasDisabled) {
            tertiarySelect.disabled = false;
          }
          
          // S'assurer que le select a les bonnes options
          if (tertiarySelect.options.length <= 1) {
            console.log("Le select n'a pas d'options, ajout des options");
            tertiarySelect.innerHTML = '';
            tertiarySelect.appendChild(new Option('--', ''));
            
            // Ajouter les options selon la catégorie
            if (tabId === 'task') {
              tertiarySelect.appendChild(new Option('B', 'B'));
              tertiarySelect.appendChild(new Option('S', 'S'));
            } else if (tabId === 'knowledge') {
              tertiarySelect.appendChild(new Option('A', 'A'));
              tertiarySelect.appendChild(new Option('B', 'B'));
              tertiarySelect.appendChild(new Option('C', 'C'));
            } else { // skill et abilitie
              tertiarySelect.appendChild(new Option('1', '1'));
              tertiarySelect.appendChild(new Option('2', '2'));
            }
          }
          
          // Vérifier si la valeur existe dans les options
          const valueExists = Array.from(tertiarySelect.options).some(opt => opt.value === value);
          
          if (valueExists) {
            // Appliquer la valeur
            tertiarySelect.value = value;
            
            // Créer et dispatcher un événement change
            const changeEvent = new Event('change', { bubbles: true });
            tertiarySelect.dispatchEvent(changeEvent);
            
            // Incrémenter le compteur de succès
            successCount++;
            
            // Restaurer l'état désactivé si nécessaire après un court délai
            if (wasDisabled) {
              setTimeout(() => {
                tertiarySelect.disabled = true;
              }, 100);
            }
            
            console.log(`Succès! Valeur modifiée de ${oldValue} à ${value}`);
          } else {
            console.error(`La valeur ${value} n'existe pas dans ce select. Options disponibles:`, 
                         Array.from(tertiarySelect.options).map(o => o.value));
            
                         // Ajouter l'option manquante
             if (optionsValides.includes(value)) {
               console.log(`Ajout de l'option manquante ${value}`);
               tertiarySelect.appendChild(new Option(value, value));
               tertiarySelect.value = value;
               successCount++;
             }
          }
        } catch (err) {
          console.error("Erreur lors de la modification:", err);
        }
      }
    }
  });
  
  // Afficher une notification avec le nombre de selects modifiés
  showNotification(`${successCount} contrôles de niveau toléré (T) mis à jour avec succès`, 'success');
}

// Fonction pour mettre à jour les options des contrôles globaux en fonction de la catégorie active
function updateGlobalSelectOptions(tabId) {
  try {
    console.log("Mise à jour des contrôles globaux pour l'onglet:", tabId);
    const activeTab = document.getElementById(tabId);
    if (!activeTab) return;
    
    const globalSecondary = document.getElementById('global-niveau-attendu-select');
    const globalTertiary = document.getElementById('global-niveau-tolere-select');
    
    if (!globalSecondary || !globalTertiary) {
      console.error("Contrôles globaux non trouvés");
      return;
    }
    
    // Sauvegarde des valeurs actuelles
    const secondaryValue = globalSecondary.value;
    const tertiaryValue = globalTertiary.value;
    
    console.log(`Valeurs actuelles avant mise à jour: A=${secondaryValue}, T=${tertiaryValue}`);
    
    // Réinitialiser les options
    globalSecondary.innerHTML = '<option value="">--</option>';
    globalTertiary.innerHTML = '<option value="">--</option>';
    
    // Ajouter les options selon la catégorie active
    if (tabId === 'task') {
      console.log("Configuration des options pour Task");
      // Options pour Task (B, S, M)
      globalSecondary.innerHTML += '<option value="B" title="Basic">B</option>';
      globalSecondary.innerHTML += '<option value="S" title="Senior">S</option>';
      globalSecondary.innerHTML += '<option value="M" title="Master">M</option>';
      
      // Pour le contrôle T (niveau toléré), on ne met que B et S (pas M car logiquement on ne tolère pas un niveau supérieur)
      globalTertiary.innerHTML += '<option value="B" title="Basic">B</option>';
      globalTertiary.innerHTML += '<option value="S" title="Senior">S</option>';
    } 
    else if (tabId === 'knowledge') {
      console.log("Configuration des options pour Knowledge");
      // Options pour Knowledge (A, B, C, D)
      globalSecondary.innerHTML += '<option value="A" title="Level A">A</option>';
      globalSecondary.innerHTML += '<option value="B" title="Level B">B</option>';
      globalSecondary.innerHTML += '<option value="C" title="Level C">C</option>';
      globalSecondary.innerHTML += '<option value="D" title="Level D">D</option>';
      
      // Pour le contrôle T (niveau toléré), on ne met que A, B, C (pas D car logiquement on ne tolère pas un niveau supérieur)
      globalTertiary.innerHTML += '<option value="A" title="Level A">A</option>';
      globalTertiary.innerHTML += '<option value="B" title="Level B">B</option>';
      globalTertiary.innerHTML += '<option value="C" title="Level C">C</option>';
    }
    else {
      console.log(`Configuration des options pour ${tabId} (Skill/Ability)`);
      // Options pour Skill et Ability (1, 2, 3)
      globalSecondary.innerHTML += '<option value="1" title="Level 1">1</option>';
      globalSecondary.innerHTML += '<option value="2" title="Level 2">2</option>';
      globalSecondary.innerHTML += '<option value="3" title="Level 3">3</option>';
      
      // Pour le contrôle T (niveau toléré), on ne met que 1, 2 (pas 3 car logiquement on ne tolère pas un niveau supérieur)
      globalTertiary.innerHTML += '<option value="1" title="Level 1">1</option>';
      globalTertiary.innerHTML += '<option value="2" title="Level 2">2</option>';
    }
    
    // Forcer un rafraîchissement visuel des selects
    globalSecondary.style.display = 'none';
    globalTertiary.style.display = 'none';
    
    // Petit délai pour permettre le re-rendu
    setTimeout(() => {
      globalSecondary.style.display = '';
      globalTertiary.style.display = '';
      
      console.log(`Options mises à jour pour ${tabId}:`);
      console.log(`- Global A (niveau attendu): ${globalSecondary.options.length} options`);
      console.log(`- Global T (niveau toléré): ${globalTertiary.options.length} options`);
      
      // Restaurer les valeurs si elles sont compatibles avec la nouvelle catégorie
      if (secondaryValue) {
        const secondaryOption = Array.from(globalSecondary.options).find(opt => opt.value === secondaryValue);
        if (secondaryOption) {
          globalSecondary.value = secondaryValue;
          console.log(`Valeur A restaurée: ${secondaryValue}`);
        } else {
          console.log(`Valeur A ${secondaryValue} non compatible avec ${tabId}, réinitialisée`);
        }
      }
      
      if (tertiaryValue) {
        const tertiaryOption = Array.from(globalTertiary.options).find(opt => opt.value === tertiaryValue);
        if (tertiaryOption) {
          globalTertiary.value = tertiaryValue;
          console.log(`Valeur T restaurée: ${tertiaryValue}`);
        } else {
          console.log(`Valeur T ${tertiaryValue} non compatible avec ${tabId}, réinitialisée`);
        }
      }
    }, 50);
    
  } catch (error) {
    console.error("Erreur lors de la mise à jour des contrôles globaux:", error);
  }
}

// Fonction pour montrer un infobulle sur les options des selects
function showInfoTooltip(select) {
  // Cette fonction existe uniquement pour compatibilité avec les attributs onclick existants
  // Elle n'a pas besoin d'implémentation
}

// Fonction pour restaurer l'état des contrôles globaux au chargement
function restoreGlobalControlsState() {
  const container = document.getElementById('global-controls-container');
  if (container) {
    const isHidden = localStorage.getItem('globalControlsHidden') === 'true';
    if (isHidden) {
      container.classList.add('hidden');
      const toggleButton = container.querySelector('button[onclick="toggleGlobalControls()"]');
      if (toggleButton) {
        toggleButton.textContent = '◀';
        toggleButton.title = 'Afficher les contrôles';
      }
    }
  }
}

// Fonction pour forcer l'apparition des options dans les selects tertiaires
function ensureTertiarySelectOptions() {
  console.log("Forçage de l'apparition des options dans les selects tertiaires");
  
  // Obtenir l'onglet actif
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  const tabId = activeTab.id;
  console.log("Onglet actif:", tabId);
  
  // Trouver tous les groupes de selects
  const selectGroups = activeTab.querySelectorAll('.select-group');
  console.log(`Nombre de groupes trouvés: ${selectGroups.length}`);
  
  // Pour chaque groupe
  selectGroups.forEach((group, index) => {
    // Trouver tous les selects dans ce groupe
    const selects = group.querySelectorAll('select');
    
    // S'il y a au moins 2 selects
    if (selects.length >= 2) {
      // Récupérer les références aux selects
      const primarySelect = selects[0];  // Premier select (pertinence)
      const secondarySelect = selects.length >= 2 ? selects[1] : null;  // Deuxième select (niveau attendu)
      const tertiarySelect = selects.length >= 3 ? selects[2] : null;  // Troisième select (niveau toléré)
      
      if (!tertiarySelect) {
        console.log(`Groupe ${index}: Pas de select tertiaire trouvé`);
        return;
      }
      
      console.log(`Groupe ${index}: Analyse du select tertiaire`, tertiarySelect);
      
      // Si le select tertiaire n'a pas d'options ou est désactivé
      if (tertiarySelect.options.length <= 1 || tertiarySelect.disabled) {
        console.log(`Groupe ${index}: Le select tertiaire n'a pas d'options ou est désactivé`);
        
        // Activer temporairement
        tertiarySelect.disabled = false;
        
        // Ajouter des options selon le type d'onglet
        if (tabId === 'task') {
          // Pour Task, ajouter les options B, S, M
          addOptionsToSelect(tertiarySelect, [
            { value: 'B', text: 'B', title: 'Basic' },
            { value: 'S', text: 'S', title: 'Senior' },
            { value: 'M', text: 'M', title: 'Master' }
          ]);
        } else if (tabId === 'knowledge') {
          // Pour Knowledge, ajouter les options A, B, C, D
          addOptionsToSelect(tertiarySelect, [
            { value: 'A', text: 'A', title: 'Level A' },
            { value: 'B', text: 'B', title: 'Level B' },
            { value: 'C', text: 'C', title: 'Level C' },
            { value: 'D', text: 'D', title: 'Level D' }
          ]);
        } else {
          // Pour Skill et Ability, ajouter les options 1, 2, 3
          addOptionsToSelect(tertiarySelect, [
            { value: '1', text: '1', title: 'Level 1' },
            { value: '2', text: '2', title: 'Level 2' },
            { value: '3', text: '3', title: 'Level 3' }
          ]);
        }
        

        
        // Si le select secondaire a une valeur, ajuster les options du tertiaire
        if (secondarySelect && secondarySelect.value) {
          console.log(`Ajustement des options selon la valeur du select secondaire: ${secondarySelect.value}`);
          
          if (tabId === 'task') {
            // Logique spécifique pour Task
            if (secondarySelect.value === 'B') {
              // Si B est sélectionné, désactiver le tertiaire
              tertiarySelect.disabled = true;
            } else if (secondarySelect.value === 'S') {
              // Si S est sélectionné, n'autoriser que B
              clearSelectExcept(tertiarySelect, ['B']);
            } else if (secondarySelect.value === 'M') {
              // Si M est sélectionné, autoriser B et S
              clearSelectExcept(tertiarySelect, ['B', 'S']);
            }
          } else if (tabId === 'knowledge') {
            // Logique spécifique pour Knowledge
            if (secondarySelect.value === 'A') {
              // Si A est sélectionné, désactiver le tertiaire
              tertiarySelect.disabled = true;
            } else if (secondarySelect.value === 'B') {
              // Si B est sélectionné, n'autoriser que A
              clearSelectExcept(tertiarySelect, ['A']);
            } else if (secondarySelect.value === 'C') {
              // Si C est sélectionné, autoriser A et B
              clearSelectExcept(tertiarySelect, ['A', 'B']);
            } else if (secondarySelect.value === 'D') {
              // Si D est sélectionné, autoriser A, B et C
              clearSelectExcept(tertiarySelect, ['A', 'B', 'C']);
            }
          } else {
            // Logique pour Skill et Ability
            if (secondarySelect.value === '1') {
              // Si 1 est sélectionné, désactiver le tertiaire
              tertiarySelect.disabled = true;
            } else if (secondarySelect.value === '2') {
              // Si 2 est sélectionné, n'autoriser que 1
              clearSelectExcept(tertiarySelect, ['1']);
            } else if (secondarySelect.value === '3') {
              // Si 3 est sélectionné, autoriser 1 et 2
              clearSelectExcept(tertiarySelect, ['1', '2']);
            }
          }
        }
        

      }
    }
  });
  
  console.log("Fin du forçage de l'apparition des options dans les selects tertiaires");
}

// Fonction utilitaire pour ajouter des options à un select
function addOptionsToSelect(select, options) {
  // Vider le select sauf la première option vide si elle existe
  if (select.options.length > 0 && select.options[0].value === '') {
    while (select.options.length > 1) {
      select.remove(1);
    }
  } else {
    select.innerHTML = '';
    
    // Ajouter une option vide au début
    const emptyOption = document.createElement('option');
    emptyOption.value = '';
    emptyOption.text = '--';
    select.appendChild(emptyOption);
  }
  
  // Ajouter les nouvelles options
  options.forEach(option => {
    const opt = document.createElement('option');
    opt.value = option.value;
    opt.text = option.text || option.value;
    if (option.title) opt.title = option.title;
    select.appendChild(opt);
  });
  
  console.log(`Options ajoutées au select. Nombre d'options: ${select.options.length}`);
}

// Fonction utilitaire pour ne conserver que certaines options
function clearSelectExcept(select, valuesToKeep) {
  // Convertir les options actuelles en tableau
  const options = Array.from(select.options);
  
  // Vider le select
  select.innerHTML = '';
  
  // Ajouter d'abord l'option vide si elle existait
  const emptyOption = options.find(opt => opt.value === '');
  if (emptyOption) {
    select.appendChild(emptyOption);
  }
  
  // Réajouter uniquement les options à conserver
  options.forEach(option => {
    if (valuesToKeep.includes(option.value)) {
      select.appendChild(option);
    }
  });
  
  console.log(`Select filtré. Options conservées: ${valuesToKeep.join(', ')}. Nombre d'options: ${select.options.length}`);
}

// Appeler cette fonction lorsqu'on change d'onglet ou lorsqu'on utilise le contrôle global T
document.addEventListener('DOMContentLoaded', function() {
  // Attendre que tout soit chargé
  setTimeout(() => {
    console.log("Initialisation des selects dans tous les onglets");
    
    // Trouver tous les onglets et s'assurer que les selects sont correctement configurés dans chacun
    ['task', 'knowledge', 'skill', 'abilitie'].forEach(tabId => {
      const tabContent = document.getElementById(tabId);
      if (tabContent) {
        console.log(`Configuration des selects dans l'onglet ${tabId}`);
        
        // Pour chaque groupe de selects dans cet onglet
        const selectGroups = tabContent.querySelectorAll('.select-group');
        selectGroups.forEach((group, groupIndex) => {
          const selects = group.querySelectorAll('select');
          
          // S'il y a moins de 3 selects, vérifier pourquoi et recréer si nécessaire
          if (selects.length < 3) {
            console.warn(`Groupe ${groupIndex} dans ${tabId}: seulement ${selects.length} selects trouvés, vérification...`);
          }
          
          // Pour chaque select, s'assurer qu'il a des options
          selects.forEach((select, selectIndex) => {
            // Si le select n'a pas d'options ou seulement l'option vide
            if (select.options.length <= 1) {
              console.warn(`Select ${selectIndex} dans groupe ${groupIndex} de ${tabId} n'a pas d'options, ajout...`);
              
              // Ajouter les options appropriées selon le type d'onglet et la position du select
              if (selectIndex === 0) {  // Premier select (pertinence) - même pour tous les onglets
                addOptionsToSelect(select, [
                  { value: '0', text: '0', title: "Non pertinent" },
                  { value: '1', text: '1', title: "Critique (Must have)" },
                  { value: '2', text: '2', title: "Important (Rapidement acquis)" },
                  { value: '3', text: '3', title: "Secondaire (Complémentaire)" }
                ]);
              } else if (selectIndex === 1) {  // Deuxième select (niveau attendu)
                if (tabId === 'task') {
                  addOptionsToSelect(select, [
                    { value: 'B', text: 'B', title: "Basic" },
                    { value: 'S', text: 'S', title: "Senior" },
                    { value: 'M', text: 'M', title: "Master" }
                  ]);
                } else if (tabId === 'knowledge') {
                  addOptionsToSelect(select, [
                    { value: 'A', text: 'A', title: "Level A" },
                    { value: 'B', text: 'B', title: "Level B" },
                    { value: 'C', text: 'C', title: "Level C" },
                    { value: 'D', text: 'D', title: "Level D" }
                  ]);
                } else {  // skill et abilitie
                  addOptionsToSelect(select, [
                    { value: '1', text: '1', title: "Level 1" },
                    { value: '2', text: '2', title: "Level 2" },
                    { value: '3', text: '3', title: "Level 3" }
                  ]);
                }
              } else if (selectIndex === 2) {  // Troisième select (niveau toléré)
                if (tabId === 'task') {
                  addOptionsToSelect(select, [
                    { value: 'B', text: 'B', title: "Basic" },
                    { value: 'S', text: 'S', title: "Senior" }
                    // M n'est pas inclus car logiquement on ne tolère pas un niveau supérieur à celui attendu
                  ]);
                } else if (tabId === 'knowledge') {
                  addOptionsToSelect(select, [
                    { value: 'A', text: 'A', title: "Level A" },
                    { value: 'B', text: 'B', title: "Level B" },
                    { value: 'C', text: 'C', title: "Level C" }
                    // D n'est pas inclus car logiquement on ne tolère pas un niveau supérieur à celui attendu
                  ]);
                } else {  // skill et abilitie
                  addOptionsToSelect(select, [
                    { value: '1', text: '1', title: "Level 1" },
                    { value: '2', text: '2', title: "Level 2" }
                    // 3 n'est pas inclus car logiquement on ne tolère pas un niveau supérieur à celui attendu
                  ]);
                }
              }
            }
          });
        });
      }
    });
    
    // Trouver le select de contrôle tertiaire
    const tertiaryGlobalSelect = document.getElementById('global-niveau-tolere-select');
    if (tertiaryGlobalSelect) {
      tertiaryGlobalSelect.onchange = function(e) {
        const value = this.value;
        if (value) {
          // D'abord s'assurer que les options existent
          ensureTertiarySelectOptions();
          // Puis forcer la mise à jour
          setTimeout(() => {
            forceUpdateAllTertiarySelects(value);
          }, 100);
          e.stopPropagation();
        }
      };
      console.log("Nouveau gestionnaire d'événements installé pour le contrôle tertiaire");
    }
    
    // Trouver tous les boutons d'onglet
    const tabButtons = document.querySelectorAll('.tab-button');
    tabButtons.forEach(button => {
      // Ajouter un gestionnaire d'événements pour le clic
      const originalClickHandler = button.onclick;
      button.onclick = function(e) {
        // Appeler le gestionnaire d'origine
        if (originalClickHandler) {
          originalClickHandler.call(this, e);
        }
        
        // Attendre que l'onglet soit changé
        setTimeout(() => {
          // Forcer l'apparition des options
          ensureTertiarySelectOptions();
        }, 200);
      };
    });
  }, 1000); // Attendre 1 seconde pour être sûr que tout est chargé
});

// Gère la logique de dépendance pour les contrôles globaux
function handleGlobalPertinenceChange(value) {
    const globalAttenduSelect = document.getElementById('global-niveau-attendu-select');
    const globalTolereSelect = document.getElementById('global-niveau-tolere-select');

    if (!globalAttenduSelect || !globalTolereSelect) return;

    // Règle 1: Si P=0, tout désactiver
    if (value === '0') {
        globalAttenduSelect.disabled = true;
        globalTolereSelect.disabled = true;
        globalAttenduSelect.value = '';
        globalTolereSelect.value = '';
        globalAttenduSelect.classList.add('opacity-50', 'bg-gray-200');
        globalTolereSelect.classList.add('opacity-50', 'bg-gray-200');
        return;
    }

    // Si P > 0, on active toujours A
    globalAttenduSelect.disabled = false;
    globalAttenduSelect.classList.remove('opacity-50', 'bg-gray-200');

    // Règle 2: T n'est activé que si P = 2
    const isTolereEnabled = value === '2';
    globalTolereSelect.disabled = !isTolereEnabled;

    if (isTolereEnabled) {
        globalTolereSelect.classList.remove('opacity-50', 'bg-gray-200');
    } else {
        globalTolereSelect.value = '';
        globalTolereSelect.classList.add('opacity-50', 'bg-gray-200');
    }
}

function updateGlobalTolereOptions(selectedValue) {
    const globalTolereSelect = document.getElementById('global-niveau-tolere-select');
    if (!globalTolereSelect) return;

    const activeTab = document.querySelector('.tab-content:not(.hidden)');
    if (!activeTab) return;
    const tabId = activeTab.id;

    const hierarchies = {
        task: ['B', 'S', 'M'],
        knowledge: ['A', 'B', 'C', 'D'],
        skill: ['1', '2', '3'],
        abilitie: ['1', '2', '3']
    };

    const hierarchy = hierarchies[tabId];
    if (!hierarchy) return;

    const selectedIndex = hierarchy.indexOf(selectedValue);

    if (selectedValue === '' || selectedIndex === -1) {
        Array.from(globalTolereSelect.options).forEach(opt => { opt.disabled = false; });
        return;
    }

    Array.from(globalTolereSelect.options).forEach(opt => {
        if (opt.value === '') {
            opt.disabled = false;
            return;
        }
        const optionIndex = hierarchy.indexOf(opt.value);
        opt.disabled = optionIndex !== -1 && optionIndex > selectedIndex;
    });

    const currentTolereValue = globalTolereSelect.value;
    const currentTolereIndexInHierarchy = hierarchy.indexOf(currentTolereValue);
    if (currentTolereValue !== '' && (currentTolereIndexInHierarchy === -1 || currentTolereIndexInHierarchy > selectedIndex)) {
        globalTolereSelect.value = '';
    }
}

// ...
// Dans le DOMContentLoaded principal, restaurer au tout début :
document.addEventListener("DOMContentLoaded", () => {
  restoreGlobalControlsFromLocalStorage();
  // ...
  // (le reste du code d'initialisation existant)

  // Ajouter l'appel à saveGlobalControlsToLocalStorage sur chaque select global :
  document.getElementById('global-pertinence-select')?.addEventListener('change', saveGlobalControlsToLocalStorage);
  document.getElementById('global-niveau-attendu-select')?.addEventListener('change', saveGlobalControlsToLocalStorage);
  document.getElementById('global-niveau-tolere-select')?.addEventListener('change', saveGlobalControlsToLocalStorage);
});

// --- NOUVELLE FONCTION DE RESTAURATION AU CHARGEMENT ---
function restoreStateOnLoad() {
    serverStorage.getItem('currentOpeningSelection').then(explicitLoadDataJSON => {
        const sessionStateJSON = sessionStorage.getItem('ksatLastSavedState');
        let dataToRestoreJSON = null;

        if (explicitLoadDataJSON) {
            console.log("Chargement d'une sélection explicite...");
            dataToRestoreJSON = explicitLoadDataJSON;
            serverStorage.removeItem('currentOpeningSelection'); // Utiliser une seule fois
            sessionStorage.setItem('ksatLastSavedState', explicitLoadDataJSON); // Devient le nouvel état de session
        } else if (sessionStateJSON) {
            console.log("Restauration de l'état de la session (F5)...");
            dataToRestoreJSON = sessionStateJSON;
        }

        if (dataToRestoreJSON) {
            performRestoration(JSON.parse(dataToRestoreJSON));
        } else {
            console.log("Aucun état à restaurer.");
        }
    }).catch(error => {
        console.error("Erreur lors de la récupération de la sélection à charger:", error);
        const sessionStateJSON = sessionStorage.getItem('ksatLastSavedState');
        if (sessionStateJSON) {
            console.log("Restauration de l'état de session (F5) en fallback...");
            performRestoration(JSON.parse(sessionStateJSON));
        }
    });
}

function performRestoration(data) {
    try {
        console.log("Restauration en cours avec les données:", data);

        // ÉTAPE 1: Restaurer l'onglet actif et les valeurs des selects
        // Activer l'onglet sans déclencher tous les effets de bord de .click()
        if (data.activeTab) {
            const tabButton = document.querySelector(`[data-tab="${data.activeTab}"]`);
            if (tabButton) {
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove("border-blue-500", "text-blue-600"));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.add("hidden"));
                tabButton.classList.add("border-blue-500", "text-blue-600");
                const tabContent = document.getElementById(data.activeTab);
                if (tabContent) tabContent.classList.remove("hidden");
                currentActiveTab = data.activeTab;
                updateGlobalSelectOptions(data.activeTab);
            }
        }
        
        // Restaurer les valeurs des contrôles globaux
        if (data.globalControls) {
            const p = document.getElementById('global-pertinence-select');
            const a = document.getElementById('global-niveau-attendu-select');
            const t = document.getElementById('global-niveau-tolere-select');
            if (p) p.value = data.globalControls.pertinence || '';
            if (a) a.value = data.globalControls.attendu || '';
            if (t) t.value = data.globalControls.tolere || '';
        }

        // Restaurer les valeurs de tous les selects ligne par ligne
        if (data.selectValues) {
            Object.entries(data.selectValues).forEach(([key, value]) => {
                const parts = key.split('_');
                if (parts.length !== 3) return;

                const [tabId, rowIndex, selectIndex] = parts;

                const tab = document.getElementById(tabId);
                if (!tab) return;

                const rows = tab.querySelectorAll('tbody tr');
                if (rows.length <= rowIndex) return;
                const row = rows[rowIndex];

                const selects = row.querySelectorAll('.select-group select');
                if (selects.length <= selectIndex) return;
                
                const select = selects[selectIndex];
                if (select) {
                    select.value = value;
                }
            });
        }

        // ÉTAPE 2: Appliquer l'état visuel (ex: disabled) basé sur les valeurs restaurées
        document.querySelectorAll('.tab-content').forEach(tabContent => {
            const tabId = tabContent.id;
            tabContent.querySelectorAll('tbody tr').forEach(row => {
                updateRowVisualState(row, tabId);
            });
        });
        
        // Appliquer aussi la logique pour les contrôles globaux
        const globalPertinenceSelect = document.getElementById('global-pertinence-select');
        if (globalPertinenceSelect) {
            handleGlobalPertinenceChange(globalPertinenceSelect.value);
        }

        // ÉTAPE 3: Mettre à jour les compteurs
        initializeSelectionCounters();

        // ÉTAPE 4: Attacher les listeners de sauvegarde de session
        document.querySelectorAll('#global-pertinence-select, #global-niveau-attendu-select, #global-niveau-tolere-select').forEach(el => {
            el.addEventListener('change', saveStateToSession);
        });
        document.getElementById('tab-contents').addEventListener('change', (event) => {
            if (event.target.tagName === 'SELECT') {
                saveStateToSession();
            }
        });
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => setTimeout(saveStateToSession, 50));
        });

        console.log("Restauration de l'état terminée.");
    } catch (e) {
        console.error("Erreur lors de la restauration de l'état.", e);
    }
}

function updateRowVisualState(row, tabId) {
    const primarySelect = row.querySelector('.primary-select');
    const secondarySelects = Array.from(row.querySelectorAll('.secondary-select'));
    const select2 = secondarySelects[0];
    const select3 = secondarySelects[1];

    if (!primarySelect || !select2 || !select3) return;

    // Règle 1: Basé sur la Pertinence (P)
    const isP0 = primarySelect.value === '0';
    select2.disabled = isP0;
    
    // Par défaut, T est désactivé et sera activé par la suite si les conditions sont remplies
    select3.disabled = true;

    if (isP0) return; // Si P=0, on s'arrête ici, A et T sont désactivés.

    // Règle 2: T (select3) ne peut être activé que si P (primarySelect) est '2'
    if (primarySelect.value === '2') {
        select3.disabled = false;
    }

    // Règle 3: Désactivation supplémentaire de T (select3) basée sur A (select2), seulement si T n'est pas déjà désactivé.
    if (!select3.disabled) {
        const valueA = select2.value;
        if ((tabId === 'task' && valueA === 'B') ||
            ((tabId === 'skill' || tabId === 'abilitie') && valueA === '1') ||
            (tabId === 'knowledge' && valueA === 'A')) {
            select3.disabled = true;
        }
    }
}

// ...
// Dans DOMContentLoaded, remplacer l'appel à loadSavedSelectionIfNeeded
// par la nouvelle fonction.
document.addEventListener("DOMContentLoaded", function() {
  // ...
  restoreStateOnLoad();
  // ...
});
// ...

// -- LOGIQUE DE PERSISTANCE DES CONTROLES GLOBAUX AU F5 --

function saveGlobalControlsState() {
    const data = {
        pertinence: document.getElementById('global-pertinence-select')?.value || '',
        attendu: document.getElementById('global-niveau-attendu-select')?.value || '',
        tolere: document.getElementById('global-niveau-tolere-select')?.value || ''
    };
    localStorage.setItem('ksatGlobalControlsState', JSON.stringify(data));
}

function restoreGlobalControlsState() {
    try {
        const dataJSON = localStorage.getItem('ksatGlobalControlsState');
        if (!dataJSON) return;
        
        const data = JSON.parse(dataJSON);
        const p = document.getElementById('global-pertinence-select');
        const a = document.getElementById('global-niveau-attendu-select');
        const t = document.getElementById('global-niveau-tolere-select');

        if (p) p.value = data.pertinence || '';
        if (a) a.value = data.attendu || '';
        if (t) t.value = data.tolere || '';

        // Appliquer la logique de dépendance après restauration
        if (p) {
            handleGlobalPertinenceChange(p.value);
        }
        if (a) {
            updateGlobalTolereOptions(a.value);
        }
    } catch (e) {
        console.error("Erreur de restauration des contrôles globaux:", e);
    }
}


// ... (dans DOMContentLoaded)
document.addEventListener('DOMContentLoaded', function() {
    // Restaurer l'état des contrôles globaux en premier
    restoreGlobalControlsState();

    // Lancer la restauration de la sauvegarde principale (si elle existe)
    restoreStateOnLoad();

    // Attacher les listeners pour la sauvegarde automatique des contrôles globaux
    document.getElementById('global-pertinence-select')?.addEventListener('change', saveGlobalControlsState);
    document.getElementById('global-niveau-attendu-select')?.addEventListener('change', saveGlobalControlsState);
    document.getElementById('global-niveau-tolere-select')?.addEventListener('change', saveGlobalControlsState);

    // ... (reste du code)
});
// ... (fin du script)

// --- Logique de persistance de session (F5) ---

function saveStateToSession() {
    if (document.getElementById('loading-overlay')?.classList.contains('hidden') === false) {
        return; // Ne pas sauvegarder pendant le chargement initial
    }
    const state = {
        activeTab: currentActiveTab,
        globalControls: {
            pertinence: document.getElementById('global-pertinence-select')?.value || '',
            attendu: document.getElementById('global-niveau-attendu-select')?.value || '',
            tolere: document.getElementById('global-niveau-tolere-select')?.value || ''
        },
        selectValues: {}
    };

    document.querySelectorAll('.tab-content').forEach(tab => {
        const tabId = tab.id;
        tab.querySelectorAll('tbody tr').forEach((row, rowIndex) => {
            row.querySelectorAll('.select-group select').forEach((select, selectIndex) => {
                const key = `${tabId}_${rowIndex}_${selectIndex}`;
                state.selectValues[key] = select.value;
            });
        });
    });

    sessionStorage.setItem('ksatFullPageState', JSON.stringify(state));
    console.log("État de la page (avec index) sauvegardé pour la session.");
}

// ... (dans performRestoration)
// ÉTAPE 4: Mettre à jour les compteurs et attacher les listeners de sauvegarde de session
initializeSelectionCounters();

// Attacher les listeners après que la restauration soit terminée pour éviter de sauvegarder pendant le processus
document.querySelectorAll('#global-pertinence-select, #global-niveau-attendu-select, #global-niveau-tolere-select').forEach(el => {
    el.addEventListener('change', saveStateToSession);
});
document.getElementById('tab-contents').addEventListener('change', (event) => {
    if (event.target.tagName === 'SELECT') {
        saveStateToSession();
    }
});
document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => setTimeout(saveStateToSession, 50));
});

console.log("Restauration de l'état terminée.");


// ... (dans restoreStateOnLoad)
// Remplacer l'ancienne logique par une qui utilise le nouvel état de session
function restoreStateOnLoad() {
    serverStorage.getItem('currentOpeningSelection').then(explicitLoadDataJSON => {
        let dataToRestoreJSON = null;

        if (explicitLoadDataJSON) {
            console.log("Chargement d'une sélection explicite...");
            dataToRestoreJSON = explicitLoadDataJSON;
            serverStorage.removeItem('currentOpeningSelection'); 
            sessionStorage.setItem('ksatFullPageState', explicitLoadDataJSON); 
        } else {
            dataToRestoreJSON = sessionStorage.getItem('ksatFullPageState');
            if (dataToRestoreJSON) {
                console.log("Restauration de l'état de la session (F5)...");
            }
        }

        if (dataToRestoreJSON) {
            performRestoration(JSON.parse(dataToRestoreJSON));
        } else {
            console.log("Aucun état à restaurer.");
        }
    }).catch(error => {
        console.error("Erreur lors de la récupération de la sélection à charger:", error);
        const sessionStateJSON = sessionStorage.getItem('ksatFullPageState');
        if (sessionStateJSON) {
             console.log("Restauration de l'état de session (F5) en fallback...");
            performRestoration(JSON.parse(sessionStateJSON));
        }
    });
}

</script>
<!-- Les données modales sont maintenant chargées directement dans la variable JavaScript -->

<!-- Style de débogage -->
<style>
.debug-info {
  background-color: #f8f9fa;
  border: 1px solid #ddd;
  padding: 5px;
  margin: 5px 0;
  font-size: 12px;
  color: #333;
}
</style>
{% endblock %}
