{% extends "web_app/template/base.html" %}
{% load work_role_tags %}
{% load ksat_tags %}
{% load select_options_tags %}
{% load modal_info_tags %}

{% block script %}
<style>
  /* Style pour mettre en évidence la première lettre de chaque catégorie KSAT */
  .tab-button::first-letter {
    font-weight: bold;
    color: #3b82f6; /* Couleur bleue (blue-500 en tailwind) */
    font-size: 1.2em;
  }
  
  /* Styles pour grouper visuellement les colonnes du même work_role */
  /* Les couleurs seront définies dynamiquement en fonction des couleurs de la catégorie */
  
  /* Style pour les cellules correspondantes dans le corps du tableau (copier le style pour tous les groups) */
  tr td:nth-child(n+2) {
    border-top: none;
    border-bottom: none;
  }
  
  /* Styles de l'animation de chargement */
  .loading-spinner {
    position: relative;
    width: 80px;
    height: 80px;
  }
  
  .spinner-ring {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 4px solid transparent;
    border-top-color: #3b82f6;
    animation: spin 1.5s linear infinite;
  }
  
  .spinner-ring:nth-child(2) {
    width: 80%;
    height: 80%;
    top: 10%;
    left: 10%;
    border-top-color: transparent;
    border-right-color: #3b82f6;
    animation: spin 2s linear infinite reverse;
  }
  
  .spinner-dot {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 15px;
    height: 15px;
    background-color: #3b82f6;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    animation: pulse 1s ease-in-out infinite alternate;
  }
  
  .progress-bar {
    width: 0%;
    animation: progress 15s linear forwards;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  @keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(0.8); }
    100% { transform: translate(-50%, -50%) scale(1.2); }
  }
  
  @keyframes progress {
    0% { width: 5%; }
    20% { width: 25%; }
    50% { width: 50%; }
    70% { width: 70%; }
    100% { width: 95%; }
  }
  
  /* Styles pour la grille de contrôle global */
  .control-grid {
    min-width: 200px;
    max-width: 250px;
  }
  
  .control-grid button:hover {
    transform: scale(1.05);
  }
  
  .control-grid select:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
  }
  
  /* Animation pour les notifications */
  .notification-enter {
    animation: slideInRight 0.3s ease-out;
  }
  
  .notification-exit {
    animation: slideOutRight 0.3s ease-in;
  }
  
  /* z-index pour les selects globaux pour que les dropdowns s'affichent correctement */
  #global-pertinence-select,
  #global-niveau-attendu-select,
  #global-niveau-tolere-select {
    position: relative;
    z-index: 1000;
  }
  @keyframes slideInRight {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
  
  @keyframes slideOutRight {
    from {
      transform: translateX(0);
      opacity: 1;
    }
    to {
      transform: translateX(100%);
      opacity: 0;
    }
  }

</style>
{% endblock script %}

{% block content %}
<style>
  /* Styles pour les cartes de rôles sélectionnés */
  #step0-selected-roles {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
    color: white !important;
    border-radius: 0.75rem !important;
    padding: 1.5rem !important;
    margin-bottom: 2rem !important;
    margin-top: 1.5rem !important;
    text-align: center !important;
    width: 100% !important;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
  }

  #step0-selected-roles h3 {
    font-size: 1.25rem !important;
    font-weight: 600 !important;
    margin-bottom: 1rem !important;
    color: white !important;
  }

  #selected-roles-container {
    display: flex !important;
    flex-wrap: wrap !important;
    gap: 0.75rem !important;
    justify-content: center !important;
  }

  #step0-selected-roles .selected-role-card {
    background: rgba(255, 255, 255, 0.15) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    border: 2px solid rgba(255, 255, 255, 0.3) !important;
    border-radius: 12px !important;
    padding: 1rem 1.25rem !important;
    transition: all 0.3s ease !important;
    min-width: 280px !important;
    max-width: 320px !important;
    flex: 0 0 auto !important;
  }

  #step0-selected-roles .selected-role-card:hover {
    background: rgba(255, 255, 255, 0.25) !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2) !important;
  }

  #step0-selected-roles .selected-role-card.primary {
    background: linear-gradient(135deg, rgba(255, 193, 7, 0.3) 0%, rgba(255, 152, 0, 0.3) 100%) !important;
    border: 2px solid rgba(255, 193, 7, 0.8) !important;
    box-shadow: 0 0 20px rgba(255, 193, 7, 0.4) !important;
  }

  #step0-selected-roles .selected-role-card.primary::before {
    content: '⭐ Principal' !important;
    display: block !important;
    font-size: 0.75rem !important;
    font-weight: 700 !important;
    color: #ffc107 !important;
    text-transform: uppercase !important;
    margin-bottom: 0.5rem !important;
    letter-spacing: 1px !important;
  }

  #step0-selected-roles .selected-role-card .role-opm {
    font-size: 1.25rem !important;
    font-weight: 800 !important;
    color: #fff !important;
    margin-bottom: 0.5rem !important;
    text-align: left !important;
  }

  #step0-selected-roles .selected-role-card .role-name {
    font-size: 0.95rem !important;
    font-weight: 600 !important;
    color: rgba(255, 255, 255, 0.95) !important;
    line-height: 1.3 !important;
    text-align: left !important;
  }

  #step0-selected-roles .selected-role-card .role-element {
    font-size: 0.75rem !important;
    color: rgba(255, 255, 255, 0.7) !important;
    margin-top: 0.5rem !important;
    font-weight: 500 !important;
    text-align: left !important;
  }
</style>

<!-- Overlay de chargement (visible par défaut) -->
<div id="loading-overlay" class="fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-70">
  <div class="bg-white p-8 rounded-lg shadow-xl text-center max-w-md">
    <div class="flex flex-col items-center">
      <!-- Animation améliorée -->
      <div class="loading-spinner">
        <div class="spinner-ring"></div>
        <div class="spinner-ring"></div>
        <div class="spinner-dot"></div>
      </div>
      <h2 class="text-2xl font-bold mb-2 mt-4">Chargement en cours</h2>
      <p class="text-gray-600">Veuillez patienter, cette opération peut prendre quelques instants...</p>
      <div class="w-full bg-gray-200 h-2 mt-4 rounded-full overflow-hidden">
        <div class="progress-bar h-full bg-blue-500 rounded-full"></div>
      </div>
      <p class="text-sm text-gray-500 mt-4">Traitement d'une grande quantité de données (KSAT)</p>
    </div>
  </div>
</div>

<main class="mx-auto max-w-7xl p-6">
  <!-- Affichage des work roles sélectionnés depuis Step0 -->
  <div id="step0-selected-roles" class="mt-6" style="display: none;">
    <h3 class="text-xl font-semibold mb-3 text-white">Actual selected workroles (Step 2)</h3>
    <div id="selected-roles-container" class="flex flex-wrap gap-3 justify-center"></div>
    <div class="flex justify-between items-center mt-4 relative">
      <a href="http://127.0.0.1:8000/home/" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition">
        ← Step 2
      </a>
      <div class="relative">
        <button id="etape2-button" 
                onclick="checkAndGoToEtape2()"
                class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed"
                disabled>
          Step 3 →
        </button>
        <!-- Tooltip pour expliquer pourquoi le bouton est désactivé -->
        <div id="etape2-tooltip" class="absolute bottom-full right-0 mb-2 hidden bg-gray-800 text-white text-sm rounded-lg px-3 py-2 whitespace-nowrap z-50">
          <div class="flex items-center space-x-2">
            <svg class="w-4 h-4 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
            </svg>
            <span>Sauvegardez d'abord votre sélection</span>
          </div>
          <!-- Flèche du tooltip -->
          <div class="absolute top-full right-4 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-800"></div>
        </div>
      </div>
    </div>
  </div>
    <!-- Onglets -->
  <div class="flex justify-between items-center mb-4">
    <div id="tab-buttons" class="flex border-b">
      {% for key in ksat_dict.keys %}
        <button data-tab="{{ key }}"
                class="tab-button px-4 py-2 text-gray-600 hover:text-blue-600 border-b-2">
          <span style="font-weight: bold; color: #3b82f6; font-size: 1.2em;">{{ key|title|slice:":1" }}</span>{{ key|title|slice:"1:" }}{% if key != 'knowledge' %}s{% endif %}
        </button>
      {% endfor %}
    </div>
    
    <div class="flex items-center space-x-5">
      <button id="compare-button" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
        Comparer
      </button>
      
      <button id="save-selection-button" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition">
        Sauvegarder
      </button>
    </div>
  </div>


  <!-- Contenus -->
  <div id="tab-contents">
    {% for key, ksats in ksat_dict.items %}
      <div id="{{ key }}" class="tab-content hidden">
        <!-- Legend for C, A, and * symbols -->
        <div class="mb-4 p-3 bg-gray-50 border border-gray-200 rounded-lg">
          <div class="text-sm text-gray-700 space-y-1">
            <div class="flex items-center gap-2">
              <span class="px-2 py-0.5 text-xs rounded bg-blue-100 text-blue-800 font-semibold">C</span>
              <span>= KSAT or KSA Core</span>
            </div>
            <div class="flex items-center gap-2">
              <span class="px-2 py-0.5 text-xs rounded bg-green-100 text-green-800 font-semibold">A</span>
              <span>= KSAT or KSA Additional</span>
            </div>
            <div class="flex items-center gap-2">
              <span class="text-red-600 font-bold text-lg">*</span>
              <span>= KSAT DCWF 25 Common to all DCWF 25 work roles</span>
            </div>
          </div>
        </div>
        <table class="min-w-full table-fixed border-collapse mb-6" style="table-layout: fixed;">
          <thead>

            
            <!-- Ligne principale du tableau -->
            <tr class="bg-gray-100 sticky top-16 z-50">
              <th class="px-3 py-2 border text-left bg-white" style="width: 300px;">
                <div class="flex items-center space-x-2">
                  <input type="checkbox" 
                         id="check-all-{{ key }}" 
                         class="check-all-ksat w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" 
                         data-category="{{ key }}"
                         checked
                         onchange="toggleAllKSATs('{{ key }}', this.checked)">
                  <label for="check-all-{{ key }}" class="font-medium cursor-pointer">
                    (UN)SELECT ALL {{ key|title|slice:":1" }}{{ key|title|slice:"1:" }}{% if key != 'knowledge' %}s{% endif %}
                  </label>
                </div>
              </th>
              {% for role in formatted_roles %}
                <th class="px-3 py-3 border {% if role.group_id %}{{ role.group_id }} work-role-group{% endif %}" 
                    data-framework="{{ role.framework }}" 
                    data-role-id="{{ role.id }}"
                    data-opm-id="{{ role.opm_id|default:'' }}"
                    data-model-type="{{ role.model_type }}"
                    data-group-id="{{ role.group_id }}"
                    data-category-color="{{ role.category_color }}"
                    style="width: 140px; text-align: left; vertical-align: top;">
                  
                  <!-- Structure avec hauteurs fixes pour alignement -->
                  <div class="flex flex-col" style="height: 100%; min-height: 280px;">
                    <!-- Informations du work role - Section principale avec hauteurs fixes -->
                    <div class="flex-shrink-0 mb-4">
                      <!-- OPM ID - Mis en valeur avec hauteur fixe -->
                      <div class="text-center mb-2" style="height: 48px; display: flex; align-items: center; justify-content: center;">
                        {% if role.opm_id %}
                          <div class="text-3xl font-bold text-gray-900 leading-none" style="font-weight: 700; letter-spacing: -0.5px;">
                            {{ role.opm_id }}
                          </div>
                        {% else %}
                          <div class="text-3xl font-bold text-gray-400 leading-none">&nbsp;</div>
                        {% endif %}
                      </div>
                      
                      <!-- Titre du work role avec hauteur fixe -->
                      <div class="text-center mb-2" style="height: 56px; display: flex; align-items: center; justify-content: center;">
                        <div class="text-sm font-semibold text-gray-800 leading-tight" style="line-height: 1.3;">
                          {{ role.title }}
                        </div>
                      </div>
                      
                      <!-- Framework et code NCWF avec hauteur fixe -->
                      <div class="text-center" style="height: 40px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                        <span class="text-xs text-gray-500 font-medium">{{ role.framework }}</span>
                        {% if role.model_type == 'ncwf_2017' or role.model_type == 'ncwf_2024' or role.model_type == 'ncwf_2025' %}
                          {% if role.nist_id %}
                            <div class="mt-1">
                              <span class="text-xs text-blue-600 font-medium">{{ role.nist_id }}</span>
                            </div>
                          {% else %}
                            <div style="height: 16px;"></div>
                          {% endif %}
                        {% else %}
                          <div style="height: 16px;"></div>
                        {% endif %}
                      </div>
                    </div>

                    <!-- Compteurs T/K/S/A - Deux cases séparées, alignés en bas avec hauteur fixe -->
                    <div class="mt-auto" style="margin-top: auto; padding-top: 8px;">
                      <div class="space-y-2">
                      {% if key == 'task' %}
                        <!-- Case Existing -->
                        <div class="bg-gray-50 border border-gray-200 rounded-md px-2 py-1.5">
                          <div class="flex items-center justify-between">
                            <span class="text-xs font-medium text-gray-600">T Existing</span>
                            <span id="task-count-{{ key }}-{{ role.id }}" class="text-sm font-bold text-gray-900 tabular-nums">0</span>
                          </div>
                        </div>
                        <!-- Case Existing Selected -->
                        <div class="bg-blue-50 border border-blue-200 rounded-md px-2 py-1.5">
                          <div class="flex items-center justify-between">
                            <span class="text-xs font-medium text-blue-700">T Selected</span>
                            <span id="task-selected-count-{{ key }}-{{ role.id }}" class="text-sm font-bold text-blue-600 tabular-nums">0</span>
                          </div>
                        </div>
                      {% elif key == 'knowledge' %}
                        <!-- Case Existing -->
                        <div class="bg-gray-50 border border-gray-200 rounded-md px-2 py-1.5">
                          <div class="flex items-center justify-between">
                            <span class="text-xs font-medium text-gray-600">K Existing</span>
                            <span id="knowledge-count-{{ key }}-{{ role.id }}" class="text-sm font-bold text-gray-900 tabular-nums">0</span>
                          </div>
                        </div>
                        <!-- Case Existing Selected -->
                        <div class="bg-blue-50 border border-blue-200 rounded-md px-2 py-1.5">
                          <div class="flex items-center justify-between">
                            <span class="text-xs font-medium text-blue-700">K Selected</span>
                            <span id="knowledge-selected-count-{{ key }}-{{ role.id }}" class="text-sm font-bold text-blue-600 tabular-nums">0</span>
                          </div>
                        </div>
                      {% elif key == 'skill' %}
                        <!-- Case Existing -->
                        <div class="bg-gray-50 border border-gray-200 rounded-md px-2 py-1.5">
                          <div class="flex items-center justify-between">
                            <span class="text-xs font-medium text-gray-600">S Existing</span>
                            <span id="skill-count-{{ key }}-{{ role.id }}" class="text-sm font-bold text-gray-900 tabular-nums">0</span>
                          </div>
                        </div>
                        <!-- Case Existing Selected -->
                        <div class="bg-blue-50 border border-blue-200 rounded-md px-2 py-1.5">
                          <div class="flex items-center justify-between">
                            <span class="text-xs font-medium text-blue-700">S Selected</span>
                            <span id="skill-selected-count-{{ key }}-{{ role.id }}" class="text-sm font-bold text-blue-600 tabular-nums">0</span>
                          </div>
                        </div>
                      {% elif key == 'abilitie' %}
                        <!-- Case Existing -->
                        <div class="bg-gray-50 border border-gray-200 rounded-md px-2 py-1.5">
                          <div class="flex items-center justify-between">
                            <span class="text-xs font-medium text-gray-600">A Existing</span>
                            <span id="ability-count-{{ key }}-{{ role.id }}" class="text-sm font-bold text-gray-900 tabular-nums">0</span>
                          </div>
                        </div>
                        <!-- Case Existing Selected -->
                        <div class="bg-blue-50 border border-blue-200 rounded-md px-2 py-1.5">
                          <div class="flex items-center justify-between">
                            <span class="text-xs font-medium text-blue-700">A Selected</span>
                            <span id="ability-selected-count-{{ key }}-{{ role.id }}" class="text-sm font-bold text-blue-600 tabular-nums">0</span>
                          </div>
                        </div>
                      {% endif %}
                      </div>
                    </div>
                  </div>
                </th>
              {% endfor %}
            </tr>
          </thead>
          <tbody>
            {% for ksat in ksats %}
              <tr class="hover:bg-gray-50">
                <td class="px-3 py-2 border align-top" style="width: 300px;">
                  <div class="flex items-start space-x-2">
                    <input type="checkbox" 
                           class="ksat-checkbox w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 mt-1" 
                           data-ksat-id="{% if ksat.dcwf_id %}{{ ksat.dcwf_id }}{% elif ksat.ncwf_id %}{{ ksat.ncwf_id }}{% else %}{{ ksat.id }}{% endif %}"
                           data-category="{{ key }}"
                           data-ksat-description="{{ ksat.description|escape }}"
                           checked
                           onchange="handleKSATCheckboxChange(this, '{{ key }}')">
                    <div class="flex-1">
                      <p class="font-medium">{{ ksat.description }}</p>
                      <div class="mt-1 text-sm text-gray-600 space-x-2">
                          {% dcwf_url ksat %}
                          {% ncwf_2017_url ksat %}
                          {% ncwf_2025_url ksat %}
                          <div class="mt-2 text-xs text-gray-500">
                            ID: {% if ksat.dcwf_id %}{{ ksat.dcwf_id }}{% elif ksat.ncwf_id %}{{ ksat.ncwf_id }}{% else %}{{ ksat.id }}{% endif %}
                            {% if ksat.core_or_additional %}
                              <span class="ml-2 px-1 py-0.5 text-xs rounded {% if ksat.core_or_additional == 'C' %}bg-blue-100 text-blue-800{% else %}bg-green-100 text-green-800{% endif %}">
                                {{ ksat.core_or_additional }}
                              </span>
                            {% endif %}
                          </div>
                      </div>
                      <!-- Indicateur Skills Alignment dans le td align-top -->
                      <div class="mt-2">
                        <span class="skills-alignment-indicator-top" 
                              data-ksat-id="{% if ksat.dcwf_id %}{{ ksat.dcwf_id }}{% elif ksat.ncwf_id %}{{ ksat.ncwf_id }}{% else %}{{ ksat.id }}{% endif %}"
                              data-category="{{ key }}"
                              style="display: none; cursor: pointer; color: #f59e0b; font-size: 12px; font-weight: bold;"
                              onclick="event.stopPropagation(); showTaskAlignment(this)"
                              title="Click to see linked tasks">
                          <span style="font-size: 14px;">⚠️</span> <span>Linked to tasks</span>
                        </span>
                        <span class="task-skills-alignment-indicator-top" 
                              data-ksat-id="{% if ksat.dcwf_id %}{{ ksat.dcwf_id }}{% elif ksat.ncwf_id %}{{ ksat.ncwf_id }}{% else %}{{ ksat.id }}{% endif %}"
                              data-category="{{ key }}"
                              style="display: none; cursor: pointer; color: #3b82f6; font-size: 12px; font-weight: bold;"
                              onclick="event.stopPropagation(); showTaskSkillsAlignment(this)"
                              title="Click to see linked Knowledge and Skills">
                          <span style="font-size: 14px;">ℹ️</span> <span>Contains K/S</span>
                        </span>
                      </div>
                    </div>
                  </div>
                </td>
                {% for role in formatted_roles %}
                  <td class="px-3 py-2 border text-center align-middle" style="width: 126px; position: relative;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                      {% if role.model_obj|has_ksat:ksat %}✅{% else %}❌{% endif %}
                    </div>
                  </td>
                {% endfor %}
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    {% endfor %}
  </div>
</main>

<script>
// Variables qui seront initialisées au chargement pour éviter le hardcoding
let allSelectValues = {
    task: {},
    knowledge: {},
    skill: {},
    abilitie: {}
};

// Stockage des compteurs de sélection pour chaque onglet
let selectionCounters = {
  'task': { selected: 0, total: 0 },
  'knowledge': { selected: 0, total: 0 },
  'skill': { selected: 0, total: 0 },
  'abilitie': { selected: 0, total: 0 }
};

// Compteur global pour toutes les catégories
let globalCounter = { selected: 0, total: 0 };

// Onglet actif actuel
let currentActiveTab = '';

// Fonction pour gérer la dépendance entre le deuxième et le troisième select pour Task
function handleSecondarySelectChange(select) {
  const selectedValue = select.value;
  const selectGroup = select.closest('.select-group');
  const thirdSelect = selectGroup.querySelectorAll('.secondary-select')[1];
  const primarySelect = selectGroup.querySelector('.primary-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = select.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Vérifier si nous sommes dans un onglet Task
  const isTaskTab = selectGroup.closest('#task') !== null;
  
  // Ne pas modifier le troisième select si c'est un événement déclenché par le contrôle global
  // Cette vérification permet d'éviter les interférences entre les contrôles A et T
  const isGlobalEvent = select.hasAttribute('data-global-change');
  if (isGlobalEvent) {
    return;
  }
  
  // Réinitialiser le troisième select
  thirdSelect.innerHTML = '';
  
  // Fonction pour cloner une option
  function cloneOption(sourceOption) {
    const option = document.createElement('option');
    option.value = sourceOption.value;
    option.text = sourceOption.text || sourceOption.value;
    option.title = sourceOption.title || '';
    return option;
  }
  
  // Fonction pour trouver l'option avec une valeur spécifique
  function findOptionByValue(selectElement, value) {
    return Array.from(selectElement.options).find(opt => opt.value === value);
  }
  
  // Pour Task: Si le premier select n'est pas 2, désactiver le troisième select indépendamment de la valeur du second select
  if (isTaskTab && primarySelect && primarySelect.value !== '2') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50');
    return;
  }
  
  // Traitement spécifique pour l'onglet Task
  if (isTaskTab) {
    // Trouver tous les selects dans Task pour récupérer les options
    const allSelects = document.querySelectorAll('#task select');
    let thirdSelectSource = null;
    
    // Trouver le select source qui contient les options originales pour le troisième select
    allSelects.forEach(selectEl => {
      if (selectEl !== thirdSelect && 
          selectEl.parentElement.closest('.select-container') && 
          selectEl.parentElement.nextElementSibling && 
          selectEl.parentElement.nextElementSibling.nextElementSibling) {
        thirdSelectSource = selectEl.parentElement.nextElementSibling.nextElementSibling.querySelector('select');
      }
    });
    
    // Utiliser le select que l'on vient de réinitialiser comme source de secours
    if (!thirdSelectSource) {
      thirdSelectSource = thirdSelect;
    }
    
    // Pour Task: Quand le select n2 est sur B, désactiver le select n3
    if (selectedValue === 'B') {
      thirdSelect.disabled = true;
      thirdSelect.classList.add('opacity-50');
      return;
    }
    
    // Pour Task: Quand le select n2 est sur S, activer select n3 avec option B uniquement
    if (selectedValue === 'S') {
      thirdSelect.disabled = false;
      thirdSelect.classList.remove('opacity-50');
      
      // Chercher l'option B mais n'en ajouter qu'une seule
      let optionBAdded = false;
      for (const selectEl of allSelects) {
        if (optionBAdded) break;
        
        for (const opt of selectEl.options) {
          if (opt.value === 'B' && !optionBAdded) {
            thirdSelect.appendChild(cloneOption(opt));
            optionBAdded = true;
            break;
          }
        }
      }
      return;
    }
    
    // Pour Task: Quand le select n2 est sur M, activer select n3 avec options B et S
    if (selectedValue === 'M') {
      thirdSelect.disabled = false;
      thirdSelect.classList.remove('opacity-50');
      
      // Chercher et ajouter l'option B (une seule fois)
      let optionBAdded = false;
      let optionSAdded = false;
      
      // Parcourir tous les selects pour trouver les options B et S
      for (const selectEl of allSelects) {
        // Si on a déjà trouvé les deux options, on peut arrêter la recherche
        if (optionBAdded && optionSAdded) break;
        
        for (const opt of selectEl.options) {
          // Ajouter l'option B si elle n'a pas encore été ajoutée
          if (opt.value === 'B' && !optionBAdded) {
            thirdSelect.appendChild(cloneOption(opt));
            optionBAdded = true;
          }
          // Ajouter l'option S si elle n'a pas encore été ajoutée
          else if (opt.value === 'S' && !optionSAdded) {
            thirdSelect.appendChild(cloneOption(opt));
            optionSAdded = true;
          }
          
          // Si on a trouvé les deux options, on peut sortir de la boucle
          if (optionBAdded && optionSAdded) break;
        }
      }
      return;
    }
  } 
  
  // Si ce n'est pas un onglet Task ou si la valeur du select n2 n'est pas reconnue, garder le comportement d'origine
  if (selectedValue === '1') { // Option B (Basic)
    // Désactiver le troisième select
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50');
  } else {
    // Réactiver le troisième select
    thirdSelect.disabled = false;
    thirdSelect.classList.remove('opacity-50');
    
    // Pour les autres onglets (non-Task), chercher les options existantes
    const otherSelects = document.querySelectorAll('select');
    
    // Ajouter l'option correspondant à la valeur 1 (B)
    otherSelects.forEach(selectEl => {
      selectEl.querySelectorAll('option').forEach(opt => {
        if (opt.value === '1') {
          thirdSelect.appendChild(cloneOption(opt));
        }
      });
    });
    
    // Si option value 3 (M - Master) est sélectionnée, ajouter également l'option value 2 (S - Senior)
    if (selectedValue === '3') {
      otherSelects.forEach(selectEl => {
        selectEl.querySelectorAll('option').forEach(opt => {
          if (opt.value === '2' && !findOptionByValue(thirdSelect, '2')) {
            thirdSelect.appendChild(cloneOption(opt));
          }
        });
      });
    }
  }
}
// Fonction pour gérer la dépendance entre le premier et les autres selects pour Knowledge
function handleKnowledgeSelectChange(select) {
  const selectedValue = select.value;
  const container = select.closest('.select-group');
  const secondSelect = container.querySelector('#knowledge-second-select');
  const thirdSelect = container.querySelector('#knowledge-third-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = select.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  if (selectedValue === '0') {
    // Désactiver les deux selects secondaires
    secondSelect.disabled = true;
    thirdSelect.disabled = true;
    secondSelect.classList.add('opacity-50');
    thirdSelect.classList.add('opacity-50');
  } else {
    // Activer le second select
    secondSelect.disabled = false;
    secondSelect.classList.remove('opacity-50');
    
    // Si le premier select n'est pas égal à 2, désactiver le troisième select
    if (selectedValue !== '2') {
      thirdSelect.disabled = true;
      thirdSelect.classList.add('opacity-50');
      thirdSelect.innerHTML = ''; // Vider le troisième select
    } else {
      // Activer le troisième select seulement si le premier select est 2
      thirdSelect.disabled = false;
      thirdSelect.classList.remove('opacity-50');
      // Gérer l'état du troisième select seulement si le premier select est 2
      handleKnowledgeSecondarySelectChange(secondSelect);
    }
  }
}

// Fonction pour gérer la dépendance entre le deuxième et troisième select pour Knowledge
function handleKnowledgeSecondarySelectChange(select) {
  const selectedValue = select.value;
  const selectGroup = select.closest('.select-group');
  const secondarySelects = Array.from(selectGroup.querySelectorAll('.secondary-select'));
  const thirdSelect = secondarySelects[1]; // Le troisième select est le deuxième des secondary-select
  const primarySelect = selectGroup.querySelector('.primary-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = select.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Ne pas modifier le troisième select si c'est un événement déclenché par le contrôle global
  // Cette vérification permet d'éviter les interférences entre les contrôles A et T
  const isGlobalEvent = select.hasAttribute('data-global-change');
  if (isGlobalEvent) {
    return;
  }
  
  // Réinitialiser le troisième select
  thirdSelect.innerHTML = '';
  
  // Pour Knowledge: Vérifier si nous sommes dans l'onglet Knowledge
  const isKnowledgeTab = selectGroup.closest('#knowledge') !== null;
  
  // Si nous ne sommes pas dans l'onglet Knowledge, laisser les autres fonctions gérer le comportement
  if (!isKnowledgeTab) return;
  
  // Pour Knowledge: Vérifier si le premier select a la valeur "2"
  if (primarySelect && primarySelect.value !== '2') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50');
    return;
  }
  
  // Règles spécifiques pour Knowledge
  
  // Si select n2 a la valeur A, désactiver le select n3
  if (selectedValue === 'A') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50');
    return;
  }
  
  // Activer le select n3 pour les autres cas
  thirdSelect.disabled = false;
  thirdSelect.classList.remove('opacity-50');
  
  // Trouver toutes les options existantes pour Knowledge dans le DOM
  // pour éviter le hardcoding
  const allSelects = document.querySelectorAll('select');
  let knowledgeOptions = [];
  
  // Collecter toutes les options des selects de Type de maîtrise 2 dans Knowledge
  allSelects.forEach(selectEl => {
    if (selectEl.closest('#knowledge') && 
        Array.from(selectEl.classList).includes('secondary-select')) {
      Array.from(selectEl.options).forEach(opt => {
        if (!knowledgeOptions.some(ko => ko.value === opt.value && ko.text === opt.text)) {
          knowledgeOptions.push({
            value: opt.value,
            text: opt.text,
            title: opt.title
          });
        }
      });
    }
  });
  
  // Filtrer et ajouter les options appropriées selon la valeur du select n2
  const optionA = knowledgeOptions.find(opt => opt.text === 'A') || {
    value: '1',
    text: 'A',
    title: "Level A: Can identify basic facts and terms about the subject."
  };
  
  const optionB = knowledgeOptions.find(opt => opt.text === 'B') || {
    value: '2',
    text: 'B',
    title: "Level B: Can identify relationships of basic facts and state general principles about the subject."
  };
  
  const optionC = knowledgeOptions.find(opt => opt.text === 'C') || {
    value: '3',
    text: 'C',
    title: "Level C: Can analyze facts and principals and draw conclusions about the subject."
  };
  
  // Ajouter l'option A pour tous les cas (B, C, D)
  const newOptA = document.createElement('option');
  newOptA.value = optionA.value;
  newOptA.text = optionA.text;
  newOptA.title = optionA.title;
  thirdSelect.appendChild(newOptA);
  
  // Ajouter l'option B pour les cas C et D
  if (selectedValue === 'C' || selectedValue === 'D') {
    const newOptB = document.createElement('option');
    newOptB.value = optionB.value;
    newOptB.text = optionB.text;
    newOptB.title = optionB.title;
    thirdSelect.appendChild(newOptB);
  }
  
  // Ajouter l'option C uniquement pour le cas D
  if (selectedValue === 'D') {
    const newOptC = document.createElement('option');
    newOptC.value = optionC.value;
    newOptC.text = optionC.text;
    newOptC.title = optionC.title;
    thirdSelect.appendChild(newOptC);
  }
}

// Déclaration des variables globales pour les données modales
let modalInfoData = null;
let modalDataLoaded = false;

// Fonction pour charger les données modales via une requête AJAX
function initModalData() {
  return new Promise((resolve, reject) => {
    console.log('Chargement des données modales via AJAX...');
    
    // Créer une requête XMLHttpRequest
    const xhr = new XMLHttpRequest();
    xhr.open('GET', '/api/modal-info/', true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.setRequestHeader('Accept', 'application/json');
    
    // Gérer la réponse
    xhr.onload = function() {
      if (xhr.status === 200) {
        try {
          modalInfoData = JSON.parse(xhr.responseText);
          modalDataLoaded = true;
          console.log('Données modales chargées avec succès via AJAX');
          resolve(true);
        } catch(e) {
          console.error('Erreur lors du parsing des données modales:', e);
          modalDataLoaded = false;
          reject(e);
        }
      } else {
        console.error('Erreur lors du chargement des données modales:', xhr.status);
        modalDataLoaded = false;
        reject(new Error('Erreur HTTP: ' + xhr.status));
      }
    };
    
    // Gérer les erreurs
    xhr.onerror = function() {
      console.error('Erreur réseau lors du chargement des données modales');
      modalDataLoaded = false;
      reject(new Error('Erreur réseau'));
    };
    
    // Envoyer la requête
    xhr.send();
  });
}

// Fonction pour afficher la fenêtre modale avec les informations des niveaux pour la catégorie active
function showLevelInfoModal(infoType) {
  console.log('Affichage du modal des niveaux pour:', infoType);
  
  // Détecter la catégorie KSAT active
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) {
    console.error('Aucun onglet actif trouvé');
    return;
  }
  
  const activeTabId = activeTab.id;
  console.log('Onglet actif:', activeTabId);
  
  // Mapping des onglets vers les noms de catégories
  // Note: le nom doit correspondre exactement au nom dans la base de données
  const categoryMapping = {
    'task': { name: 'Task', displayName: 'Tasks (Tâches)', color: 'blue', letter: 'T' },
    'knowledge': { name: 'Knowledge', displayName: 'Knowledge (Connaissances)', color: 'green', letter: 'K' },
    'skill': { name: 'Skill', displayName: 'Skills (Compétences)', color: 'orange', letter: 'S' },
    'abilitie': { name: 'Ability', displayName: 'Abilities (Aptitudes)', color: 'purple', letter: 'A' }
  };
  
  const currentCategory = categoryMapping[activeTabId];
  if (!currentCategory) {
    console.error('Catégorie non reconnue pour l\'onglet:', activeTabId);
    return;
  }
  
  // Créer le modal
  const modal = document.createElement('div');
  modal.id = 'level-info-modal';
  modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4';
  
  const modalContent = document.createElement('div');
  modalContent.className = 'bg-white rounded-lg shadow-xl max-w-3xl w-full max-h-[90vh] overflow-auto';
  
  // Définir les titres et descriptions selon le type d'information
  let modalTitle = '';
  let modalDescription = '';
  
  switch(infoType) {
    case 'pertinence':
      modalTitle = `Pertinence (P) - ${currentCategory.displayName}`;
      modalDescription = `Indique l'importance de ces ${currentCategory.displayName.toLowerCase()} pour le poste`;
      break;
    case 'niveau-attendu':
      modalTitle = `Niveau Attendu (A) - ${currentCategory.displayName}`;
      modalDescription = `Le niveau de compétence requis pour ces ${currentCategory.displayName.toLowerCase()} dans des conditions normales`;
      break;
    case 'niveau-tolere':
      modalTitle = `Niveau Toléré (T) - ${currentCategory.displayName}`;
      modalDescription = `Le niveau minimum acceptable pour ces ${currentCategory.displayName.toLowerCase()} lors du recrutement`;
      break;
  }
  
  // En-tête
  const header = document.createElement('div');
  header.className = 'border-b px-6 py-4 flex justify-between items-center sticky top-0 bg-white rounded-t-lg';
  header.innerHTML = `
    <div>
      <h3 class="font-bold text-xl text-gray-800">${modalTitle}</h3>
      <p class="text-sm text-gray-600 mt-1">${modalDescription}</p>
    </div>
    <button type="button" id="close-level-modal" class="text-gray-500 hover:text-gray-700 text-2xl font-bold">&times;</button>
  `;
  
  // Corps du modal
  const body = document.createElement('div');
  body.className = 'p-6';
  
  // Créer le tableau avec les informations des niveaux pour la catégorie active
  const tableHTML = `
    <div class="overflow-x-auto">
      <table class="w-full border-collapse border border-gray-300">
        <thead>
          <tr class="bg-gray-100">
            <th class="border border-gray-300 px-4 py-3 text-left font-semibold">Catégorie KSAT</th>
            <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Niveau 0</th>
            <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Niveau 1</th>
            <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Niveau 2</th>
            <th class="border border-gray-300 px-4 py-3 text-center font-semibold">Niveau 3</th>
          </tr>
        </thead>
        <tbody>
          <tr class="hover:bg-gray-50">
            <td class="border border-gray-300 px-4 py-3 font-medium ${currentCategory.color === 'blue' ? 'bg-blue-50' : currentCategory.color === 'green' ? 'bg-green-50' : currentCategory.color === 'orange' ? 'bg-orange-50' : 'bg-purple-50'}">
              <span class="${currentCategory.color === 'blue' ? 'text-blue-600' : currentCategory.color === 'green' ? 'text-green-600' : currentCategory.color === 'orange' ? 'text-orange-600' : 'text-purple-600'} font-bold">${currentCategory.letter}</span>${currentCategory.displayName.substring(1)}
            </td>
            <td class="border border-gray-300 px-4 py-3 text-center text-gray-500 italic">
              ${currentCategory.letter} non pertinant pour le poste
            </td>
            <td class="border border-gray-300 px-4 py-3 text-center" id="${activeTabId}-level-1">
              Chargement...
            </td>
            <td class="border border-gray-300 px-4 py-3 text-center" id="${activeTabId}-level-2">
              Chargement...
            </td>
            <td class="border border-gray-300 px-4 py-3 text-center" id="${activeTabId}-level-3">
              Chargement...
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <div class="mt-6 p-4 ${currentCategory.color === 'blue' ? 'bg-blue-50' : currentCategory.color === 'green' ? 'bg-green-50' : currentCategory.color === 'orange' ? 'bg-orange-50' : 'bg-purple-50'} rounded-lg">
      <h4 class="font-semibold ${currentCategory.color === 'blue' ? 'text-blue-800' : currentCategory.color === 'green' ? 'text-green-800' : currentCategory.color === 'orange' ? 'text-orange-800' : 'text-purple-800'} mb-2">Information importante :</h4>
      <p class="text-sm ${currentCategory.color === 'blue' ? 'text-blue-700' : currentCategory.color === 'green' ? 'text-green-700' : currentCategory.color === 'orange' ? 'text-orange-700' : 'text-purple-700'}">
        ${infoType === 'pertinence' ? `Les niveaux de pertinence indiquent l'importance relative de ces ${currentCategory.displayName.toLowerCase()} pour le poste.` : 
          infoType === 'niveau-attendu' ? `Les niveaux attendus représentent le niveau de maîtrise requis pour ces ${currentCategory.displayName.toLowerCase()} dans des conditions normales de travail.` :
          `Les niveaux tolérés représentent le niveau minimum acceptable pour ces ${currentCategory.displayName.toLowerCase()} lors du recrutement, permettant une montée en compétence progressive.`}
      </p>
    </div>
  `;
  
  body.innerHTML = tableHTML;
  
  // Assembler le modal
  modalContent.appendChild(header);
  modalContent.appendChild(body);
  modal.appendChild(modalContent);
  
  // Ajouter au DOM
  document.body.appendChild(modal);
  
  // Charger les données des select options
  loadSelectOptionsData(infoType, activeTabId, currentCategory);
  
  // Gestionnaire de fermeture
  const closeButton = document.getElementById('close-level-modal');
  closeButton.addEventListener('click', () => {
    document.body.removeChild(modal);
  });
  
  // Fermeture en cliquant sur l'overlay
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  });
  
  // Fermeture avec la touche Escape
  const handleEscape = (e) => {
    if (e.key === 'Escape') {
      document.body.removeChild(modal);
      document.removeEventListener('keydown', handleEscape);
    }
  };
  document.addEventListener('keydown', handleEscape);
}

// Fonction pour charger les données des select options
function loadSelectOptionsData(infoType, activeTabId, currentCategory) {
  // Afficher un message de chargement dans les cellules
  for (let level = 1; level <= 3; level++) {
    const cellId = `${activeTabId}-level-${level}`;
    const cell = document.getElementById(cellId);
    if (cell) {
      cell.innerHTML = `
        <div class="flex items-center justify-center">
          <div class="animate-pulse flex space-x-1">
            <div class="h-2 w-2 bg-blue-400 rounded-full"></div>
            <div class="h-2 w-2 bg-blue-400 rounded-full"></div>
            <div class="h-2 w-2 bg-blue-400 rounded-full"></div>
          </div>
        </div>
      `;
    }
  }

  console.log(`Chargement des données pour ${currentCategory.name}...`);
  
  // Créer la requête AJAX pour récupérer les données des select options
  const xhr = new XMLHttpRequest();
  xhr.open('GET', '/api/select-options/', true);
  xhr.setRequestHeader('Content-Type', 'application/json');
  xhr.setRequestHeader('Accept', 'application/json');
  
  xhr.onload = function() {
    console.log(`Réponse reçue (statut ${xhr.status})`);
    
    if (xhr.status === 200) {
      try {
        console.log('Contenu de la réponse:', xhr.responseText.substring(0, 200) + '...');
        const data = JSON.parse(xhr.responseText);
        populateModalTable(data, infoType, activeTabId, currentCategory);
      } catch(e) {
        console.error('Erreur lors du parsing des données des select options:', e);
        showLoadingError(activeTabId);
      }
    } else {
      console.error('Erreur lors du chargement des données des select options:', xhr.status);
      showLoadingError(activeTabId);
    }
  };
  
  xhr.onerror = function() {
    console.error('Erreur réseau lors du chargement des données des select options');
    showLoadingError(activeTabId);
  };
  
  xhr.send();
}

// Fonction pour populer le tableau du modal avec les données
function populateModalTable(data, infoType, activeTabId, currentCategory) {
  // Déterminer la catégorie de select selon le type d'information et la catégorie KSAT active
  let selectCategory = '';
  switch(infoType) {
    case 'pertinence':
      selectCategory = 'Importance';
      break;
    case 'niveau-attendu':
      // Pour Skills et Abilities, utiliser Type de maîtrise 2 car Type de maîtrise 1 n'existe pas
      if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
        selectCategory = 'Type de maîtrise 2';
      } else {
        selectCategory = 'Type de maîtrise 1';
      }
      break;
    case 'niveau-tolere':
      // Pour Task, utiliser Type de maîtrise 2 ou Type de maîtrise 3 selon disponibilité
      if (currentCategory.name === 'Task') {
        selectCategory = 'Type de maîtrise 2';
      } else if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
        selectCategory = 'Type de maîtrise 3';
      } else {
        selectCategory = 'Type de maîtrise 2';
      }
      break;
  }
  
  // Debug pour voir les données reçues
  console.log("Données reçues:", data);
  console.log("Catégorie courante:", currentCategory);
  console.log("Catégorie de select:", selectCategory);
  
  // Récupérer les options pour la catégorie active et ce type de select
  if (!data || Object.keys(data).length === 0) {
    console.error("Aucune donnée n'a été reçue");
    showLoadingError(activeTabId);
    return;
  }
  
  // Vérifier si le type KSAT existe dans les données
  if (!data[currentCategory.name]) {
    console.error(`Le type KSAT '${currentCategory.name}' n'existe pas dans les données`);
    console.log("Types KSAT disponibles:", Object.keys(data));
    showLoadingError(activeTabId);
    return;
  }
  
  const categoryData = data[currentCategory.name];
  
  // Vérifier si la catégorie de select existe pour ce type KSAT
  if (!categoryData[selectCategory]) {
    console.warn(`La catégorie de select '${selectCategory}' n'existe pas pour le type KSAT '${currentCategory.name}'`);
    console.log("Catégories disponibles:", Object.keys(categoryData));
    
    // Essayer une catégorie alternative
    let alternativeCategory = '';
    if (selectCategory === 'Type de maîtrise 1' && categoryData['Type de maîtrise 2']) {
      alternativeCategory = 'Type de maîtrise 2';
    } else if (selectCategory === 'Type de maîtrise 2' && categoryData['Type de maîtrise 1']) {
      alternativeCategory = 'Type de maîtrise 1';
    } else if (selectCategory === 'Type de maîtrise 3' && categoryData['Type de maîtrise 2']) {
      alternativeCategory = 'Type de maîtrise 2';
    }
    
    if (alternativeCategory) {
      console.log(`Utilisation de la catégorie alternative '${alternativeCategory}'`);
      selectCategory = alternativeCategory;
    } else {
      // Si aucune alternative n'est disponible
      showLoadingError(activeTabId);
      return;
    }
  }
  
  const options = categoryData[selectCategory];
  
  // Vérifier si des options sont disponibles
  if (!options || options.length === 0) {
    console.error(`Aucune option disponible pour '${currentCategory.name}' et '${selectCategory}'`);
    showLoadingError(activeTabId);
    return;
  }
  console.log(`Options pour ${currentCategory.name} et ${selectCategory}:`, options);
  
  // Populer les niveaux 1, 2, 3
  for (let level = 1; level <= 3; level++) {
    const cellId = `${activeTabId}-level-${level}`;
    const cell = document.getElementById(cellId);
    
    if (cell) {
      // Trouver l'option correspondant au niveau
      // Mapping des valeurs selon le type de catégorie et le niveau
      let option;
      
      if (currentCategory.name === 'Task' && (selectCategory === 'Type de maîtrise 1' || selectCategory === 'Type de maîtrise 2')) {
        // Pour Tasks, les niveaux sont B, S, M
        if (level === 1) option = options.find(opt => opt.value === 'B');
        else if (level === 2) option = options.find(opt => opt.value === 'S');
        else if (level === 3) option = options.find(opt => opt.value === 'M');
        
        // Vérification supplémentaire pour toutes les catégories au niveau 3
        if (level === 3 && !option) {
          // Recherches supplémentaires selon la catégorie
          if (currentCategory.name === 'Task') {
            // Pour Task, chercher M avec insensibilité à la casse
            option = options.find(opt => opt.value.toUpperCase() === 'M');
          } 
          else if (currentCategory.name === 'Knowledge') {
            // Pour Knowledge, chercher D ou 3 ou 4
            option = options.find(opt => ['D', '3', '4'].includes(opt.value));
          }
          else if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
            // Pour Skill/Ability, chercher 3 ou des variations
            option = options.find(opt => ['3', 'HIGH', 'EXPERT', 'ADVANCED'].includes(opt.value.toUpperCase()));
          }
          
          // Si toujours pas trouvé, afficher une description par défaut
          if (!option) {
            // Descriptions spécifiques selon la catégorie
            let title = '';
            let description = '';
            
            if (currentCategory.name === 'Task') {
              title = "Proficiency level MASTER";
              description = "Capable de former et d'encadrer les autres. Niveau le plus élevé de maîtrise.";
            } 
            else if (currentCategory.name === 'Knowledge') {
              title = "Level D (Analysis & Evaluation)";
              description = "Capacité à analyser et évaluer les connaissances à un niveau expert. Niveau le plus élevé.";
            }
            else if (currentCategory.name === 'Skill') {
              title = "Niveau 3 (Expert)";
              description = "Capable de gérer indépendamment une grande variété de tâches complexes. Niveau le plus élevé.";
            }
            else if (currentCategory.name === 'Ability') {
              title = "Niveau 3 (Expert)";
              description = "Maîtrise complète et capacité à résoudre des problèmes complexes. Niveau le plus élevé.";
            }
            
            cell.innerHTML = `
              <div class="text-sm">
                <div class="font-medium">${title}</div>
                <div class="text-xs text-gray-600 mt-1">${description}</div>
              </div>
            `;
            continue; // Passer à l'itération suivante
          }
        }
      } 
      else if ((currentCategory.name === 'Skill' || currentCategory.name === 'Ability') && 
               (selectCategory === 'Type de maîtrise 2' || selectCategory === 'Type de maîtrise 3')) {
        // Pour Skills et Abilities, les niveaux sont numériques 1, 2, 3
        option = options.find(opt => opt.value === level.toString());
      }
      else if (currentCategory.name === 'Knowledge') {
        // Pour Knowledge, les niveaux peuvent être A, B, C, D ou 1, 2, 3
        if (level === 1) option = options.find(opt => opt.value === '1' || opt.value === 'A');
        else if (level === 2) option = options.find(opt => opt.value === '2' || opt.value === 'B' || opt.value === 'C');
        else if (level === 3) option = options.find(opt => opt.value === '3' || opt.value === 'D');
      }
      else {
        // Fallback général
        option = options.find(opt => {
          return opt.value === level.toString() || 
                (level === 1 && (opt.value === 'A' || opt.value === '1' || opt.value === 'B')) ||
                (level === 2 && (opt.value === 'B' || opt.value === '2' || opt.value === 'C' || opt.value === 'S')) ||
                (level === 3 && (opt.value === 'C' || opt.value === '3' || opt.value === 'D' || opt.value === 'M'));
        });
      }
      
      if (option) {
        cell.innerHTML = `
          <div class="text-sm">
            <div class="font-medium">${option.title || `Niveau ${level}`}</div>
            <div class="text-xs text-gray-600 mt-1">${option.description || 'Aucune description disponible'}</div>
          </div>
        `;
        
        // Pour le débogage
        console.log(`Option trouvée pour ${currentCategory.name}, niveau ${level}:`, option);
              } else {
          // Pour le débogage
          console.warn(`Aucune option trouvée pour ${currentCategory.name}, niveau ${level}, catégorie ${selectCategory}`);
          console.log('Options disponibles:', options.map(o => `${o.value}: ${o.title}`));
          
          // Fallback pour tous les niveaux dans toutes les catégories
          if (level === 3) {
            // Fallback spécifique pour le niveau 3
            let title = '';
            let description = '';
            
            if (currentCategory.name === 'Task') {
              title = "Proficiency level MASTER";
              description = "Capable de former et d'encadrer les autres. Niveau le plus élevé de maîtrise.";
            } 
            else if (currentCategory.name === 'Knowledge') {
              title = "Level D (Analysis & Evaluation)";
              description = "Capacité à analyser et évaluer les connaissances à un niveau expert. Niveau le plus élevé.";
            }
            else if (currentCategory.name === 'Skill') {
              title = "Niveau 3 (Expert)";
              description = "Capable de gérer indépendamment une grande variété de tâches complexes. Niveau le plus élevé.";
            }
            else if (currentCategory.name === 'Ability') {
              title = "Niveau 3 (Expert)";
              description = "Maîtrise complète et capacité à résoudre des problèmes complexes. Niveau le plus élevé.";
            }
            
            cell.innerHTML = `
              <div class="text-sm">
                <div class="font-medium">${title}</div>
                <div class="text-xs text-gray-600 mt-1">${description}</div>
              </div>
            `;
          } 
          else if (level === 2) {
            // Fallback pour le niveau 2
            let title = '';
            let description = '';
            
            if (currentCategory.name === 'Task') {
              title = "Proficiency level SENIOR";
              description = "Autonome au quotidien. Peut accomplir les tâches sans supervision.";
            } 
            else if (currentCategory.name === 'Knowledge') {
              title = "Level C (Application)";
              description = "Capable d'appliquer les connaissances dans différentes situations.";
            }
            else if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
              title = "Niveau 2 (Intermédiaire)";
              description = "Capable de traiter de manière autonome certaines tâches complexes.";
            }
            
            cell.innerHTML = `
              <div class="text-sm">
                <div class="font-medium">${title}</div>
                <div class="text-xs text-gray-600 mt-1">${description}</div>
              </div>
            `;
          }
          else if (level === 1) {
            // Fallback pour le niveau 1
            let title = '';
            let description = '';
            
            if (currentCategory.name === 'Task') {
              title = "Proficiency level BASIC";
              description = "Notions, pas encore autonome. Nécessite une supervision.";
            } 
            else if (currentCategory.name === 'Knowledge') {
              title = "Level A/B (Familiarity/Comprehension)";
              description = "Connaissance de base et compréhension des concepts fondamentaux.";
            }
            else if (currentCategory.name === 'Skill' || currentCategory.name === 'Ability') {
              title = "Niveau 1 (Base)";
              description = "Doit être familier avec cette compétence, notions de base.";
            }
            
            cell.innerHTML = `
              <div class="text-sm">
                <div class="font-medium">${title}</div>
                <div class="text-xs text-gray-600 mt-1">${description}</div>
              </div>
            `;
          }
          else {
            cell.innerHTML = `<span class="text-gray-400 text-sm">Non défini</span>`;
          }
        }
    }
  }
}

// Fonction pour afficher une erreur de chargement
function showLoadingError(activeTabId) {
  for (let level = 1; level <= 3; level++) {
    const cellId = `${activeTabId}-level-${level}`;
    const cell = document.getElementById(cellId);
    if (cell) {
      cell.innerHTML = `
        <div class="text-center">
          <span class="text-red-500 text-sm">Erreur de chargement</span>
          <button 
            class="ml-2 px-2 py-0.5 text-xs bg-gray-200 hover:bg-gray-300 rounded" 
            onclick="retryLoadingData('${activeTabId}')">
            Réessayer
          </button>
        </div>
      `;
    }
  }
}

// Fonction pour réessayer de charger les données
function retryLoadingData(activeTabId) {
  const currentCategory = categoryMapping[activeTabId];
  if (!currentCategory) return;
  
  // Déterminer le type d'information actif
  let infoType = '';
  const infoButtons = document.querySelectorAll('[id^="info-"]');
  for (const button of infoButtons) {
    if (button.getAttribute('onclick').includes('pertinence')) {
      infoType = 'pertinence';
      break;
    } else if (button.getAttribute('onclick').includes('niveau-attendu')) {
      infoType = 'niveau-attendu';
      break;
    } else if (button.getAttribute('onclick').includes('niveau-tolere')) {
      infoType = 'niveau-tolere';
      break;
    }
  }
  
  // Recharger les données
  loadSelectOptionsData(infoType, activeTabId, currentCategory);
}

// Fonction pour afficher la fenêtre modale d'information
function showModalInfo(buttonId) {
  console.log('Affichage du modal pour le bouton:', buttonId);
  
  // Vérifier si les données sont chargées
  if (!modalDataLoaded || !modalInfoData || !modalInfoData.categories) {
    console.log('Les données ne sont pas encore chargées, on essaie de les charger...');
    
    // Afficher un message d'attente
    const waitingModal = document.createElement('div');
    waitingModal.style.position = 'fixed';
    waitingModal.style.top = '0';
    waitingModal.style.left = '0';
    waitingModal.style.width = '100%';
    waitingModal.style.height = '100%';
    waitingModal.style.backgroundColor = 'rgba(0,0,0,0.5)';
    waitingModal.style.display = 'flex';
    waitingModal.style.justifyContent = 'center';
    waitingModal.style.alignItems = 'center';
    waitingModal.style.zIndex = '9999';
    
    const messageBox = document.createElement('div');
    messageBox.style.backgroundColor = 'white';
    messageBox.style.padding = '20px';
    messageBox.style.borderRadius = '5px';
    messageBox.innerHTML = 'Chargement des informations détaillées...';
    
    waitingModal.appendChild(messageBox);
    document.body.appendChild(waitingModal);
    
    // Essayer de charger les données via AJAX
    initModalData()
      .then(() => {
        // Supprimer le message d'attente
        document.body.removeChild(waitingModal);
        
        // Rappeler cette fonction maintenant que les données sont chargées
        showModalInfo(buttonId);
      })
      .catch(error => {
        // Supprimer le message d'attente
        document.body.removeChild(waitingModal);
        
        // Afficher un message d'erreur
        alert('Impossible de charger les informations détaillées. Veuillez réessayer ultérieurement.');
        console.error('Erreur lors du chargement des données modales:', error);
      });
    
    return;
  }
  
  console.log('Données modales disponibles:', modalInfoData);
  
  // Déterminer le type de KSAT actif
  const isKnowledgeTab = document.getElementById('knowledge').classList.contains('hidden') === false;
  const isSkillTab = document.getElementById('skill').classList.contains('hidden') === false;
  const isAbilitieTab = document.getElementById('abilitie').classList.contains('hidden') === false;
  
  let ksatType = 'task'; // Par défaut
  if (isKnowledgeTab) ksatType = 'knowledge';
  if (isSkillTab) ksatType = 'skill';
  if (isAbilitieTab) ksatType = 'ability';
  
  console.log('Type KSAT actif:', ksatType);
  
  // Déterminer le titre et les options en fonction du bouton
  let modalTitle = '';
  let options = [];
  
  // Récupérer les données du modal depuis l'objet modalInfoData
  if (modalInfoData.categories[buttonId] &&
      modalInfoData.categories[buttonId].infos && 
      modalInfoData.categories[buttonId].infos[ksatType]) {
    const modalInfo = modalInfoData.categories[buttonId].infos[ksatType];
    modalTitle = modalInfo.title || getDefaultTitle(buttonId);
    options = modalInfo.options || [];
    console.log('Données trouvées pour', buttonId, 'et', ksatType, ':', modalInfo);
  } else {
    console.warn('Aucune donnée trouvée pour', buttonId, 'et', ksatType);
    modalTitle = getDefaultTitle(buttonId);
  }
  
  // Fonction pour obtenir un titre par défaut en fonction du bouton
  function getDefaultTitle(buttonId) {
    switch(buttonId) {
      case 'info-button-1':
        return 'Importance (0-3)';
      case 'info-button-2':
        return 'Type de maîtrise (B, S, M)';
      case 'info-button-3':
        return 'Type de maîtrise simplifié (B, S)';
      default:
        return 'Information';
    }
  }
  
  // Créer le modal
  const modal = document.createElement('div');
  modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4';
  
  const modalContent = document.createElement('div');
  modalContent.className = 'bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-auto';
  
  // En-tête
  const header = document.createElement('div');
  header.className = 'border-b px-4 py-3 flex justify-between items-center sticky top-0 bg-white';
  header.innerHTML = `
    <h3 class="font-bold text-lg">${modalTitle}</h3>
    <button type="button" class="text-gray-500 hover:text-white text-xl">&times;</button>
  `;
  
  // Corps
  const body = document.createElement('div');
  body.className = 'p-4';
  
  // Si aucune option n'est disponible, afficher un message
  if (!options.length) {
    const message = document.createElement('p');
    message.textContent = 'Aucune information disponible pour cette section.';
    message.className = 'text-gray-600 italic';
    body.appendChild(message);
  }
  
  // Créer le contenu pour chaque option
  options.forEach(option => {
    const optionDiv = document.createElement('div');
    optionDiv.className = 'mb-4 pb-4 border-b last:border-0';
    
    // Titre avec badge
    const title = document.createElement('h4');
    title.className = 'font-bold text-md mb-2 flex items-center';
    const badge = document.createElement('span');
    badge.className = 'inline-block w-6 h-6 rounded-full bg-blue-600 text-white flex items-center justify-center mr-2';
    badge.textContent = option.text || '';
    
    title.appendChild(badge);
    
    // Extraire le titre principal (avant le premier saut de ligne)
    const titleText = option.title ? option.title.split('\n')[0].trim() : '';
    title.appendChild(document.createTextNode(titleText));
    optionDiv.appendChild(title);
    
    // Contenu formaté (après le premier saut de ligne)
    if (option.title && option.title.includes('\n')) {
      const content = document.createElement('div');
      content.className = 'text-sm text-gray-700 pl-8';
      
      const formattedText = option.title
        .substring(option.title.indexOf('\n'))
        .replace(/---/g, '<hr class="my-2 border-gray-200">')
        .replace(/\n/g, '<br>');
      
      content.innerHTML = formattedText;
      optionDiv.appendChild(content);
    }
    
    body.appendChild(optionDiv);
  });
  
  // Assembler le modal
  modalContent.appendChild(header);
  modalContent.appendChild(body);
  modal.appendChild(modalContent);
  
  // Ajouter au DOM
  document.body.appendChild(modal);
  
  // Gestionnaires d'événements pour fermer le modal
  const closeBtn = header.querySelector('button');
  closeBtn.addEventListener('click', () => document.body.removeChild(modal));
  modal.addEventListener('click', (e) => {
    if (e.target === modal) document.body.removeChild(modal);
  });
}

// Cette fonction sera appelée une fois le DOM chargé pour récupérer les données JSON
function loadModalData() {
  console.log('Tentative de chargement des données modales...');
  try {
    const modalInfoElement = document.getElementById('modal-info-data');
    console.log('Elément modal-info-data:', modalInfoElement);
    
    if (modalInfoElement && modalInfoElement.textContent.trim()) {
      console.log('Contenu JSON brut:', modalInfoElement.textContent.substring(0, 100) + '...');
      modalInfoData = JSON.parse(modalInfoElement.textContent);
      console.log('Données modales chargées avec succès', modalInfoData);
      modalDataLoaded = true;
      return true;
    } else {
      console.warn('Script JSON des modals vide ou introuvable - vérifiez que populate_modal_infos.py a été exécuté');
      modalDataLoaded = false;
      return false;
    }
  } catch(e) {
    console.error('Erreur lors du chargement des données modales:', e);
    modalDataLoaded = false;
    return false;
  }
}

// Fonction pour extraire l'OPM ID (les 3 premiers chiffres) d'un OPM ID complet
function extractOpmId(opmIdString) {
  if (!opmIdString) return null;
  // Extraire les 3 premiers chiffres de l'OPM ID
  const match = opmIdString.toString().match(/^(\d{3})/);
  return match ? match[1] : null;
}

// Fonction pour regrouper visuellement les colonnes du même work_role selon la couleur de leur catégorie
function colorizeColumns() {
  console.log('Application des styles aux colonnes selon la couleur de la catégorie...');
  
  try {
    // Sélectionner tous les tableaux dans tous les onglets (visibles ou non)
    const tables = document.querySelectorAll('.tab-content table');
    if (!tables.length) {
      console.error('Aucun tableau trouvé dans la page');
      return;
    }
    
    // Appliquer les styles à chaque tableau
    tables.forEach(table => {
      // Sélectionner les en-têtes de colonnes (sans compter la première colonne qui est la description)
      const headers = table.querySelectorAll('thead th');
      const numColumns = headers.length - 1; // -1 pour exclure la colonne de description
      
      if (numColumns <= 0) return;
      
      // Parcourir chaque colonne et appliquer les styles
      for (let i = 1; i <= numColumns; i++) { // Commencer à 1 pour sauter la colonne de description
        const header = headers[i];
        if (!header) continue;
        
        // Récupérer les attributs data pour déterminer le work_role
        const roleId = header.getAttribute('data-role-id');
        const groupId = header.getAttribute('data-group-id');
        const opmId = header.getAttribute('data-opm-id');
        
        // Extraire l'OPM ID (les 3 premiers chiffres)
        const opmIdBase = extractOpmId(opmId);
        
        // Récupérer la couleur de la catégorie via un attribut data
        const categoryColor = header.getAttribute('data-category-color');
        
        if (categoryColor) {
          // Créer les couleurs à partir de la couleur de la catégorie
          const bgColor = `rgba(${categoryColor}, 0.15)`;
          const borderColor = `rgba(${categoryColor}, 1)`;
          
          // Déterminer si c'est la première colonne du groupe OPM ID
          let isFirstInOpmGroup = false;
          let isLastInOpmGroup = false;
          
          if (opmIdBase) {
            // Vérifier la colonne précédente
            const prevHeader = headers[i - 1];
            const prevOpmId = prevHeader ? prevHeader.getAttribute('data-opm-id') : null;
            const prevOpmIdBase = extractOpmId(prevOpmId);
            
            // Vérifier la colonne suivante
            const nextHeader = headers[i + 1];
            const nextOpmId = nextHeader ? nextHeader.getAttribute('data-opm-id') : null;
            const nextOpmIdBase = extractOpmId(nextOpmId);
            
            // C'est la première colonne du groupe si l'OPM ID est différent de la précédente
            isFirstInOpmGroup = (prevOpmIdBase !== opmIdBase);
            
            // C'est la dernière colonne du groupe si l'OPM ID est différent de la suivante ou si c'est la dernière colonne
            isLastInOpmGroup = (nextOpmIdBase !== opmIdBase || i === numColumns);
          } else {
            // Si pas d'OPM ID, traiter comme un groupe solo
            isFirstInOpmGroup = true;
            isLastInOpmGroup = true;
          }
          
          // Appliquer un style à l'en-tête
          header.style.backgroundColor = bgColor;
          header.style.borderTop = `3px solid ${borderColor}`;
          
          // Appliquer les bordures gauche et droite selon le groupement OPM ID
          if (isFirstInOpmGroup) {
            header.style.borderLeft = `3px solid ${borderColor}`;
          } else {
            header.style.borderLeft = '';
          }
          
          if (isLastInOpmGroup) {
            header.style.borderRight = `3px solid ${borderColor}`;
          } else {
            header.style.borderRight = '';
          }
          
          // Appliquer le même style à toutes les cellules de cette colonne
          const rows = table.querySelectorAll('tbody tr');
          rows.forEach(row => {
            if (row.cells.length <= i) return;
            
            const cell = row.cells[i];
            if (cell) {
              cell.style.backgroundColor = `rgba(${categoryColor}, 0.05)`; // Plus léger pour les cellules
              
              // Appliquer les bordures gauche et droite selon le groupement OPM ID
              if (isFirstInOpmGroup) {
                cell.style.borderLeft = `3px solid ${borderColor}`;
              } else {
                cell.style.borderLeft = '';
              }
              
              if (isLastInOpmGroup) {
                cell.style.borderRight = `3px solid ${borderColor}`;
              } else {
                cell.style.borderRight = '';
              }
            }
          });
        } else {
          console.warn(`Pas de couleur de catégorie définie pour la colonne ${i}`);
        }
      }
    });
    
    console.log('Styles appliqués avec succès aux colonnes des tableaux');
  } catch (error) {
    console.error('Erreur lors de l\'application des styles:', error);
  }
}


document.addEventListener("DOMContentLoaded", () => {
  console.log('DOM chargé, initialisation de l\'interface...');
  
  // Charger les données KSAT pour les Skills Alignment
  loadKsatData();
  
  // Initialiser les données modales via AJAX (asynchrone)
  initModalData()
    .then(success => {
      console.log('Initialisation des données modales réussie!');
      // Appeler la fonction pour colorier les colonnes par groupes
      colorizeColumns();
      // Initialiser les compteurs de sélection
      setTimeout(() => {
        initializeSelectionCounters();
      }, 500); // Délai plus long pour s'assurer que tous les éléments sont prêts
    })
    .catch(error => {
      console.error('Impossible d\'initialiser les données modales:', error);
      const errorDiv = document.createElement('div');
      errorDiv.style.backgroundColor = '#ffeeee';
      errorDiv.style.color = '#cc0000';
      errorDiv.style.padding = '10px';
      errorDiv.style.margin = '10px';
      errorDiv.style.borderRadius = '5px';
      errorDiv.innerHTML = '<strong>Erreur:</strong> Impossible de charger les informations détaillées. Contactez l\'administrateur.';
      document.body.prepend(errorDiv);
    });
  
  // Attachement direct des gestionnaires d'événements aux boutons d'information
  console.log('Attachement des événements aux boutons d\'information...');
  document.querySelectorAll('[id^="info-button-"]').forEach(button => {
    console.log('Attachement événement au bouton:', button.id);
    button.onclick = function(e) {
      console.log('Clic sur le bouton d\'information:', this.id);
      e.preventDefault();
      e.stopPropagation();
      showModalInfo(this.id);
    };
  });
  
  const tabs = document.querySelectorAll(".tab-button");
  const contents = document.querySelectorAll(".tab-content");

  function activate(btn) {
    tabs.forEach(b => {
      b.classList.toggle("border-blue-500", b===btn);
      b.classList.toggle("text-blue-600", b===btn);
    });
    contents.forEach(c => c.classList.add("hidden"));
    const activeTabContent = document.getElementById(btn.dataset.tab);
    activeTabContent.classList.remove("hidden");

    // Déplacer les contrôles globaux dans l'en-tête du tableau de l'onglet actif
    const controlsContent = document.getElementById('global-controls-content');
    const headerCell = activeTabContent.querySelector('thead th:first-child');
    
    if (controlsContent && headerCell) {
        // S'assurer que le contenu de la cellule est dans un conteneur flex
        let flexWrapper = headerCell.querySelector('.header-flex-wrapper');
        if (!flexWrapper) {
            flexWrapper = document.createElement('div');
            flexWrapper.className = 'flex items-center header-flex-wrapper';
            // Déplacer le contenu existant de la cellule dans le wrapper
            while (headerCell.firstChild) {
                flexWrapper.appendChild(headerCell.firstChild);
            }
            headerCell.appendChild(flexWrapper);
        }
        // Ajouter les contrôles au wrapper
        flexWrapper.appendChild(controlsContent);
    }
    
    // Afficher/masquer les boutons d'information selon l'onglet actif
    const isActiveTab = btn.dataset.tab === 'task' || btn.dataset.tab === 'knowledge';
    document.querySelectorAll('.info-buttons').forEach(buttons => {
      if (isActiveTab) {
        buttons.classList.remove('hidden');
      } else {
        buttons.classList.add('hidden');
      }
    });
    
    // Mettre à jour l'onglet actif et le compteur
    currentActiveTab = btn.dataset.tab;
    
    // S'assurer que les compteurs sont à jour pour cet onglet
    updateSelectionCountersForTab(btn.dataset.tab);
    updateSelectionCounter(btn.dataset.tab);
    
    // Mettre à jour l'état de la checkbox "Check All" pour cet onglet
    updateCheckAllState(btn.dataset.tab);
    
    // RESTAURATION CRITIQUE DES OPTIONS DES SELECTS POUR LE NOUVEL ONGLET ACTIF
    console.log(`Restauration des options pour l'onglet ${btn.dataset.tab}`);
    try {
      // Vérifier si la fonction existe (ajoutée plus tard dans le code)
      if (typeof restaurerOptionsSelects === 'function') {
        restaurerOptionsSelects();
      } else {
        // Fallback si la fonction n'existe pas encore
        console.log("La fonction restaurerOptionsSelects n'existe pas encore, restauration manuelle");
        const tab = document.getElementById(btn.dataset.tab);
        if (tab) {
          const selectGroups = tab.querySelectorAll('.select-group');
          selectGroups.forEach(group => {
            const selects = group.querySelectorAll('select');
            selects.forEach((select, selectIndex) => {
              if (select.options.length <= 1) {
                // Restaurer les options selon la position du select
                if (selectIndex === 0) {  // Premier select (pertinence)
                  select.innerHTML = '';
                  select.appendChild(new Option('--', ''));
                  select.appendChild(new Option('0', '0'));
                  select.appendChild(new Option('1', '1'));
                  select.appendChild(new Option('2', '2'));
                  select.appendChild(new Option('3', '3'));
                }
                else if (selectIndex === 1) {  // Deuxième select
                  select.innerHTML = '';
                  select.appendChild(new Option('--', ''));
                  
                  if (btn.dataset.tab === 'task') {
                    select.appendChild(new Option('B', 'B'));
                    select.appendChild(new Option('S', 'S'));
                    select.appendChild(new Option('M', 'M'));
                  } 
                  else if (btn.dataset.tab === 'knowledge') {
                    select.appendChild(new Option('A', 'A'));
                    select.appendChild(new Option('B', 'B'));
                    select.appendChild(new Option('C', 'C'));
                    select.appendChild(new Option('D', 'D'));
                  } 
                  else {  // skill et abilitie
                    select.appendChild(new Option('1', '1'));
                    select.appendChild(new Option('2', '2'));
                    select.appendChild(new Option('3', '3'));
                  }
                }
                else if (selectIndex === 2) {  // Troisième select
                  select.innerHTML = '';
                  select.appendChild(new Option('--', ''));
                  
                  if (btn.dataset.tab === 'task') {
                    select.appendChild(new Option('B', 'B'));
                    select.appendChild(new Option('S', 'S'));
                  } 
                  else if (btn.dataset.tab === 'knowledge') {
                    select.appendChild(new Option('A', 'A'));
                    select.appendChild(new Option('B', 'B'));
                    select.appendChild(new Option('C', 'C'));
                  } 
                  else {  // skill et abilitie
                    select.appendChild(new Option('1', '1'));
                    select.appendChild(new Option('2', '2'));
                  }
                }
              }
            });
          });
        }
      }
    } catch (error) {
      console.error("Erreur lors de la restauration des options:", error);
    }
    
    // Observer les selects dans le nouvel onglet actif et mettre à jour l'état des selects globaux
    setTimeout(() => {
      observeSelectChanges();
      // Mettre à jour les options des contrôles globaux en fonction de la catégorie active
      updateGlobalSelectOptions(btn.dataset.tab);
      
      // Mettre à jour les dépendances des contrôles globaux
      const globalPertinenceSelect = document.getElementById('global-pertinence-select');
      const globalAttenduSelect = document.getElementById('global-niveau-attendu-select');
      if (globalPertinenceSelect) {
          handleGlobalPertinenceChange(globalPertinenceSelect.value);
      }
      if (globalAttenduSelect) {
          updateGlobalTolereOptions(globalAttenduSelect.value);
      }
    }, 100);
  }

  tabs.forEach(btn => btn.addEventListener("click", () => activate(btn)));
  if (tabs.length) {
    activate(tabs[0]);
    // S'assurer que les contrôles globaux sont correctement initialisés
    setTimeout(() => {
      updateGlobalSelectOptions(tabs[0].dataset.tab);
    }, 200);
  }
  
  // Initialiser immédiatement les contrôles globaux avec force
  setTimeout(() => {
    // Forcer l'initialisation manuelle des contrôles globaux  
    const globalSecondary = document.getElementById('global-niveau-attendu-select');
    const globalTertiary = document.getElementById('global-niveau-tolere-select');
    
    if (globalSecondary && globalTertiary) {
      console.log('Force initialisation des contrôles globaux...');
      
      // Par défaut, commencer avec les options de Task (premier onglet)
      globalSecondary.innerHTML = '<option value="">--</option>' +
                                  '<option value="B" title="Basic">B</option>' +
                                  '<option value="S" title="Senior">S</option>' +
                                  '<option value="M" title="Master">M</option>';
      
      globalTertiary.innerHTML = '<option value="">--</option>' +
                                '<option value="B" title="Basic">B</option>' +
                                '<option value="S" title="Senior">S</option>';
      
      console.log('Options par défaut ajoutées aux contrôles globaux');
      
      // Ensuite appeler la fonction normale
      const firstActiveTab = document.querySelector('.tab-button.text-blue-600') || tabs[0];
      if (firstActiveTab) {
        setTimeout(() => {
          updateGlobalSelectOptions(firstActiveTab.dataset.tab);
          console.log('Contrôles globaux mis à jour pour:', firstActiveTab.dataset.tab);
        }, 100);
      }
    } else {
      console.error('Contrôles globaux non trouvés lors de l\'initialisation!');
    }
  }, 100);
  
  // Initialiser les selects au chargement
  document.querySelectorAll('.primary-select').forEach(select => {
    if (select.classList.contains('knowledge-select')) {
      handleKnowledgeSelectChange(select);
    } else if (select.closest('#skill')) {
      handleSkillSelectChange(select);
    } else if (select.closest('#abilitie')) {
      handleAbilitySelectChange(select);
    } else {
      handleSelectChange(select);
    }
  });
  
  // Initialiser la dépendance entre les selects pour toutes les catégories
  document.querySelectorAll('.select-group').forEach(group => {
    const secondarySelects = group.querySelectorAll('.secondary-select');
    if (secondarySelects.length >= 1) {
      const secondSelect = secondarySelects[0];
      
      // Si c'est un groupe de selects de Knowledge
      if (group.querySelector('.knowledge-select')) {
        handleKnowledgeSecondarySelectChange(secondSelect);
      } 
      // Si c'est un groupe de selects de Skills
      else if (group.closest('#skill')) {
        handleSkillSecondarySelectChange(secondSelect);
      }
      // Si c'est un groupe de selects d'Abilities
      else if (group.closest('#abilitie')) {
        handleAbilitySecondarySelectChange(secondSelect);
      }
      // Sinon c'est un groupe de selects de Task
      else {
        handleSecondarySelectChange(secondSelect);
      }
    }
  });
  
  // Initialiser l'observation des selects et l'état des selects globaux
  setTimeout(() => {
    observeSelectChanges();
    // Initialiser les options des contrôles globaux pour l'onglet actif au chargement
    if (currentActiveTab) {
      updateGlobalSelectOptions(currentActiveTab);
    }
  }, 200);
  
  // Les données des modals sont déjà chargées au début du script
  console.log('Configuration des modals terminée');
  
  // Ajouter un écouteur d'événement pour tous les selects dans tous les onglets
  document.querySelectorAll('#skill select, #abilitie select, #task select, #knowledge select').forEach(select => {
    select.addEventListener('change', function() {
      // Récupérer l'identifiant de l'onglet parent
      const tabContent = this.closest('.tab-content');
      if (tabContent) {
        const tabId = tabContent.id;
        console.log(`Select changé dans l'onglet ${tabId}`); 
        // Mettre à jour le compteur pour cet onglet
        updateSelectionCountersForTab(tabId);
        // Mettre à jour les compteurs individuels pour chaque work role
        updateIndividualRoleCounters();
      }
    });
  });
});

// Fonction pour initialiser les compteurs de sélection pour tous les onglets
function initializeSelectionCounters() {
  const tabIds = ['task', 'knowledge', 'skill', 'abilitie'];
  
  console.log('Initialisation des compteurs pour tous les onglets');
  
  // Réinitialiser tous les compteurs à 0
  selectionCounters = {};
  tabIds.forEach(tabId => {
    selectionCounters[tabId] = { total: 0, selected: 0, unselected: 0 };
  });
  
  // Mettre à jour le compteur pour l'onglet actif
  if (currentActiveTab) {
    updateSelectionCounter(currentActiveTab);
  } else {
    // Si aucun onglet actif n'est défini, utiliser le premier
    const firstTab = document.querySelector('.tab-button');
    if (firstTab) {
      currentActiveTab = firstTab.getAttribute('data-tab');
      updateSelectionCounter(currentActiveTab);
    }
  }
  
  // Initialiser le compteur T/K/S/A (commence à 0)
  updateTKSACounter();
  
  // Débug pour vérifier les compteurs
  console.log('Compteurs initialisés:', selectionCounters);
}

// Fonction pour mettre à jour les compteurs de sélection pour un onglet spécifique
function updateSelectionCountersForTab(tabId) {
  const tabContent = document.getElementById(tabId);
  if (!tabContent) {
    console.log('Tab content non trouvé pour ' + tabId);
    return; 
  }
  
  // Réinitialiser les compteurs pour cet onglet
  selectionCounters[tabId] = { selected: 0, total: 0 };
  
  // Récupérer toutes les lignes dans ce tableau
  const rows = tabContent.querySelectorAll('tbody tr');
  
  // Ne compter que les lignes qui ont des selects (lignes avec des données)
  let validRows = 0;
  rows.forEach(row => {
    const selectGroup = row.querySelector('.select-group');
    if (selectGroup) {
      validRows++;
      
      // Adapter la recherche en fonction du type d'onglet
      let firstSelect = null;
      
      // Rechercher le premier select (n1) selon la structure spécifique à chaque onglet
      if (tabId === 'knowledge') {
        firstSelect = selectGroup.querySelector('.knowledge-select');
      } else if (tabId === 'skill' || tabId === 'abilitie') {
        // Pour Skills et Abilities, prendre explicitement le premier select de la sélection
        const allSelects = selectGroup.querySelectorAll('select');
        if (allSelects.length > 0) {
          firstSelect = allSelects[0];
        }
      } else {
        // Pour task et autres
        firstSelect = selectGroup.querySelectorAll('select')[0];
      }
      
      if (firstSelect && firstSelect.value && firstSelect.value !== '0') {
        selectionCounters[tabId].selected++;
      }
    }
  });
  
  // Mettre à jour le total avec seulement les lignes valides
  selectionCounters[tabId].total = validRows;
  
  console.log(`Compteur mis à jour pour ${tabId}: ${selectionCounters[tabId].selected}/${selectionCounters[tabId].total} (lignes valides: ${validRows})`);
  
  // Si c'est l'onglet actif, mettre à jour le compteur affiché
  if (tabId === currentActiveTab) {
    updateSelectionCounter(tabId);
  }
}

// Fonction pour mettre à jour l'affichage du compteur par onglet
function updateSelectionCounter(tabId) {
  // Mettre à jour le compteur
  const counterElement = document.getElementById('current-tab-counter');
  if (counterElement && selectionCounters[tabId]) {
    counterElement.textContent = `${selectionCounters[tabId].selected}/${selectionCounters[tabId].total}`;
  }
  
  // Mettre à jour le nom de la catégorie
  const tabNameElement = document.getElementById('current-tab-name');
  if (tabNameElement) {
    // Formater le nom de la catégorie avec majuscule et pluriel si nécessaire
    let categoryName = tabId;
    if (categoryName === 'task') {
      categoryName = 'Tasks';
    } else if (categoryName === 'knowledge') {
      categoryName = 'Knowledge';
    } else if (categoryName === 'skill') {
      categoryName = 'Skills';
    } else if (categoryName === 'abilitie') {
      categoryName = 'Abilities';
    }
    tabNameElement.textContent = `${categoryName} :`;
  }
  
  // Mettre à jour le compteur global
  updateGlobalCounter();
}

// Fonction pour mettre à jour le compteur global
function updateGlobalCounter() {
  let globalSelected = 0;
  let globalTotal = 0;
  
  // Calculer les totaux globaux
  Object.keys(selectionCounters).forEach(tabId => {
    globalSelected += selectionCounters[tabId].selected || 0;
    globalTotal += selectionCounters[tabId].total || 0;
  });
  
  // Mettre à jour l'affichage du compteur global
  const globalCounterElement = document.getElementById('global-counter');
  if (globalCounterElement) {
    globalCounterElement.textContent = `${globalSelected}/${globalTotal}`;
  }
  
  // Mettre à jour le compteur T/K/S/A
  updateTKSACounter();
  
  console.log(`Compteur global mis à jour: ${globalSelected}/${globalTotal}`);
}

// Fonction pour mettre à jour le compteur T/K/S/A global
function updateTKSACounter() {
  const taskCount = document.getElementById('task-count');
  const knowledgeCount = document.getElementById('knowledge-count');
  const skillCount = document.getElementById('skill-count');
  const abilityCount = document.getElementById('ability-count');
  
  if (taskCount) {
    const taskTab = document.getElementById('task');
    const taskSelected = taskTab ? selectionCounters['task']?.selected || 0 : 0;
    const taskTotal = taskTab ? selectionCounters['task']?.total || 0 : 0;
    taskCount.textContent = `${taskSelected}/${taskTotal}`;
  }
  
  if (knowledgeCount) {
    const knowledgeTab = document.getElementById('knowledge');
    const knowledgeSelected = knowledgeTab ? selectionCounters['knowledge']?.selected || 0 : 0;
    const knowledgeTotal = knowledgeTab ? selectionCounters['knowledge']?.total || 0 : 0;
    knowledgeCount.textContent = `${knowledgeSelected}/${knowledgeTotal}`;
  }
  
  if (skillCount) {
    const skillTab = document.getElementById('skill');
    const skillSelected = skillTab ? selectionCounters['skill']?.selected || 0 : 0;
    const skillTotal = skillTab ? selectionCounters['skill']?.total || 0 : 0;
    skillCount.textContent = `${skillSelected}/${skillTotal}`;
  }
  
  if (abilityCount) {
    const abilityTab = document.getElementById('abilitie');
    const abilitySelected = abilityTab ? selectionCounters['abilitie']?.selected || 0 : 0;
    const abilityTotal = abilityTab ? selectionCounters['abilitie']?.total || 0 : 0;
    abilityCount.textContent = `${abilitySelected}/${abilityTotal}`;
  }
  
  // Mettre à jour les compteurs individuels pour chaque work role
  updateIndividualRoleCounters();
}

// Fonction pour mettre à jour les compteurs individuels de chaque work role
function updateIndividualRoleCounters() {
  // Récupérer tous les onglets (catégories)
  const categories = ['task', 'knowledge', 'skill', 'abilitie'];
  
  // Récupérer tous les work roles uniques depuis tous les onglets
  const allRoleIds = new Set();
  categories.forEach(category => {
    const tabContent = document.getElementById(category);
    if (!tabContent) return;
    const roleHeaders = tabContent.querySelectorAll('thead th[data-role-id]');
    roleHeaders.forEach(header => {
      const roleId = header.getAttribute('data-role-id');
      if (roleId) allRoleIds.add(roleId);
    });
  });
  
  // Pour chaque work role, compter les KSAT cochés par type
  allRoleIds.forEach(roleId => {
    const counts = countSelectedKSATByType(roleId);
    const selectedCounts = countSelectedKSATWithCheckmarkByType(roleId);
    
    // Récupérer l'OPM ID du work role pour utiliser les données JSON
    let opmId = null;
    const firstTab = document.getElementById('task') || document.getElementById('knowledge') || document.getElementById('skill') || document.getElementById('abilitie');
    if (firstTab) {
      const roleHeader = firstTab.querySelector(`th[data-role-id="${roleId}"]`);
      if (roleHeader) {
        opmId = roleHeader.getAttribute('data-opm-id');
      }
    }
    
    // Pour les abilities, utiliser les données du fichier JSON si disponibles
    let abilityCount = counts.A || 0;
    if (opmId && ksatDataLoaded && dcwfKsatData) {
      const dcwfCounts = countDCWFKsat(opmId);
      abilityCount = dcwfCounts.A || 0;
    }
    
    // Mettre à jour uniquement le compteur correspondant à chaque catégorie
    categories.forEach(category => {
      if (category === 'task') {
        const taskCountEl = document.getElementById(`task-count-${category}-${roleId}`);
        if (taskCountEl) taskCountEl.textContent = counts.T || 0;
        const taskSelectedCountEl = document.getElementById(`task-selected-count-${category}-${roleId}`);
        if (taskSelectedCountEl) taskSelectedCountEl.textContent = selectedCounts.T || 0;
      } else if (category === 'knowledge') {
        const knowledgeCountEl = document.getElementById(`knowledge-count-${category}-${roleId}`);
        if (knowledgeCountEl) knowledgeCountEl.textContent = counts.K || 0;
        const knowledgeSelectedCountEl = document.getElementById(`knowledge-selected-count-${category}-${roleId}`);
        if (knowledgeSelectedCountEl) knowledgeSelectedCountEl.textContent = selectedCounts.K || 0;
      } else if (category === 'skill') {
        const skillCountEl = document.getElementById(`skill-count-${category}-${roleId}`);
        if (skillCountEl) skillCountEl.textContent = counts.S || 0;
        const skillSelectedCountEl = document.getElementById(`skill-selected-count-${category}-${roleId}`);
        if (skillSelectedCountEl) skillSelectedCountEl.textContent = selectedCounts.S || 0;
      } else if (category === 'abilitie') {
        const abilityCountEl = document.getElementById(`ability-count-${category}-${roleId}`);
        if (abilityCountEl) abilityCountEl.textContent = abilityCount; // Utiliser le compte depuis le JSON
        const abilitySelectedCountEl = document.getElementById(`ability-selected-count-${category}-${roleId}`);
        if (abilitySelectedCountEl) abilitySelectedCountEl.textContent = selectedCounts.A || 0;
      }
    });
  });
  
  // Garder l'ancienne logique pour les autres éléments si nécessaire
  categories.forEach(category => {
    const tabContent = document.getElementById(category);
    if (!tabContent) return;
    
    const roleHeaders = tabContent.querySelectorAll('thead th[data-role-id]');
    
    roleHeaders.forEach(header => {
      const roleId = header.getAttribute('data-role-id');
      const framework = header.getAttribute('data-framework');
      
      // Calculer les totaux et sélections pour chaque catégorie
      const taskStats = calculateKSATStatsForRole(roleId, 'task');
      const knowledgeStats = calculateKSATStatsForRole(roleId, 'knowledge');
      const skillStats = calculateKSATStatsForRole(roleId, 'skill');
      const abilityStats = calculateKSATStatsForRole(roleId, 'abilitie');
      
      // Mettre à jour l'en-tête avec le total de tous les KSATs (T + K + S + A) pour cette catégorie
      const totalElement = document.getElementById(`total-${category}-${roleId}`);
      const totalAll = taskStats.total + knowledgeStats.total + skillStats.total + abilityStats.total;
      if (totalElement) totalElement.textContent = totalAll;
      
      // Mettre à jour les compteurs ✓ et ✗ dans l'en-tête (totaux de tous les KSAT sélectionnés/non sélectionnés)
      const headerSelectedElement = document.getElementById(`header-selected-${roleId}`);
      const headerUnselectedElement = document.getElementById(`header-unselected-${roleId}`);
      const totalSelected = taskStats.selected + knowledgeStats.selected + skillStats.selected + abilityStats.selected;
      const totalUnselected = taskStats.unselected + knowledgeStats.unselected + skillStats.unselected + abilityStats.unselected;
      
      if (headerSelectedElement) headerSelectedElement.textContent = totalSelected;
      if (headerUnselectedElement) headerUnselectedElement.textContent = totalUnselected;
      
      // Mettre à jour les éléments T avec les vrais compteurs
      const taskTotalElement = document.getElementById(`task-total-${category}-${roleId}`);
      const taskSelectedElement = document.getElementById(`task-selected-${category}-${roleId}`);
      const taskUnselectedElement = document.getElementById(`task-unselected-${category}-${roleId}`);
      
      if (taskTotalElement) taskTotalElement.textContent = taskStats.total;
      if (taskSelectedElement) taskSelectedElement.textContent = taskStats.selected;
      if (taskUnselectedElement) taskUnselectedElement.textContent = taskStats.unselected;
      
      // Mettre à jour les éléments K
      const knowledgeTotalElement = document.getElementById(`knowledge-total-${category}-${roleId}`);
      const knowledgeSelectedElement = document.getElementById(`knowledge-selected-${category}-${roleId}`);
      const knowledgeUnselectedElement = document.getElementById(`knowledge-unselected-${category}-${roleId}`);
      
      if (knowledgeTotalElement) knowledgeTotalElement.textContent = knowledgeStats.total;
      if (knowledgeSelectedElement) knowledgeSelectedElement.textContent = knowledgeStats.selected;
      if (knowledgeUnselectedElement) knowledgeUnselectedElement.textContent = knowledgeStats.unselected;
      
      // Mettre à jour les éléments S
      const skillTotalElement = document.getElementById(`skill-total-${category}-${roleId}`);
      const skillSelectedElement = document.getElementById(`skill-selected-${category}-${roleId}`);
      const skillUnselectedElement = document.getElementById(`skill-unselected-${category}-${roleId}`);
      
      if (skillTotalElement) skillTotalElement.textContent = skillStats.total;
      if (skillSelectedElement) skillSelectedElement.textContent = skillStats.selected;
      if (skillUnselectedElement) skillUnselectedElement.textContent = skillStats.unselected;
      
      // Mettre à jour les éléments A
      const abilityTotalElement = document.getElementById(`ability-total-${category}-${roleId}`);
      const abilitySelectedElement = document.getElementById(`ability-selected-${category}-${roleId}`);
      const abilityUnselectedElement = document.getElementById(`ability-unselected-${category}-${roleId}`);
      
      if (abilityTotalElement) abilityTotalElement.textContent = abilityStats.total;
      if (abilitySelectedElement) abilitySelectedElement.textContent = abilityStats.selected;
      if (abilityUnselectedElement) abilityUnselectedElement.textContent = abilityStats.unselected;
    });
  });
}

// Fonction pour compter les ✅ (checkmarks) par type (T, K, S, A) dans la colonne d'un work role
function countSelectedKSATByType(roleId) {
  const counts = { T: 0, K: 0, S: 0, A: 0 };
  
  // Parcourir tous les onglets (task, knowledge, skill, abilitie)
  const tabs = [
    { id: 'task', type: 'T' },
    { id: 'knowledge', type: 'K' },
    { id: 'skill', type: 'S' },
    { id: 'abilitie', type: 'A' }
  ];
  
  tabs.forEach(tab => {
    const tabContent = document.getElementById(tab.id);
    if (!tabContent) return;
    
    // Trouver la colonne correspondant à ce work role
    const roleHeader = tabContent.querySelector(`th[data-role-id="${roleId}"]`);
    if (!roleHeader) return;
    
    const headerIndex = Array.from(roleHeader.parentNode.children).indexOf(roleHeader);
    
    // Parcourir toutes les lignes et compter les ✅ dans cette colonne
    const rows = tabContent.querySelectorAll('tbody tr');
    rows.forEach(row => {
      const cells = row.querySelectorAll('td');
      if (cells.length > headerIndex) {
        const roleCell = cells[headerIndex];
        if (roleCell) {
          const cellContent = roleCell.textContent || roleCell.innerHTML;
          // Compter les ✅ (checkmarks) dans cette cellule
          if (cellContent.includes('✅') || cellContent.includes('✓')) {
            counts[tab.type] = (counts[tab.type] || 0) + 1;
          }
        }
      }
    });
  });
  
  return counts;
}

// Fonction pour compter les KSAT cochés qui ont un ✅ pour le work role en question
function countSelectedKSATWithCheckmarkByType(roleId) {
  const counts = { T: 0, K: 0, S: 0, A: 0 };
  
  // Parcourir tous les onglets (task, knowledge, skill, abilitie)
  const tabs = [
    { id: 'task', type: 'T' },
    { id: 'knowledge', type: 'K' },
    { id: 'skill', type: 'S' },
    { id: 'abilitie', type: 'A' }
  ];
  
  tabs.forEach(tab => {
    const tabContent = document.getElementById(tab.id);
    if (!tabContent) return;
    
    // Trouver la colonne correspondant à ce work role
    const roleHeader = tabContent.querySelector(`th[data-role-id="${roleId}"]`);
    if (!roleHeader) return;
    
    const headerIndex = Array.from(roleHeader.parentNode.children).indexOf(roleHeader);
    
    // Parcourir toutes les lignes et compter les KSAT cochés qui ont un ✅
    const rows = tabContent.querySelectorAll('tbody tr');
    rows.forEach(row => {
      // Vérifier si la checkbox KSAT est cochée
      const checkbox = row.querySelector('.ksat-checkbox');
      if (!checkbox || !checkbox.checked) return;
      
      // Vérifier si la cellule du work role contient un ✅
      const cells = row.querySelectorAll('td');
      if (cells.length > headerIndex) {
        const roleCell = cells[headerIndex];
        if (roleCell) {
          const cellContent = roleCell.textContent || roleCell.innerHTML;
          // Compter seulement si la cellule contient un ✅
          if (cellContent.includes('✅') || cellContent.includes('✓')) {
            counts[tab.type] = (counts[tab.type] || 0) + 1;
          }
        }
      }
    });
  });
  
  return counts;
}

// Fonction pour calculer les statistiques KSAT pour un work role spécifique
function calculateKSATStatsForRole(roleId, tabId) {
  const tabContent = document.getElementById(tabId);
  if (!tabContent) return { total: 0, selected: 0, unselected: 0 };
  
  let total = 0;
  let selected = 0;
  let unselected = 0;
  
  const rows = tabContent.querySelectorAll('tbody tr');
  
  // Trouver la colonne correspondant à ce work role
  const roleHeader = document.querySelector(`th[data-role-id="${roleId}"]`);
  if (!roleHeader) return { total: 0, selected: 0, unselected: 0 };
  
  const headerIndex = Array.from(roleHeader.parentNode.children).indexOf(roleHeader);
  
  rows.forEach((row, index) => {
    const roleCell = row.children[headerIndex];
    
    if (roleCell) {
      // Compter toutes les lignes comme total (nombre total de KSATs par catégorie)
      total++;
      
      // Vérifier d'abord si le premier select de cette ligne ≠ "0"
      const descriptionCell = row.querySelector('td:first-child');
      let hasSelection = false;
      
      if (descriptionCell) {
        // Chercher le premier select (celui avec la classe primary-select)
        const firstSelect = descriptionCell.querySelector('.primary-select');
        if (firstSelect && firstSelect.value && firstSelect.value !== '0') {
          hasSelection = true;
        }
      }
      
      // Seulement si le KSAT est sélectionné (premier select ≠ "0"), compter les emojis
      if (hasSelection) {
        const cellContent = roleCell.textContent || roleCell.innerHTML;
        
        if (cellContent.includes('✅')) {
          selected++; // +1 dans la colonne ✓
        }
        if (cellContent.includes('❌')) {
          unselected++; // +1 dans la colonne ✗
        }
      }
    }
  });
  
  return { total, selected, unselected };
}

// Fonction pour compter les sélections pour un work role spécifique (ancienne version)
function countSelectionsForRole(roleId, tabId) {
  const stats = calculateKSATStatsForRole(roleId, tabId);
  return stats.selected;
}

// Fonction pour gérer le changement du premier select pour les Tasks et Knowledge
function handleSelectChange(primarySelect) {
  const selectGroup = primarySelect.closest('.select-group');
  const secondarySelects = Array.from(selectGroup.querySelectorAll('.secondary-select'));
  const select2 = secondarySelects[0];
  const select3 = secondarySelects[1];
  
  // Mise à jour du compteur après changement de select
  const tabContent = primarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Gérer le select 2
  if (primarySelect.value === '0') {
    // Si le premier select est 0, désactiver le select 2
    select2.disabled = true;
    select2.classList.add('opacity-50', 'cursor-not-allowed');
    select2.selectedIndex = 0;
  } else {
    // Sinon, activer le select 2
    select2.disabled = false;
    select2.classList.remove('opacity-50', 'cursor-not-allowed');
  }
  
  // Gérer le select 3
  if (primarySelect.value === '2') {
    // Si le premier select est 2, activer le select 3
    select3.disabled = false;
    select3.classList.remove('opacity-50', 'cursor-not-allowed');
  } else {
    // Sinon, désactiver le select 3
    select3.disabled = true;
    select3.classList.add('opacity-50', 'cursor-not-allowed');
    select3.selectedIndex = 0;
  }
}

// Fonction pour gérer le changement du premier select pour les Skills
function handleSkillSelectChange(primarySelect) {
  const selectGroup = primarySelect.closest('.select-group');
  const secondarySelects = Array.from(selectGroup.querySelectorAll('.secondary-select'));
  const select2 = secondarySelects[0];
  const select3 = secondarySelects[1];
  
  // Mise à jour du compteur après changement de select
  const tabContent = primarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Gérer le select 2
  if (primarySelect.value === '0') {
    // Si le premier select est 0, désactiver le select 2
    select2.disabled = true;
    select2.classList.add('opacity-50', 'cursor-not-allowed');
    select2.selectedIndex = 0;
    
    // Désactiver aussi le select 3
    select3.disabled = true;
    select3.classList.add('opacity-50', 'cursor-not-allowed');
    select3.selectedIndex = 0;
  } else {
    // Sinon, activer le select 2
    select2.disabled = false;
    select2.classList.remove('opacity-50', 'cursor-not-allowed');
    
    // Vérifier si le premier select est 2, seul cas où le select 3 peut être activé
    if (primarySelect.value === '2') {
      // Le select 3 pourra être activé en fonction du select 2
      handleSkillSecondarySelectChange(select2);
    } else {
      // Pour les valeurs 1 et 3 du premier select, désactiver toujours le select 3
      select3.disabled = true;
      select3.classList.add('opacity-50', 'cursor-not-allowed');
      select3.selectedIndex = 0;
    }
  }
}

// Fonction pour gérer le changement du premier select pour les Abilities
function handleAbilitySelectChange(primarySelect) {
  const selectGroup = primarySelect.closest('.select-group');
  const secondarySelects = Array.from(selectGroup.querySelectorAll('.secondary-select'));
  const select2 = secondarySelects[0];
  const select3 = secondarySelects[1];
  
  // Mise à jour du compteur après changement de select
  const tabContent = primarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Gérer le select 2
  if (primarySelect.value === '0') {
    // Si le premier select est 0, désactiver le select 2
    select2.disabled = true;
    select2.classList.add('opacity-50', 'cursor-not-allowed');
    select2.selectedIndex = 0;
    
    // Désactiver aussi le select 3
    select3.disabled = true;
    select3.classList.add('opacity-50', 'cursor-not-allowed');
    select3.selectedIndex = 0;
  } else {
    // Sinon, activer le select 2
    select2.disabled = false;
    select2.classList.remove('opacity-50', 'cursor-not-allowed');
    
    // Vérifier si le premier select est 2, seul cas où le select 3 peut être activé
    if (primarySelect.value === '2') {
      // Le select 3 pourra être activé en fonction du select 2
      handleAbilitySecondarySelectChange(select2);
    } else {
      // Pour les valeurs 1 et 3 du premier select, désactiver toujours le select 3
      select3.disabled = true;
      select3.classList.add('opacity-50', 'cursor-not-allowed');
      select3.selectedIndex = 0;
    }
  }
}

// Fonction pour gérer le changement du deuxième select pour les Skills
function handleSkillSecondarySelectChange(secondarySelect) {
  const selectGroup = secondarySelect.closest('.select-group');
  const thirdSelect = selectGroup.querySelectorAll('.secondary-select')[1];
  const primarySelect = selectGroup.querySelector('.primary-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = secondarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Vérifier si nous sommes dans l'onglet Skills
  const isSkillTab = selectGroup.closest('#skill') !== null;
  
  // Si nous ne sommes pas dans Skills, sortir de la fonction
  if (!isSkillTab) return;
  
  // Ne pas modifier le troisième select si c'est un événement déclenché par le contrôle global
  const isGlobalEvent = secondarySelect.hasAttribute('data-global-change');
  if (isGlobalEvent) {
    return;
  }
  
  // Réinitialiser le troisième select
  thirdSelect.innerHTML = '';
  thirdSelect.selectedIndex = 0;
  
  // Vérifier d'abord si le premier select a l'option 2 sélectionnée
  // C'est la seule valeur du premier select qui permet d'activer le troisième select
  if (primarySelect.value !== '2') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50', 'cursor-not-allowed');
    return;
  }
  
  // Pour Skills: récupérer dynamiquement les options 1 et 2 depuis les selects existants
  const allSelects = document.querySelectorAll('select');
  let options = [];
  
  // Collecter les options des selects dans l'onglet Skills
  allSelects.forEach(selectEl => {
    if (selectEl.closest('#skill')) {
      Array.from(selectEl.options).forEach(opt => {
        // Ajouter uniquement les options avec les valeurs 1, 2 et éviter les doublons
        if (['1', '2'].includes(opt.value) && 
            !options.some(so => so.value === opt.value)) {
          options.push({
            value: opt.value,
            text: opt.text || opt.value,
            title: opt.title || ''
          });
        }
      });
    }
  });
  
  // Trier les options par valeur
  options.sort((a, b) => parseInt(a.value) - parseInt(b.value));
  
  // Si aucune option n'a été trouvée dans le DOM, utiliser des valeurs par défaut
  if (options.length === 0) {
    options = [
      { value: '1', text: '1', title: "Must be familiar with this competency" },
      { value: '2', text: '2', title: "Must be capable of independently handling some complex tasks" }
    ];
  }
  
  // Gérer les options et l'état du troisième select en fonction de la valeur du deuxième select
  thirdSelect.disabled = false;
  thirdSelect.classList.remove('opacity-50', 'cursor-not-allowed');
  
  // Ajouter les options appropriées
  options.forEach(option => {
    const newOpt = document.createElement('option');
    newOpt.value = option.value;
    newOpt.text = option.text;
    newOpt.title = option.title;
    thirdSelect.appendChild(newOpt);
    
    // Si le deuxième select est 2, désactiver l'option 2
    if (secondarySelect.value === '2' && option.value === '2') {
      newOpt.disabled = true;
    }
    // Si le deuxième select est 1, désactiver tout le select n3
    else if (secondarySelect.value === '1') {
      thirdSelect.disabled = true;
      thirdSelect.classList.add('opacity-50', 'cursor-not-allowed');
    }
  });
  
  // Forçage de la sélection à 1 si le select n2 est 2
  if (secondarySelect.value === '2') {
    thirdSelect.value = '1';
  }
}

// Fonction pour gérer le changement du deuxième select pour les Abilities
function handleAbilitySecondarySelectChange(secondarySelect) {
  const selectGroup = secondarySelect.closest('.select-group');
  const thirdSelect = selectGroup.querySelectorAll('.secondary-select')[1];
  const primarySelect = selectGroup.querySelector('.primary-select');
  
  // Mise à jour du compteur après changement de select
  const tabContent = secondarySelect.closest('.tab-content');
  if (tabContent) {
    const tabId = tabContent.id;
    updateSelectionCountersForTab(tabId);
  }
  
  // Vérifier si nous sommes dans l'onglet Abilities
  const isAbilitieTab = selectGroup.closest('#abilitie') !== null;
  
  // Si nous ne sommes pas dans Abilities, sortir de la fonction
  if (!isAbilitieTab) return;
  
  // Ne pas modifier le troisième select si c'est un événement déclenché par le contrôle global
  const isGlobalEvent = secondarySelect.hasAttribute('data-global-change');
  if (isGlobalEvent) {
    return;
  }
  
  // Réinitialiser le troisième select
  thirdSelect.innerHTML = '';
  thirdSelect.selectedIndex = 0;
  
  // Vérifier d'abord si le premier select a l'option 2 sélectionnée
  // C'est la seule valeur du premier select qui permet d'activer le troisième select
  if (primarySelect.value !== '2') {
    thirdSelect.disabled = true;
    thirdSelect.classList.add('opacity-50', 'cursor-not-allowed');
    return;
  }
  
  // Pour Abilities: récupérer dynamiquement les options 1 et 2 depuis les selects existants
  const allSelects = document.querySelectorAll('select');
  let options = [];
  
  // Collecter les options des selects dans l'onglet Abilities
  allSelects.forEach(selectEl => {
    if (selectEl.closest('#abilitie')) {
      Array.from(selectEl.options).forEach(opt => {
        // Ajouter uniquement les options avec les valeurs 1, 2 et éviter les doublons
        if (['1', '2'].includes(opt.value) && 
            !options.some(so => so.value === opt.value)) {
          options.push({
            value: opt.value,
            text: opt.text || opt.value,
            title: opt.title || ''
          });
        }
      });
    }
  });
  
  // Trier les options par valeur
  options.sort((a, b) => parseInt(a.value) - parseInt(b.value));
  
  // Si aucune option n'a été trouvée dans le DOM, utiliser des valeurs par défaut
  if (options.length === 0) {
    options = [
      { value: '1', text: '1', title: "Must be familiar with this competency" },
      { value: '2', text: '2', title: "Must be capable of independently handling some complex tasks" }
    ];
  }
  
  // Gérer les options et l'état du troisième select en fonction de la valeur du deuxième select
  thirdSelect.disabled = false;
  thirdSelect.classList.remove('opacity-50', 'cursor-not-allowed');
  
  // Ajouter les options appropriées
  options.forEach(option => {
    const newOpt = document.createElement('option');
    newOpt.value = option.value;
    newOpt.text = option.text;
    newOpt.title = option.title;
    thirdSelect.appendChild(newOpt);
    
    // Si le deuxième select est 2, désactiver l'option 2
    if (secondarySelect.value === '2' && option.value === '2') {
      newOpt.disabled = true;
    }
    // Si le deuxième select est 1, désactiver tout le select n3
    else if (secondarySelect.value === '1') {
      thirdSelect.disabled = true;
      thirdSelect.classList.add('opacity-50', 'cursor-not-allowed');
    }
  });
  
  // Forçage de la sélection à 1 si le select n2 est 2
  if (secondarySelect.value === '2') {
    thirdSelect.value = '1';
  }
}

// Fonction pour collecter les données de comparaison et ouvrir la fenêtre de détails
function openComparisonWindow() {
  // Activer l'étape 2 uniquement pour l'utilisateur actuel
  // Récupérer le nom d'utilisateur de manière fiable
  let currentUser = '{% if user.is_authenticated %}{{ user.username }}{% else %}anonymous{% endif %}';
  
  if (!currentUser || currentUser === 'anonymous') {
    // Tenter de récupérer depuis une balise meta
    currentUser = document.querySelector('meta[name="username"]')?.content || 'anonymous';
  }
  
  console.log('Activating Etape 2 for user:', currentUser);
  
  // Ne pas utiliser de valeur globale qui serait partagée entre tous les utilisateurs
  // Utiliser uniquement un stockage spécifique à l'utilisateur
  try {
    // Utiliser serverStorage au lieu de localStorage
    serverStorage.getItem('etapeActivations').then(activationsStr => {
      const etapeActivations = JSON.parse(activationsStr || '{}');
      
      // Activer l'étape 2 pour cet utilisateur uniquement
      etapeActivations[currentUser] = {
        ...etapeActivations[currentUser] || {},
        etape2Activated: true
      };
      
      // Sauvegarder les activations mises à jour
      serverStorage.setItem('etapeActivations', JSON.stringify(etapeActivations));
      console.log('Saved etape2 activation state for user ' + currentUser + ':', etapeActivations[currentUser]);
    }).catch(error => {
      console.error('Error loading etape activations:', error);
    });
  } catch (error) {
    console.error('Error saving etape activation:', error);
  }
  
  // Collecter les données des différentes catégories
  const comparisonData = {
    task: [],
    knowledge: [],
    skill: [],
    abilitie: []
  };
  
  // Sauvegarder les totaux par catégorie pour comparer avec les OPM IDs par la suite
  const categoryTotals = {
    task: selectionCounters['task'].total,
    knowledge: selectionCounters['knowledge'].total,
    skill: selectionCounters['skill'].total,
    abilitie: selectionCounters['abilitie'].total
  };
  
  // Sauvegarder dans serverStorage pour accès dans compare_details.html
  Promise.all([
    serverStorage.setItem('totalTaskCount', categoryTotals.task),
    serverStorage.setItem('totalKnowledgeCount', categoryTotals.knowledge),
    serverStorage.setItem('totalSkillCount', categoryTotals.skill),
    serverStorage.setItem('totalAbilitieCount', categoryTotals.abilitie)
  ]).then(() => {
    console.log('Category totals saved to serverStorage');
  }).catch(error => {
    console.error('Error saving category totals:', error);
  });
  
  // Collecter les informations sur les OPM IDs
  const opmIds = [];
  const opmIdsData = {};
  
  // Créer un mapping des colonnes par OPM ID (car un même OPM ID peut avoir plusieurs colonnes)
  const opmIdColumnMap = {};
  const thElements = document.querySelectorAll('thead tr:first-of-type th:not(:first-child)');
  
  thElements.forEach((th, columnIndex) => {
    const opmIdElement = th.querySelector('div div:first-child');
    if (opmIdElement) {
      const opmId = opmIdElement.textContent.trim();
      if (opmId && opmId !== '\xa0') { // \xa0 est un espace insécable
        // Ajouter cette colonne à la liste des colonnes de cet OPM ID
        if (!opmIdColumnMap[opmId]) {
          opmIdColumnMap[opmId] = [];
          // Aussi ajouter à la liste des OPM IDs si pas déjà présent
          if (!opmIds.includes(opmId)) {
            opmIds.push(opmId);
          }
        }
        opmIdColumnMap[opmId].push(columnIndex);
        
        // Initialiser les compteurs pour cet OPM ID si pas déjà fait
        if (!opmIdsData[opmId]) {
          opmIdsData[opmId] = {
            task: { selected: 0, total: 0, validRows: [] },
            knowledge: { selected: 0, total: 0, validRows: [] },
            skill: { selected: 0, total: 0, validRows: [] },
            abilitie: { selected: 0, total: 0, validRows: [] }
          };
        }
      }
    }
  });
  
  console.log('OPM IDs et leurs colonnes:', opmIdColumnMap);
  
  // Parcourir tous les onglets
  document.querySelectorAll('.tab-content').forEach(tabContent => {
    const ksatType = tabContent.id;  // par ex. "task", "knowledge", etc.
    
    // Parcourir tous les éléments qui ont une importance supérieure à 0
    tabContent.querySelectorAll('tbody tr').forEach((row, rowIndex) => {
      const descriptionCell = row.querySelector('td:first-child');
      if (!descriptionCell) return;
      
      // Vérifier si au moins un des selects a une valeur > 0
      const selects = descriptionCell.querySelectorAll('select');
      if (selects.length === 0) return;
      
      const importanceSelect = selects[0];
      // Vérifier si le premier select est différent de 0
      const isImportant = importanceSelect && importanceSelect.value !== "0";
      
      // Vérifier les colonnes de chaque OPM ID
      const opmIdColumns = row.querySelectorAll('td:not(:first-child)');
      
      // Extraire le texte de description
      const descriptionElement = descriptionCell.querySelector('p');
      if (!descriptionElement) return;
      const description = descriptionElement.textContent.trim();
      
      // Extraire les valeurs des selects
      const importanceText = selects[0]?.options[selects[0].selectedIndex]?.text || '';
      const type1Text = selects[1]?.options[selects[1].selectedIndex]?.text || '';
      const type2Text = selects[2]?.options[selects[2].selectedIndex]?.text || '';
      
      // Récupérer les URLs
      const urlElements = descriptionCell.querySelectorAll('.text-sm.text-gray-600.space-x-2 a');
      let dcwfUrl = '';
      let ncwfUrl = '';
      let ksatId = '';
      
      // Chercher l'ID du KSAT
      const idElement = descriptionCell.querySelector('.text-xs.text-gray-500');
      if (idElement) {
        ksatId = idElement.textContent.replace('ID: ', '').trim();
      }
      
      // Extraire les URLs
      urlElements.forEach(url => {
        const href = url.getAttribute('href') || '';
        const text = url.textContent.trim();
        
        if (href.includes('dcwf')) {
          dcwfUrl = { href: href, text: text };
        } else if (href.includes('ncwf') || href.includes('nist')) {
          ncwfUrl = { href: href, text: text };
        }
      });
      
      // Préparer l'objet de données pour cet élément
      const itemData = {
        description: description,
        importance: importanceText,
        type1: type1Text,
        type2: type2Text,
        dcwfUrl: dcwfUrl,
        ncwfUrl: ncwfUrl,
        id: ksatId,
        opmIdStatus: {}
      };
      
      // Pour chaque OPM ID, vérifier si au moins une des colonnes associées a un 
      Object.keys(opmIdColumnMap).forEach(opmId => {
        // Récupérer les indices des colonnes pour cet OPM ID
        const columnIndices = opmIdColumnMap[opmId];
        
        // Vérifier si au moins une colonne de cet OPM ID a un 
        let hasAnyCheckmark = false;
        
        // Pour chaque indice de colonne associé à cet OPM ID
        for (let i = 0; i < columnIndices.length; i++) {
          const columnIndex = columnIndices[i];
          // Vérifier si l'indice est valide pour cette ligne
          if (columnIndex < opmIdColumns.length) {
            const column = opmIdColumns[columnIndex];
            if (column.textContent.includes('')) {
              hasAnyCheckmark = true;
              break; // Si on trouve au moins un , pas besoin de continuer
            }
          }
        }
        
        // Stocker l'état pour cet OPM ID dans les données de l'élément
        itemData.opmIdStatus[opmId] = hasAnyCheckmark;
        
        // Mettre à jour les compteurs pour cet OPM ID
        // Ne compter dans le total que les lignes qui ont au moins un  dans l'une des colonnes de l'OPM ID
        if (hasAnyCheckmark) {
          opmIdsData[opmId][ksatType].total++;
          
          // Si la ligne a au moins un  et est importante, l'ajouter aux lignes valides pour cet OPM ID
          if (isImportant) {
            opmIdsData[opmId][ksatType].selected++;
            opmIdsData[opmId][ksatType].validRows.push(rowIndex);
          }
        }
      });
      
      // N'ajouter à la liste des éléments à comparer que si le select d'importance est > 0
      if (isImportant) {
        comparisonData[ksatType].push(itemData);
      }
    });
  });
  
  // Stocker les données dans serverStorage pour y accéder depuis la nouvelle fenêtre
  Promise.all([
    serverStorage.setItem('comparisonData', JSON.stringify(comparisonData)),
    serverStorage.setItem('opmIdsData', JSON.stringify(opmIdsData))
  ]).then(() => {
    // Ouvrir la nouvelle fenêtre seulement après avoir sauvegardé les données
    window.open("{% url 'ksat_compare_details' %}", "_blank", "width=1200,height=800");
  }).catch(error => {
    console.error('Error saving comparison data:', error);
    // Fallback en cas d'erreur
    localStorage.setItem('comparisonData', JSON.stringify(comparisonData));
    localStorage.setItem('opmIdsData', JSON.stringify(opmIdsData));
    window.open("{% url 'ksat_compare_details' %}", "_blank", "width=1200,height=800");
  });
}

// Fonction pour sauvegarder la sélection actuelle
function saveCurrentSelection() {
  // Collecter les données de tous les selects
  const allSelects = document.querySelectorAll('select');
  const selectValues = {};
  
  allSelects.forEach((select, index) => {
    // Sauvegarder l'ID de l'élément et sa valeur
    const selectId = select.id || `select_${index}`;
    selectValues[selectId] = select.value;
  });
  
  // Obtenir les informations sur les onglets et leur état actif
  const activeTab = document.querySelector('.tab-button.text-blue-600');
  const activeTabId = activeTab ? activeTab.getAttribute('data-tab') : null;
  
  // Collecter des informations sur les work roles pour le titre
  const roles = [];
  document.querySelectorAll('thead tr:first-of-type th:not(:first-child)').forEach(th => {
    // L'OPM ID est dans le premier div avec les classes text-xs text-center mb-1 font-normal
    const opmIdDiv = th.querySelector('div div.text-xs.text-center.mb-1.font-normal');
    // Le titre est dans le div suivant
    const titleDiv = th.querySelector('div div.text-center');
    // Le framework est dans le span à l'intérieur du div suivant
    const frameworkSpan = th.querySelector('div div.text-center span');
    
    if (opmIdDiv && titleDiv && frameworkSpan) {
      const opmId = opmIdDiv.textContent.trim();
      const title = titleDiv.textContent.trim();
      const framework = frameworkSpan.textContent.replace(/[\(\)]/g, '').trim();
      
      // Ne pas ajouter les rôles sans OPM ID
      if (opmId && opmId !== '&nbsp;') {
        roles.push({
          title: title,
          framework: framework,
          opmId: opmId
        });
      }
    }
  });
  
  // Sauvegarder l'URL actuelle pour pouvoir la restaurer
  const currentUrl = window.location.href;
  
  // Collecter toutes les données des KSAT pour chaque onglet
  const ksatData = {};
  
  // Parcourir tous les onglets
  document.querySelectorAll('.tab-content').forEach(tabContent => {
    const tabId = tabContent.id; // 'task', 'knowledge', 'skill', 'abilitie'
    ksatData[tabId] = [];
    
    // Parcourir toutes les lignes de cet onglet
    tabContent.querySelectorAll('tbody tr').forEach(row => {
      const firstCell = row.querySelector('td:first-child');
      if (!firstCell) return;
      
      // Extraire la description et l'ID
      const description = firstCell.querySelector('p.font-medium')?.textContent.trim() || '';
      const ksatId = firstCell.querySelector('.text-xs.text-gray-500')?.textContent.trim() || '';
      
      // Extraire les URLs DCWF et NCWF
      const dcwfUrl = firstCell.querySelector('a[href*="dcwf"]');
      const ncwfUrl = firstCell.querySelector('a[href*="ncwf"]') || firstCell.querySelector('a[href*="nist"]');
      
      // Extraire les valeurs des selects pour cette ligne
      const lineSelects = {};
      firstCell.querySelectorAll('select').forEach((select, idx) => {
        const selectId = select.id || `${tabId}_select_${idx}`;
        lineSelects[selectId] = {
          value: select.value,
          disabled: select.disabled,
          options: Array.from(select.options).map(opt => ({
            value: opt.value,
            text: opt.text,
            disabled: opt.disabled
          }))
        };
      });
      
      // Vérifier si la checkbox est cochée
      const checkbox = firstCell.querySelector('.ksat-checkbox');
      const isChecked = checkbox ? checkbox.checked : true; // Par défaut, considérer comme cochée si pas trouvée
      
      // Collecter les statuts (✅ ou ❌) pour chaque rôle
      const roleStatuses = {};
      const roleCells = row.querySelectorAll('td:not(:first-child)');
      roleCells.forEach((cell, idx) => {
        if (roles[idx]) {
          // Check if cell contains ✅ (KSAT is associated with this role)
          roleStatuses[roles[idx].title] = cell.textContent.includes('✅');
        }
      });
      
      // Créer un objet représentant cette ligne KSAT
      const ksatItem = {
        description: description,
        id: ksatId.replace('ID: ', ''),
        dcwfUrl: dcwfUrl ? { href: dcwfUrl.href, text: dcwfUrl.textContent.trim() } : null,
        ncwfUrl: ncwfUrl ? { href: ncwfUrl.href, text: ncwfUrl.textContent.trim() } : null,
        selects: lineSelects,
        roleStatuses: roleStatuses,
        checked: isChecked  // Sauvegarder l'état de la checkbox
      };
      
      // Ajouter à la liste des KSAT pour cet onglet
      ksatData[tabId].push(ksatItem);
    });
  });
  
  // Récupérer le numéro de poste du localStorage
  const currentJobNumber = localStorage.getItem('currentJobNumber') || '';
  
  // Générer un identifiant unique pour cette sauvegarde
  const saveId = `save_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
  
  // Demander un nom pour cette sauvegarde
  let saveName = prompt("Donnez un nom à cette sauvegarde (optionnel):", "");
  if (saveName === null) {
    // L'utilisateur a annulé
    return;
  }
  
  // Si aucun nom n'est fourni, utiliser un nom par défaut avec la date
  if (!saveName.trim()) {
    const now = new Date();
    const dateStr = `${now.getDate()}/${now.getMonth() + 1}/${now.getFullYear()} ${now.getHours()}:${now.getMinutes()}`;
    saveName = `Sauvegarde du ${dateStr}`;
  }
  
  // Créer un objet de sauvegarde
  const saveData = {
    id: saveId,
    name: saveName,
    timestamp: new Date().toISOString(),
    jobNumber: currentJobNumber,  // Ajouter le numéro de poste
    selectValues: selectValues,
    allSelectValues: allSelectValues,  // Ajouter les valeurs des checkboxes
    activeTab: activeTabId,
    roles: roles,
    ksatData: ksatData,  // Ajouter les données complètes des KSAT
    counters: {
      task: selectionCounters['task'],
      knowledge: selectionCounters['knowledge'],
      skill: selectionCounters['skill'],
      abilitie: selectionCounters['abilitie']
    },
    currentUrl: currentUrl,  // Ajouter l'URL actuelle
    globalControls: {
      pertinence: document.getElementById('global-pertinence-select')?.value || '',
      attendu: document.getElementById('global-niveau-attendu-select')?.value || '',
      tolere: document.getElementById('global-niveau-tolere-select')?.value || ''
    }
  };

  // Enregistrer dans sessionStorage pour la persistance au F5
  sessionStorage.setItem('ksatLastSavedState', JSON.stringify(saveData));

  // Utiliser l'API du serveur pour sauvegarder les données au lieu du localStorage
  fetch('/api/ksat-selections/save/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // Pas besoin de CSRF token car nous utilisons @csrf_exempt
    },
    body: JSON.stringify({
      key: `ksat_selection_${saveId}`,
      value: saveData
    })
  })
  .then(response => {
    if (response.status === 403) {
      throw new Error('Vous devez être connecté pour sauvegarder des données sur le serveur. Veuillez vous connecter.');
    }
    else if (!response.ok) {
      throw new Error(`Erreur réseau lors de la sauvegarde (${response.status} ${response.statusText})`);
    }
    return response.json();
  })
  .then(data => {
    // Garder une copie dans localStorage pour compatibilité avec le code existant
    try {
      // Charger les sauvegardes existantes
      let savedSelections = JSON.parse(localStorage.getItem('ksatSavedSelections') || '[]');
      
      // Ajouter la nouvelle sauvegarde
      savedSelections.push(saveData);
      
      // Limiter à 50 sauvegardes maximum
      if (savedSelections.length > 50) {
        savedSelections = savedSelections.slice(savedSelections.length - 50);
      }
      
      // Sauvegarder dans localStorage (comme avant)
      localStorage.setItem('ksatSavedSelections', JSON.stringify(savedSelections));
    } catch (error) {
      console.error('Erreur localStorage:', error);
      // Continuer malgré l'erreur localStorage car les données sont sur le serveur
    }
    
    // Afficher un message de confirmation
    alert('Sélection sauvegardée avec succès!');
  })
  .catch(error => {
    console.error('Error saving selection:', error);
    alert('Erreur lors de la sauvegarde de la sélection: ' + error.message);
  });
}

// Ajouter fonction pour récupérer le token CSRF
function getCsrfToken() {
  // Récupérer le token CSRF des cookies
  const csrfTokenMatch = document.cookie.match(/csrftoken=([^;]+)/);
  return csrfTokenMatch ? csrfTokenMatch[1] : '';
}

// Ajouter les événements de clic aux boutons
document.addEventListener('DOMContentLoaded', function() {
  // Initialiser serverStorage
  initServerStorage();
  
  // Vérifier si l'utilisateur est connecté
  fetch('/api/ksat-selections/')
    .then(response => {
      if (response.status === 403) {
        console.warn("Vous n'êtes pas connecté. Les sauvegardes ne seront disponibles que dans ce navigateur.");
        // Afficher un message à l'utilisateur
        const saveButton = document.getElementById('save-selection-button');
        if (saveButton) {
          const warningIcon = document.createElement('span');
          warningIcon.className = 'ml-1 text-yellow-500';
          warningIcon.innerHTML = '⚠️';
          warningIcon.title = "Vous n'êtes pas connecté. Les sauvegardes ne seront disponibles que dans ce navigateur.";
          saveButton.appendChild(warningIcon);
        }
      } else {
        console.log("Utilisateur connecté, les sauvegardes seront disponibles sur tous les appareils.");
      }
    })
    .catch(error => {
      console.error("Erreur lors de la vérification de l'authentification:", error);
    });
  
  const compareButton = document.getElementById('compare-button');
  if (compareButton) {
    compareButton.addEventListener('click', openComparisonWindow);
  }
  
  
  const saveButton = document.getElementById('save-selection-button');
  if (saveButton) {
    saveButton.addEventListener('click', saveCurrentSelection);
  }
  
  // Lancer la restauration au chargement
  restoreStateOnLoad();
  
  // Charger les sauvegardes depuis le serveur pour la liste des sauvegardes
  loadSavedSelectionsFromServer();
});

// Nouvelle fonction pour charger les sauvegardes depuis le serveur
function loadSavedSelectionsFromServer() {
  // Vérifier si l'utilisateur est authentifié
  fetch('/api/ksat-selections/')
    .then(response => {
      if (!response.ok) {
        throw new Error('Erreur réseau lors du chargement des sauvegardes');
      }
      return response.json();
    })
    .then(data => {
      if (data && data.status === "success" && data.data && Array.isArray(data.data)) {
        console.log('Sauvegardes chargées depuis le serveur:', data.data.length);
        
        if (data.data.length > 0) {
          // Fusionner avec les sauvegardes locales existantes
          try {
            let localSelections = JSON.parse(localStorage.getItem('ksatSavedSelections') || '[]');
            
            // Créer un ensemble d'IDs locaux pour éviter les doublons
            const localIds = new Set(localSelections.map(item => item.id));
            
            // Nombre d'éléments ajoutés
            let addedCount = 0;
            
            // Ajouter les sauvegardes du serveur qui ne sont pas déjà présentes localement
            data.data.forEach(serverItem => {
              if (serverItem && serverItem.value && !localIds.has(serverItem.value.id)) {
                localSelections.push(serverItem.value);
                addedCount++;
              }
            });
            
            if (addedCount > 0) {
              // Limiter à 50 sauvegardes maximum et trier par date
              localSelections.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
              if (localSelections.length > 50) {
                localSelections = localSelections.slice(0, 50);
              }
              
              // Mettre à jour le localStorage
              localStorage.setItem('ksatSavedSelections', JSON.stringify(localSelections));
              console.log(`localStorage mis à jour avec ${addedCount} nouvelles sauvegardes du serveur`);
            } else {
              console.log('Aucune nouvelle sauvegarde à ajouter.');
            }
          } catch (error) {
            console.error('Erreur lors de la fusion des sauvegardes:', error);
          }
        }
      } else {
        console.log('Aucune sauvegarde trouvée sur le serveur ou format de réponse incorrect');
      }
    })
    .catch(error => {
      console.error('Erreur lors du chargement des sauvegardes depuis le serveur:', error);
  });
}

// Fonctions pour la grille de contrôle global
function showTooltip(type) {
  let message = '';
  switch(type) {
    case 'pertinence':
      message = `PERTINENCE (P) :\n\n` +
                `• 0 - Aucune compétence requise\n` +
                `• 1 - Critique, 'Must have'\n` +
                `• 2 - Important mais acquis rapidement\n` +
                `• 3 - Secondaire / Complémentaire\n\n` +
                `Cette valeur indique l'importance de la compétence pour le poste.`;
      break;
    case 'niveau-attendu':
      message = `NIVEAU NORMALEMENT ATTENDU (A) :\n\n` +
                `• 1 - Niveau de base requis\n` +
                `• 2 - Niveau intermédiaire requis\n` +
                `• 3 - Niveau expert requis\n\n` +
                `Ce niveau représente les compétences attendues dans des conditions normales d'exercice du poste.`;
      break;
    case 'niveau-tolere':
      message = `NIVEAU TOLÉRÉ AU RECRUTEMENT (T) :\n\n` +
                `• 1 - Niveau minimum acceptable\n` +
                `• 2 - Niveau intermédiaire acceptable\n` +
                `• 3 - Niveau expert souhaité\n\n` +
                `Ce niveau représente le minimum acceptable lors du recrutement, en tenant compte de la formation possible après l'embauche.`;
      break;
  }
  
  if (message) {
    alert(message);
  }
}

function updateAllSelects(selectType, value) {
  try {
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  const tabId = activeTab.id;
    const allSelectGroups = activeTab.querySelectorAll('.select-group');
    let updatedCount = 0;

    allSelectGroups.forEach(group => {
          const selects = group.querySelectorAll('select');
      let targetSelect = null;

      if (selectType === 'primary' && selects.length > 0) {
        targetSelect = selects[0];
      } else if (selectType === 'secondary' && selects.length > 1) {
        targetSelect = selects[1];
      } else if (selectType === 'tertiary' && selects.length > 2) {
        targetSelect = selects[2];
      }
      
      if (!targetSelect) return;

      // Si la valeur est vide ("--"), on réinitialise le select s'il n'est pas désactivé
      if (value === "") {
        if (!targetSelect.disabled) {
          targetSelect.value = "";
          const changeEvent = new Event('change', { bubbles: true });
          targetSelect.dispatchEvent(changeEvent);
          updatedCount++;
        }
        return; // Passe à la ligne suivante
      }

      // Si la valeur n'est pas vide, on applique les validations
      if (targetSelect.disabled) {
        return; // Ne pas modifier les selects désactivés
      }

      const optionExists = Array.from(targetSelect.options).some(opt => opt.value === value && !opt.disabled);
      if (!optionExists) {
        return; // Ne pas modifier si l'option n'est pas valide/disponible
      }
      
      targetSelect.value = value;
          const changeEvent = new Event('change', { bubbles: true });
      targetSelect.dispatchEvent(changeEvent);
      updatedCount++;
    });

    const tabNames = { 'skill': 'Skills', 'abilitie': 'Abilities', 'task': 'Tasks', 'knowledge': 'Knowledge' };
    const typeNames = { 'primary': 'Pertinence', 'secondary': 'Niveau attendu', 'tertiary': 'Niveau toléré' };
    
    if (value === "") {
        showNotification(`${updatedCount} sélection(s) pour '${typeNames[selectType]}' réinitialisée(s)`, 'info');
    } else {
        showNotification(`${updatedCount} ligne(s) pour '${typeNames[selectType]}' mise(s) à jour`, 'success');
    }

    setTimeout(() => {
        const globalPertinenceSelect = document.getElementById('global-pertinence-select');
        const globalAttenduSelect = document.getElementById('global-niveau-attendu-select');
        if (globalPertinenceSelect) handleGlobalPertinenceChange(globalPertinenceSelect.value);
        if (globalAttenduSelect) updateGlobalTolereOptions(globalAttenduSelect.value);
    }, 100);

  } catch(error) {
    console.error("Erreur dans updateAllSelects:", error);
  }
}

function showNotification(message, type = 'info') {
  // Créer l'élément de notification
  const notification = document.createElement('div');
  notification.className = `fixed top-4 right-4 z-50 px-4 py-2 rounded shadow-lg text-white transition-all duration-300 transform translate-x-full`;
  
  // Appliquer le style selon le type
  switch(type) {
    case 'success':
      notification.classList.add('bg-green-500');
      break;
    case 'warning':
      notification.classList.add('bg-yellow-500');
      break;
    case 'error':
      notification.classList.add('bg-red-500');
      break;
    default:
      notification.classList.add('bg-blue-500');
  }
  
  notification.textContent = message;
  document.body.appendChild(notification);
  
  // Animation d'entrée
  setTimeout(() => {
    notification.classList.remove('translate-x-full');
  }, 100);
  
  // Suppression automatique après 3 secondes
  setTimeout(() => {
    notification.classList.add('translate-x-full');
    setTimeout(() => {
      document.body.removeChild(notification);
    }, 300);
  }, 3000);
}

// Fonction pour mettre à jour l'état des selects de contrôle global
function updateGlobalSelectsState() {
  try {
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  const tabId = activeTab.id;
  const globalPrimary = document.getElementById('global-pertinence-select');
  const globalSecondary = document.getElementById('global-niveau-attendu-select');
  const globalTertiary = document.getElementById('global-niveau-tolere-select');
  
  if (!globalPrimary || !globalSecondary || !globalTertiary) return;
  
    // Activer tous les selects par défaut
    globalPrimary.disabled = false;
    globalSecondary.disabled = false;
    globalTertiary.disabled = false;
    
    globalPrimary.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
    globalSecondary.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
    globalTertiary.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
    
    // Désactiver les selects selon les conditions spécifiques
    if (tabId === 'knowledge' || tabId === 'task' || tabId === 'skill' || tabId === 'abilitie') {
      // Si aucune sélection n'est active, désactiver tous les selects
      if (selectionCounters[tabId].selected === 0) {
        globalSecondary.disabled = true;
        globalTertiary.disabled = true;
        globalSecondary.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
        globalTertiary.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-100');
      }
    }
  } catch(e) {
    console.error("Erreur updateGlobalSelectsState:", e);
  }
}

// Fonction modifiée pour observer les changements et mettre à jour l'état des selects globaux
function observeSelectChanges() {
  try {
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  // Observer tous les selects dans l'onglet actuel
  const allSelects = activeTab.querySelectorAll('select');
  allSelects.forEach(select => {
    // Supprimer l'ancien listener s'il existe
    select.removeEventListener('change', updateGlobalSelectsState);
    // Ajouter le nouveau listener
    select.addEventListener('change', updateGlobalSelectsState);
  });
  
  // Mettre à jour l'état initial
  updateGlobalSelectsState();
  } catch(e) {
    console.error("Erreur observeSelectChanges:", e);
  }
}

// Ce script s'exécute immédiatement
document.addEventListener('DOMContentLoaded', function() {
  // Attendre que la page soit complètement chargée
  setTimeout(() => {
    // Créer un tableau des onglets à activer manuellement pour forcer la mise à jour
    const tabsToForceUpdate = ['skill', 'abilitie'];
    
    // Sauvegarder l'onglet actif initial
    let activeTabButton = null;
    document.querySelectorAll('.tab-button').forEach(button => {
      if (button.classList.contains('text-blue-600')) {
        activeTabButton = button;
      }
    });
    
    // Parcourir chaque onglet à forcer
    let currentIndex = 0;
    
    function processNextTab() {
      if (currentIndex < tabsToForceUpdate.length) {
        const tabId = tabsToForceUpdate[currentIndex];
        currentIndex++;
        
        // Trouver le bouton d'onglet
        const tabButton = Array.from(document.querySelectorAll('.tab-button')).find(button => {
          return button.getAttribute('data-tab') === tabId;
        });
        
        if (tabButton) {
          console.log('Force updating tab: ' + tabId);
          tabButton.click();
          
          // Traiter le prochain onglet après un court délai
          setTimeout(processNextTab, 100);
        } else {
          processNextTab(); // Passer au suivant si l'onglet n'est pas trouvé
        }
      } else {
        // Une fois tous les onglets traités, revenir à l'onglet initial
        if (activeTabButton) {
          console.log('Returning to initial tab');
          activeTabButton.click();
          
          // Masquer l'overlay de chargement une fois tout le traitement terminé
          setTimeout(() => {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
              loadingOverlay.classList.add('hidden');
            }
          }, 500);
          
        } else {
          // Si aucun onglet actif n'a été trouvé, cliquer sur le premier
          const firstTab = document.querySelector('.tab-button');
          if (firstTab) {
            console.log('Clicking first tab as fallback');
            firstTab.click();
            
            // Masquer l'overlay de chargement
            setTimeout(() => {
              const loadingOverlay = document.getElementById('loading-overlay');
              if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
              }
            }, 500);
          } else {
            // Masquer l'overlay de chargement même si aucun onglet n'est trouvé
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) {
              loadingOverlay.classList.add('hidden');
            }
          }
        }
      }
    }
    
    // Démarrer le traitement des onglets
    processNextTab();
  }, 500);
});

// Fonction de secours pour masquer l'overlay en cas de problème
window.addEventListener('load', function() {
  // Masquer l'overlay après 20 secondes maximum quoi qu'il arrive
  setTimeout(() => {
    const loadingOverlay = document.getElementById('loading-overlay');
    if (loadingOverlay && !loadingOverlay.classList.contains('hidden')) {
      console.log('Masquage forcé de l\'overlay après délai maximum');
      loadingOverlay.classList.add('hidden');
    }
  }, 20000);
  

  
  // RESTAURATION URGENTE DES SELECTS DANS TOUTES LES CATÉGORIES
  console.log("RESTAURATION URGENTE DES SELECTS DANS TOUTES LES CATÉGORIES");
  
  // Restaurer les options pour chaque catégorie
  function restaurerOptionsSelects() {
    console.log("Début de la restauration des options pour tous les selects");
    
    // Parcourir toutes les catégories
    ['task', 'knowledge', 'skill', 'abilitie'].forEach(tabId => {
      console.log(`Restauration des options pour la catégorie ${tabId}`);
      const tab = document.getElementById(tabId);
      if (!tab) return;
      
      // Trouver tous les groupes de selects dans cette catégorie
      const selectGroups = tab.querySelectorAll('.select-group');
      console.log(`Nombre de groupes de selects trouvés dans ${tabId}: ${selectGroups.length}`);
      
      selectGroups.forEach((group, groupIndex) => {
        // Trouver tous les selects dans ce groupe
        const selects = group.querySelectorAll('select');
        console.log(`Groupe ${groupIndex}: ${selects.length} selects trouvés`);
        
        // Pour chaque select, vérifier et restaurer les options si nécessaire
        selects.forEach((select, selectIndex) => {
          // Si le select n'a pas d'options ou seulement l'option vide
          if (select.options.length <= 1) {
            console.log(`Restauration des options pour le select ${selectIndex} du groupe ${groupIndex} dans ${tabId}`);
            
            // Déterminer quelles options ajouter selon la catégorie et la position du select
            if (selectIndex === 0) {  // Premier select (pertinence)
              select.innerHTML = '';
              select.appendChild(new Option('--', ''));
              select.appendChild(new Option('0', '0'));
              select.appendChild(new Option('1', '1'));
              select.appendChild(new Option('2', '2'));
              select.appendChild(new Option('3', '3'));
            } 
            else if (selectIndex === 1) {  // Deuxième select (niveau attendu)
              select.innerHTML = '';
              select.appendChild(new Option('--', ''));
              
              if (tabId === 'task') {
                select.appendChild(new Option('B', 'B'));
                select.appendChild(new Option('S', 'S'));
                select.appendChild(new Option('M', 'M'));
              } 
              else if (tabId === 'knowledge') {
                select.appendChild(new Option('A', 'A'));
                select.appendChild(new Option('B', 'B'));
                select.appendChild(new Option('C', 'C'));
                select.appendChild(new Option('D', 'D'));
              } 
              else {  // skill et abilitie
                select.appendChild(new Option('1', '1'));
                select.appendChild(new Option('2', '2'));
                select.appendChild(new Option('3', '3'));
              }
            } 
            else if (selectIndex === 2) {  // Troisième select (niveau toléré)
              select.innerHTML = '';
              select.appendChild(new Option('--', ''));
              
              if (tabId === 'task') {
                select.appendChild(new Option('B', 'B'));
                select.appendChild(new Option('S', 'S'));
              } 
              else if (tabId === 'knowledge') {
                select.appendChild(new Option('A', 'A'));
                select.appendChild(new Option('B', 'B'));
                select.appendChild(new Option('C', 'C'));
              } 
              else {  // skill et abilitie
                select.appendChild(new Option('1', '1'));
                select.appendChild(new Option('2', '2'));
              }
            }
            
            console.log(`Options restaurées pour le select ${selectIndex}: ${select.options.length} options`);
          }
        });
      });
    });
    
         console.log("Restauration des options terminée");
   }
   
   // Exécuter la restauration immédiatement
   restaurerOptionsSelects();
   
   // Puis à nouveau après un court délai pour s'assurer que tout est bien chargé
   setTimeout(() => {
     restaurerOptionsSelects();
     
     // Mise à jour des contrôles globaux après restauration
     const activeTab = document.querySelector('.tab-button.text-blue-600');
     if (activeTab) {
       const tabId = activeTab.getAttribute('data-tab');
       console.log("Mise à jour des contrôles globaux après restauration pour:", tabId);
       updateGlobalSelectOptions(tabId);
     }
   }, 1000);
  
  // Attendre que tout soit chargé
  setTimeout(() => {
    // Remplacer le gestionnaire d'événements du select tertiaire
    const tertiaryGlobalSelect = document.getElementById('global-niveau-tolere-select');
    if (tertiaryGlobalSelect) {
      tertiaryGlobalSelect.onchange = function(e) {
        const value = this.value;
        if (value) {
          // Restaurer les options avant de mettre à jour
          restaurerOptionsSelects();
          // Puis forcer la mise à jour
          setTimeout(() => {
            forceUpdateAllTertiarySelects(value);
          }, 100);
          e.stopPropagation(); // Empêcher la propagation pour éviter que l'ancien gestionnaire s'exécute
        }
      };
      console.log("Nouveau gestionnaire d'événements installé pour le contrôle tertiaire");
    }
  }, 1500);
});

// Fonction pour forcer la mise à jour de tous les selects tertiaires
function forceUpdateAllTertiarySelects(value) {
  console.log("FORÇAGE de mise à jour des selects tertiaires avec la valeur:", value);
  
  // Obtenir l'onglet actif
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  const tabId = activeTab.id;
  console.log("Onglet actif:", tabId);
  
  // S'assurer que les options sont correctes pour la valeur sélectionnée
  let optionsValides = [];
  if (tabId === 'task') {
    optionsValides = ['B', 'S'];
  } else if (tabId === 'knowledge') {
    optionsValides = ['A', 'B', 'C'];
  } else { // skill et abilitie
    optionsValides = ['1', '2'];
  }
  
  // Vérifier si la valeur est valide pour cette catégorie
  if (!optionsValides.includes(value)) {
    console.warn(`La valeur ${value} n'est pas valide pour la catégorie ${tabId}. Options valides: ${optionsValides.join(', ')}`);
    showNotification(`La valeur ${value} n'est pas compatible avec la catégorie ${tabId}`, 'warning');
    return;
  }
  
  // Trouver tous les groupes de selects
  const selectGroups = activeTab.querySelectorAll('.select-group');
  console.log(`Nombre de groupes trouvés: ${selectGroups.length}`);
  
  // Compter les succès
  let successCount = 0;
  
  // Pour chaque groupe
  selectGroups.forEach((group, index) => {
    // Trouver tous les selects dans ce groupe
    const selects = group.querySelectorAll('select');
    
    // S'il y a au moins 3 selects (ou au moins 2 pour être sûr)
    if (selects.length >= 2) {
      // Prendre le dernier select
      const lastSelectIndex = selects.length - 1;
      const tertiarySelect = selects[lastSelectIndex];
      
      if (tertiarySelect) {
        console.log(`Groupe ${index}: Modification du select tertiaire (index ${lastSelectIndex})`, tertiarySelect);
        
        // Sauvegarder l'état actuel
        const wasDisabled = tertiarySelect.disabled;
        const oldValue = tertiarySelect.value;
        
        try {
          // Activer le select s'il est désactivé
          if (wasDisabled) {
            tertiarySelect.disabled = false;
          }
          
          // S'assurer que le select a les bonnes options
          if (tertiarySelect.options.length <= 1) {
            console.log("Le select n'a pas d'options, ajout des options");
            tertiarySelect.innerHTML = '';
            tertiarySelect.appendChild(new Option('--', ''));
            
            // Ajouter les options selon la catégorie
            if (tabId === 'task') {
              tertiarySelect.appendChild(new Option('B', 'B'));
              tertiarySelect.appendChild(new Option('S', 'S'));
            } else if (tabId === 'knowledge') {
              tertiarySelect.appendChild(new Option('A', 'A'));
              tertiarySelect.appendChild(new Option('B', 'B'));
              tertiarySelect.appendChild(new Option('C', 'C'));
            } else { // skill et abilitie
              tertiarySelect.appendChild(new Option('1', '1'));
              tertiarySelect.appendChild(new Option('2', '2'));
            }
          }
          
          // Vérifier si la valeur existe dans les options
          const valueExists = Array.from(tertiarySelect.options).some(opt => opt.value === value);
          
          if (valueExists) {
            // Appliquer la valeur
            tertiarySelect.value = value;
            
            // Créer et dispatcher un événement change
            const changeEvent = new Event('change', { bubbles: true });
            tertiarySelect.dispatchEvent(changeEvent);
            
            // Incrémenter le compteur de succès
            successCount++;
            
            // Restaurer l'état désactivé si nécessaire après un court délai
            if (wasDisabled) {
              setTimeout(() => {
                tertiarySelect.disabled = true;
              }, 100);
            }
            
            console.log(`Succès! Valeur modifiée de ${oldValue} à ${value}`);
          } else {
            console.error(`La valeur ${value} n'existe pas dans ce select. Options disponibles:`, 
                         Array.from(tertiarySelect.options).map(o => o.value));
            
                         // Ajouter l'option manquante
             if (optionsValides.includes(value)) {
               console.log(`Ajout de l'option manquante ${value}`);
               tertiarySelect.appendChild(new Option(value, value));
               tertiarySelect.value = value;
               successCount++;
             }
          }
        } catch (err) {
          console.error("Erreur lors de la modification:", err);
        }
      }
    }
  });
  
  // Afficher une notification avec le nombre de selects modifiés
  showNotification(`${successCount} contrôles de niveau toléré (T) mis à jour avec succès`, 'success');
}

// Fonction pour mettre à jour les options des contrôles globaux en fonction de la catégorie active
function updateGlobalSelectOptions(tabId) {
  try {
    console.log("Mise à jour des contrôles globaux pour l'onglet:", tabId);
    const activeTab = document.getElementById(tabId);
    if (!activeTab) return;
    
    const globalSecondary = document.getElementById('global-niveau-attendu-select');
    const globalTertiary = document.getElementById('global-niveau-tolere-select');
    
    if (!globalSecondary || !globalTertiary) {
      console.error("Contrôles globaux non trouvés");
      return;
    }
    
    // Sauvegarde des valeurs actuelles
    const secondaryValue = globalSecondary.value;
    const tertiaryValue = globalTertiary.value;
    
    console.log(`Valeurs actuelles avant mise à jour: A=${secondaryValue}, T=${tertiaryValue}`);
    
    // Réinitialiser les options
    globalSecondary.innerHTML = '<option value="">--</option>';
    globalTertiary.innerHTML = '<option value="">--</option>';
    
    // Ajouter les options selon la catégorie active
    if (tabId === 'task') {
      console.log("Configuration des options pour Task");
      // Options pour Task (B, S, M)
      globalSecondary.innerHTML += '<option value="B" title="Basic">B</option>';
      globalSecondary.innerHTML += '<option value="S" title="Senior">S</option>';
      globalSecondary.innerHTML += '<option value="M" title="Master">M</option>';
      
      // Pour le contrôle T (niveau toléré), on ne met que B et S (pas M car logiquement on ne tolère pas un niveau supérieur)
      globalTertiary.innerHTML += '<option value="B" title="Basic">B</option>';
      globalTertiary.innerHTML += '<option value="S" title="Senior">S</option>';
    } 
    else if (tabId === 'knowledge') {
      console.log("Configuration des options pour Knowledge");
      // Options pour Knowledge (A, B, C, D)
      globalSecondary.innerHTML += '<option value="A" title="Level A">A</option>';
      globalSecondary.innerHTML += '<option value="B" title="Level B">B</option>';
      globalSecondary.innerHTML += '<option value="C" title="Level C">C</option>';
      globalSecondary.innerHTML += '<option value="D" title="Level D">D</option>';
      
      // Pour le contrôle T (niveau toléré), on ne met que A, B, C (pas D car logiquement on ne tolère pas un niveau supérieur)
      globalTertiary.innerHTML += '<option value="A" title="Level A">A</option>';
      globalTertiary.innerHTML += '<option value="B" title="Level B">B</option>';
      globalTertiary.innerHTML += '<option value="C" title="Level C">C</option>';
    }
    else {
      console.log(`Configuration des options pour ${tabId} (Skill/Ability)`);
      // Options pour Skill et Ability (1, 2, 3)
      globalSecondary.innerHTML += '<option value="1" title="Level 1">1</option>';
      globalSecondary.innerHTML += '<option value="2" title="Level 2">2</option>';
      globalSecondary.innerHTML += '<option value="3" title="Level 3">3</option>';
      
      // Pour le contrôle T (niveau toléré), on ne met que 1, 2 (pas 3 car logiquement on ne tolère pas un niveau supérieur)
      globalTertiary.innerHTML += '<option value="1" title="Level 1">1</option>';
      globalTertiary.innerHTML += '<option value="2" title="Level 2">2</option>';
    }
    
    // Forcer un rafraîchissement visuel des selects
    globalSecondary.style.display = 'none';
    globalTertiary.style.display = 'none';
    
    // Petit délai pour permettre le re-rendu
    setTimeout(() => {
      globalSecondary.style.display = '';
      globalTertiary.style.display = '';
      
      console.log(`Options mises à jour pour ${tabId}:`);
      console.log(`- Global A (niveau attendu): ${globalSecondary.options.length} options`);
      console.log(`- Global T (niveau toléré): ${globalTertiary.options.length} options`);
      
      // Restaurer les valeurs si elles sont compatibles avec la nouvelle catégorie
      if (secondaryValue) {
        const secondaryOption = Array.from(globalSecondary.options).find(opt => opt.value === secondaryValue);
        if (secondaryOption) {
          globalSecondary.value = secondaryValue;
          console.log(`Valeur A restaurée: ${secondaryValue}`);
        } else {
          console.log(`Valeur A ${secondaryValue} non compatible avec ${tabId}, réinitialisée`);
        }
      }
      
      if (tertiaryValue) {
        const tertiaryOption = Array.from(globalTertiary.options).find(opt => opt.value === tertiaryValue);
        if (tertiaryOption) {
          globalTertiary.value = tertiaryValue;
          console.log(`Valeur T restaurée: ${tertiaryValue}`);
        } else {
          console.log(`Valeur T ${tertiaryValue} non compatible avec ${tabId}, réinitialisée`);
        }
      }
    }, 50);
    
  } catch (error) {
    console.error("Erreur lors de la mise à jour des contrôles globaux:", error);
  }
}

// Fonction pour montrer un infobulle sur les options des selects
function showInfoTooltip(select) {
  // Cette fonction existe uniquement pour compatibilité avec les attributs onclick existants
  // Elle n'a pas besoin d'implémentation
}

// Fonction pour restaurer l'état des contrôles globaux au chargement
function restoreGlobalControlsState() {
  const container = document.getElementById('global-controls-container');
  if (container) {
    const isHidden = localStorage.getItem('globalControlsHidden') === 'true';
    if (isHidden) {
      container.classList.add('hidden');
      const toggleButton = container.querySelector('button[onclick="toggleGlobalControls()"]');
      if (toggleButton) {
        toggleButton.textContent = '◀';
        toggleButton.title = 'Afficher les contrôles';
      }
    }
  }
}

// Fonction pour forcer l'apparition des options dans les selects tertiaires
function ensureTertiarySelectOptions() {
  console.log("Forçage de l'apparition des options dans les selects tertiaires");
  
  // Obtenir l'onglet actif
  const activeTab = document.querySelector('.tab-content:not(.hidden)');
  if (!activeTab) return;
  
  const tabId = activeTab.id;
  console.log("Onglet actif:", tabId);
  
  // Trouver tous les groupes de selects
  const selectGroups = activeTab.querySelectorAll('.select-group');
  console.log(`Nombre de groupes trouvés: ${selectGroups.length}`);
  
  // Pour chaque groupe
  selectGroups.forEach((group, index) => {
    // Trouver tous les selects dans ce groupe
    const selects = group.querySelectorAll('select');
    
    // S'il y a au moins 2 selects
    if (selects.length >= 2) {
      // Récupérer les références aux selects
      const primarySelect = selects[0];  // Premier select (pertinence)
      const secondarySelect = selects.length >= 2 ? selects[1] : null;  // Deuxième select (niveau attendu)
      const tertiarySelect = selects.length >= 3 ? selects[2] : null;  // Troisième select (niveau toléré)
      
      if (!tertiarySelect) {
        console.log(`Groupe ${index}: Pas de select tertiaire trouvé`);
        return;
      }
      
      console.log(`Groupe ${index}: Analyse du select tertiaire`, tertiarySelect);
      
      // Si le select tertiaire n'a pas d'options ou est désactivé
      if (tertiarySelect.options.length <= 1 || tertiarySelect.disabled) {
        console.log(`Groupe ${index}: Le select tertiaire n'a pas d'options ou est désactivé`);
        
        // Activer temporairement
        tertiarySelect.disabled = false;
        
        // Ajouter des options selon le type d'onglet
        if (tabId === 'task') {
          // Pour Task, ajouter les options B, S, M
          addOptionsToSelect(tertiarySelect, [
            { value: 'B', text: 'B', title: 'Basic' },
            { value: 'S', text: 'S', title: 'Senior' },
            { value: 'M', text: 'M', title: 'Master' }
          ]);
        } else if (tabId === 'knowledge') {
          // Pour Knowledge, ajouter les options A, B, C, D
          addOptionsToSelect(tertiarySelect, [
            { value: 'A', text: 'A', title: 'Level A' },
            { value: 'B', text: 'B', title: 'Level B' },
            { value: 'C', text: 'C', title: 'Level C' },
            { value: 'D', text: 'D', title: 'Level D' }
          ]);
        } else {
          // Pour Skill et Ability, ajouter les options 1, 2, 3
          addOptionsToSelect(tertiarySelect, [
            { value: '1', text: '1', title: 'Level 1' },
            { value: '2', text: '2', title: 'Level 2' },
            { value: '3', text: '3', title: 'Level 3' }
          ]);
        }
        

        
        // Si le select secondaire a une valeur, ajuster les options du tertiaire
        if (secondarySelect && secondarySelect.value) {
          console.log(`Ajustement des options selon la valeur du select secondaire: ${secondarySelect.value}`);
          
          if (tabId === 'task') {
            // Logique spécifique pour Task
            if (secondarySelect.value === 'B') {
              // Si B est sélectionné, désactiver le tertiaire
              tertiarySelect.disabled = true;
            } else if (secondarySelect.value === 'S') {
              // Si S est sélectionné, n'autoriser que B
              clearSelectExcept(tertiarySelect, ['B']);
            } else if (secondarySelect.value === 'M') {
              // Si M est sélectionné, autoriser B et S
              clearSelectExcept(tertiarySelect, ['B', 'S']);
            }
          } else if (tabId === 'knowledge') {
            // Logique spécifique pour Knowledge
            if (secondarySelect.value === 'A') {
              // Si A est sélectionné, désactiver le tertiaire
              tertiarySelect.disabled = true;
            } else if (secondarySelect.value === 'B') {
              // Si B est sélectionné, n'autoriser que A
              clearSelectExcept(tertiarySelect, ['A']);
            } else if (secondarySelect.value === 'C') {
              // Si C est sélectionné, autoriser A et B
              clearSelectExcept(tertiarySelect, ['A', 'B']);
            } else if (secondarySelect.value === 'D') {
              // Si D est sélectionné, autoriser A, B et C
              clearSelectExcept(tertiarySelect, ['A', 'B', 'C']);
            }
          } else {
            // Logique pour Skill et Ability
            if (secondarySelect.value === '1') {
              // Si 1 est sélectionné, désactiver le tertiaire
              tertiarySelect.disabled = true;
            } else if (secondarySelect.value === '2') {
              // Si 2 est sélectionné, n'autoriser que 1
              clearSelectExcept(tertiarySelect, ['1']);
            } else if (secondarySelect.value === '3') {
              // Si 3 est sélectionné, autoriser 1 et 2
              clearSelectExcept(tertiarySelect, ['1', '2']);
            }
          }
        }
        

      }
    }
  });
  
  console.log("Fin du forçage de l'apparition des options dans les selects tertiaires");
}

// Fonction utilitaire pour ajouter des options à un select
function addOptionsToSelect(select, options) {
  // Vider le select sauf la première option vide si elle existe
  if (select.options.length > 0 && select.options[0].value === '') {
    while (select.options.length > 1) {
      select.remove(1);
    }
  } else {
    select.innerHTML = '';
    
    // Ajouter une option vide au début
    const emptyOption = document.createElement('option');
    emptyOption.value = '';
    emptyOption.text = '--';
    select.appendChild(emptyOption);
  }
  
  // Ajouter les nouvelles options
  options.forEach(option => {
    const opt = document.createElement('option');
    opt.value = option.value;
    opt.text = option.text || option.value;
    if (option.title) opt.title = option.title;
    select.appendChild(opt);
  });
  
  console.log(`Options ajoutées au select. Nombre d'options: ${select.options.length}`);
}

// Fonction utilitaire pour ne conserver que certaines options
function clearSelectExcept(select, valuesToKeep) {
  // Convertir les options actuelles en tableau
  const options = Array.from(select.options);
  
  // Vider le select
  select.innerHTML = '';
  
  // Ajouter d'abord l'option vide si elle existait
  const emptyOption = options.find(opt => opt.value === '');
  if (emptyOption) {
    select.appendChild(emptyOption);
  }
  
  // Réajouter uniquement les options à conserver
  options.forEach(option => {
    if (valuesToKeep.includes(option.value)) {
      select.appendChild(option);
    }
  });
  
  console.log(`Select filtré. Options conservées: ${valuesToKeep.join(', ')}. Nombre d'options: ${select.options.length}`);
}

// Appeler cette fonction lorsqu'on change d'onglet ou lorsqu'on utilise le contrôle global T
document.addEventListener('DOMContentLoaded', function() {
  // Attendre que tout soit chargé
  setTimeout(() => {
    console.log("Initialisation des selects dans tous les onglets");
    
    // Trouver tous les onglets et s'assurer que les selects sont correctement configurés dans chacun
    ['task', 'knowledge', 'skill', 'abilitie'].forEach(tabId => {
      const tabContent = document.getElementById(tabId);
      if (tabContent) {
        console.log(`Configuration des selects dans l'onglet ${tabId}`);
        
        // Pour chaque groupe de selects dans cet onglet
        const selectGroups = tabContent.querySelectorAll('.select-group');
        selectGroups.forEach((group, groupIndex) => {
          const selects = group.querySelectorAll('select');
          
          // S'il y a moins de 3 selects, vérifier pourquoi et recréer si nécessaire
          if (selects.length < 3) {
            console.warn(`Groupe ${groupIndex} dans ${tabId}: seulement ${selects.length} selects trouvés, vérification...`);
          }
          
          // Pour chaque select, s'assurer qu'il a des options
          selects.forEach((select, selectIndex) => {
            // Si le select n'a pas d'options ou seulement l'option vide
            if (select.options.length <= 1) {
              console.warn(`Select ${selectIndex} dans groupe ${groupIndex} de ${tabId} n'a pas d'options, ajout...`);
              
              // Ajouter les options appropriées selon le type d'onglet et la position du select
              if (selectIndex === 0) {  // Premier select (pertinence) - même pour tous les onglets
                addOptionsToSelect(select, [
                  { value: '0', text: '0', title: "Non pertinent" },
                  { value: '1', text: '1', title: "Critique (Must have)" },
                  { value: '2', text: '2', title: "Important (Rapidement acquis)" },
                  { value: '3', text: '3', title: "Secondaire (Complémentaire)" }
                ]);
              } else if (selectIndex === 1) {  // Deuxième select (niveau attendu)
                if (tabId === 'task') {
                  addOptionsToSelect(select, [
                    { value: 'B', text: 'B', title: "Basic" },
                    { value: 'S', text: 'S', title: "Senior" },
                    { value: 'M', text: 'M', title: "Master" }
                  ]);
                } else if (tabId === 'knowledge') {
                  addOptionsToSelect(select, [
                    { value: 'A', text: 'A', title: "Level A" },
                    { value: 'B', text: 'B', title: "Level B" },
                    { value: 'C', text: 'C', title: "Level C" },
                    { value: 'D', text: 'D', title: "Level D" }
                  ]);
                } else {  // skill et abilitie
                  addOptionsToSelect(select, [
                    { value: '1', text: '1', title: "Level 1" },
                    { value: '2', text: '2', title: "Level 2" },
                    { value: '3', text: '3', title: "Level 3" }
                  ]);
                }
              } else if (selectIndex === 2) {  // Troisième select (niveau toléré)
                if (tabId === 'task') {
                  addOptionsToSelect(select, [
                    { value: 'B', text: 'B', title: "Basic" },
                    { value: 'S', text: 'S', title: "Senior" }
                    // M n'est pas inclus car logiquement on ne tolère pas un niveau supérieur à celui attendu
                  ]);
                } else if (tabId === 'knowledge') {
                  addOptionsToSelect(select, [
                    { value: 'A', text: 'A', title: "Level A" },
                    { value: 'B', text: 'B', title: "Level B" },
                    { value: 'C', text: 'C', title: "Level C" }
                    // D n'est pas inclus car logiquement on ne tolère pas un niveau supérieur à celui attendu
                  ]);
                } else {  // skill et abilitie
                  addOptionsToSelect(select, [
                    { value: '1', text: '1', title: "Level 1" },
                    { value: '2', text: '2', title: "Level 2" }
                    // 3 n'est pas inclus car logiquement on ne tolère pas un niveau supérieur à celui attendu
                  ]);
                }
              }
            }
          });
        });
      }
    });
    
    // Trouver le select de contrôle tertiaire
    const tertiaryGlobalSelect = document.getElementById('global-niveau-tolere-select');
    if (tertiaryGlobalSelect) {
      tertiaryGlobalSelect.onchange = function(e) {
        const value = this.value;
        if (value) {
          // D'abord s'assurer que les options existent
          ensureTertiarySelectOptions();
          // Puis forcer la mise à jour
          setTimeout(() => {
            forceUpdateAllTertiarySelects(value);
          }, 100);
          e.stopPropagation();
        }
      };
      console.log("Nouveau gestionnaire d'événements installé pour le contrôle tertiaire");
    }
    
    // Trouver tous les boutons d'onglet
    const tabButtons = document.querySelectorAll('.tab-button');
    tabButtons.forEach(button => {
      // Ajouter un gestionnaire d'événements pour le clic
      const originalClickHandler = button.onclick;
      button.onclick = function(e) {
        // Appeler le gestionnaire d'origine
        if (originalClickHandler) {
          originalClickHandler.call(this, e);
        }
        
        // Attendre que l'onglet soit changé
        setTimeout(() => {
          // Forcer l'apparition des options
          ensureTertiarySelectOptions();
        }, 200);
      };
    });
  }, 1000); // Attendre 1 seconde pour être sûr que tout est chargé
});

// Gère la logique de dépendance pour les contrôles globaux
function handleGlobalPertinenceChange(value) {
    const globalAttenduSelect = document.getElementById('global-niveau-attendu-select');
    const globalTolereSelect = document.getElementById('global-niveau-tolere-select');

    if (!globalAttenduSelect || !globalTolereSelect) return;

    // Règle 1: Si P=0, tout désactiver
    if (value === '0') {
        globalAttenduSelect.disabled = true;
        globalTolereSelect.disabled = true;
        globalAttenduSelect.value = '';
        globalTolereSelect.value = '';
        globalAttenduSelect.classList.add('opacity-50', 'bg-gray-200');
        globalTolereSelect.classList.add('opacity-50', 'bg-gray-200');
        return;
    }

    // Si P > 0, on active toujours A
    globalAttenduSelect.disabled = false;
    globalAttenduSelect.classList.remove('opacity-50', 'bg-gray-200');

    // Règle 2: T n'est activé que si P = 2
    const isTolereEnabled = value === '2';
    globalTolereSelect.disabled = !isTolereEnabled;

    if (isTolereEnabled) {
        globalTolereSelect.classList.remove('opacity-50', 'bg-gray-200');
    } else {
        globalTolereSelect.value = '';
        globalTolereSelect.classList.add('opacity-50', 'bg-gray-200');
    }
}

function updateGlobalTolereOptions(selectedValue) {
    const globalTolereSelect = document.getElementById('global-niveau-tolere-select');
    if (!globalTolereSelect) return;

    const activeTab = document.querySelector('.tab-content:not(.hidden)');
    if (!activeTab) return;
    const tabId = activeTab.id;

    const hierarchies = {
        task: ['B', 'S', 'M'],
        knowledge: ['A', 'B', 'C', 'D'],
        skill: ['1', '2', '3'],
        abilitie: ['1', '2', '3']
    };

    const hierarchy = hierarchies[tabId];
    if (!hierarchy) return;

    const selectedIndex = hierarchy.indexOf(selectedValue);

    if (selectedValue === '' || selectedIndex === -1) {
        Array.from(globalTolereSelect.options).forEach(opt => { opt.disabled = false; });
        return;
    }

    Array.from(globalTolereSelect.options).forEach(opt => {
        if (opt.value === '') {
            opt.disabled = false;
            return;
        }
        const optionIndex = hierarchy.indexOf(opt.value);
        opt.disabled = optionIndex !== -1 && optionIndex > selectedIndex;
    });

    const currentTolereValue = globalTolereSelect.value;
    const currentTolereIndexInHierarchy = hierarchy.indexOf(currentTolereValue);
    if (currentTolereValue !== '' && (currentTolereIndexInHierarchy === -1 || currentTolereIndexInHierarchy > selectedIndex)) {
        globalTolereSelect.value = '';
    }
}

// ...
// Dans le DOMContentLoaded principal, restaurer au tout début :
document.addEventListener("DOMContentLoaded", () => {
  restoreGlobalControlsFromLocalStorage();
  // ...
  // (le reste du code d'initialisation existant)

  // Ajouter l'appel à saveGlobalControlsToLocalStorage sur chaque select global :
  document.getElementById('global-pertinence-select')?.addEventListener('change', saveGlobalControlsToLocalStorage);
  document.getElementById('global-niveau-attendu-select')?.addEventListener('change', saveGlobalControlsToLocalStorage);
  document.getElementById('global-niveau-tolere-select')?.addEventListener('change', saveGlobalControlsToLocalStorage);
});

// --- NOUVELLE FONCTION DE RESTAURATION AU CHARGEMENT ---
function restoreStateOnLoad() {
    // Essayer d'abord avec serverStorage, puis fallback vers localStorage
    Promise.resolve(serverStorage.getItem('currentOpeningSelection'))
        .then(explicitLoadDataJSON => {
            // Si serverStorage retourne null, essayer localStorage directement
            if (!explicitLoadDataJSON) {
                explicitLoadDataJSON = localStorage.getItem('currentOpeningSelection');
            }
            
            const sessionStateJSON = sessionStorage.getItem('ksatLastSavedState');
            let dataToRestoreJSON = null;

            if (explicitLoadDataJSON) {
                console.log("Chargement d'une sélection explicite...");
                dataToRestoreJSON = explicitLoadDataJSON;
                serverStorage.removeItem('currentOpeningSelection'); // Utiliser une seule fois
                localStorage.removeItem('currentOpeningSelection'); // Nettoyer aussi localStorage
                sessionStorage.setItem('ksatLastSavedState', dataToRestoreJSON); // Devient le nouvel état de session
            } else if (sessionStateJSON) {
                console.log("Restauration de l'état de la session (F5)...");
                dataToRestoreJSON = sessionStateJSON;
            }

            if (dataToRestoreJSON) {
                const restoreData = typeof dataToRestoreJSON === 'string' ? JSON.parse(dataToRestoreJSON) : dataToRestoreJSON;
                // Restaurer allSelectValues si présent
                if (restoreData.allSelectValues) {
                    Object.keys(restoreData.allSelectValues).forEach(category => {
                        allSelectValues[category] = restoreData.allSelectValues[category];
                    });
                }
                performRestoration(restoreData);
            } else {
                console.log("Aucun état à restaurer.");
            }
        })
        .catch(error => {
            console.error("Erreur lors de la récupération de la sélection à charger:", error);
            // Fallback vers localStorage
            const localStorageData = localStorage.getItem('currentOpeningSelection');
            const sessionStateJSON = sessionStorage.getItem('ksatLastSavedState');
            
            if (localStorageData) {
                console.log("Restauration depuis localStorage (fallback)...");
                const restoreData = JSON.parse(localStorageData);
                if (restoreData.allSelectValues) {
                    Object.keys(restoreData.allSelectValues).forEach(category => {
                        allSelectValues[category] = restoreData.allSelectValues[category];
                    });
                }
                performRestoration(restoreData);
                localStorage.removeItem('currentOpeningSelection');
            } else if (sessionStateJSON) {
                console.log("Restauration de l'état de session (F5) en fallback...");
                const restoreData = JSON.parse(sessionStateJSON);
                // Restaurer allSelectValues si présent
                if (restoreData.allSelectValues) {
                    Object.keys(restoreData.allSelectValues).forEach(category => {
                        allSelectValues[category] = restoreData.allSelectValues[category];
                    });
                }
                performRestoration(restoreData);
            }
        });
}

function performRestoration(data) {
    try {
        console.log("Restauration en cours avec les données:", data);

        // ÉTAPE 1: Restaurer l'onglet actif et les valeurs des selects
        // Activer l'onglet sans déclencher tous les effets de bord de .click()
        if (data.activeTab) {
            const tabButton = document.querySelector(`[data-tab="${data.activeTab}"]`);
            if (tabButton) {
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove("border-blue-500", "text-blue-600"));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.add("hidden"));
                tabButton.classList.add("border-blue-500", "text-blue-600");
                const tabContent = document.getElementById(data.activeTab);
                if (tabContent) tabContent.classList.remove("hidden");
                currentActiveTab = data.activeTab;
                updateGlobalSelectOptions(data.activeTab);
            }
        }
        
        // Restaurer les valeurs des contrôles globaux
        if (data.globalControls) {
            const p = document.getElementById('global-pertinence-select');
            const a = document.getElementById('global-niveau-attendu-select');
            const t = document.getElementById('global-niveau-tolere-select');
            if (p) p.value = data.globalControls.pertinence || '';
            if (a) a.value = data.globalControls.attendu || '';
            if (t) t.value = data.globalControls.tolere || '';
        }

        // Restaurer les valeurs de tous les selects ligne par ligne
        if (data.selectValues) {
            Object.entries(data.selectValues).forEach(([key, value]) => {
                const parts = key.split('_');
                if (parts.length !== 3) return;

                const [tabId, rowIndex, selectIndex] = parts;

                const tab = document.getElementById(tabId);
                if (!tab) return;

                const rows = tab.querySelectorAll('tbody tr');
                if (rows.length <= rowIndex) return;
                const row = rows[rowIndex];

                const selects = row.querySelectorAll('.select-group select');
                if (selects.length <= selectIndex) return;
                
                const select = selects[selectIndex];
                if (select) {
                    select.value = value;
                }
            });
        }

        // ÉTAPE 2: Appliquer l'état visuel (ex: disabled) basé sur les valeurs restaurées
        document.querySelectorAll('.tab-content').forEach(tabContent => {
            const tabId = tabContent.id;
            tabContent.querySelectorAll('tbody tr').forEach(row => {
                updateRowVisualState(row, tabId);
            });
        });
        
        // Appliquer aussi la logique pour les contrôles globaux
        const globalPertinenceSelect = document.getElementById('global-pertinence-select');
        if (globalPertinenceSelect) {
            handleGlobalPertinenceChange(globalPertinenceSelect.value);
        }

        // Restaurer allSelectValues et les checkboxes
        if (data.allSelectValues) {
            // Restaurer allSelectValues
            Object.keys(data.allSelectValues).forEach(category => {
                allSelectValues[category] = data.allSelectValues[category];
            });
            
            // Restaurer les checkboxes avec un délai pour s'assurer que le DOM est prêt
            setTimeout(() => {
                restoreCheckboxesFromAllSelectValues();
                // Mettre à jour les compteurs après la restauration des checkboxes
                initializeSelectionCounters();
                // Mettre à jour les compteurs pour chaque onglet
                ['task', 'knowledge', 'skill', 'abilitie'].forEach(category => {
                    updateSelectionCountersForTab(category);
                });
            }, 100);
        } else {
            // ÉTAPE 3: Mettre à jour les compteurs si pas de restauration de checkboxes
            initializeSelectionCounters();
        }

        // ÉTAPE 4: Attacher les listeners de sauvegarde de session
        document.querySelectorAll('#global-pertinence-select, #global-niveau-attendu-select, #global-niveau-tolere-select').forEach(el => {
            el.addEventListener('change', saveStateToSession);
        });
        document.getElementById('tab-contents').addEventListener('change', (event) => {
            if (event.target.tagName === 'SELECT') {
                saveStateToSession();
            }
        });
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => setTimeout(saveStateToSession, 50));
        });

        console.log("Restauration de l'état terminée.");
    } catch (e) {
        console.error("Erreur lors de la restauration de l'état.", e);
    }
}

function updateRowVisualState(row, tabId) {
    const primarySelect = row.querySelector('.primary-select');
    const secondarySelects = Array.from(row.querySelectorAll('.secondary-select'));
    const select2 = secondarySelects[0];
    const select3 = secondarySelects[1];

    if (!primarySelect || !select2 || !select3) return;

    // Règle 1: Basé sur la Pertinence (P)
    const isP0 = primarySelect.value === '0';
    select2.disabled = isP0;
    
    // Par défaut, T est désactivé et sera activé par la suite si les conditions sont remplies
    select3.disabled = true;

    if (isP0) return; // Si P=0, on s'arrête ici, A et T sont désactivés.

    // Règle 2: T (select3) ne peut être activé que si P (primarySelect) est '2'
    if (primarySelect.value === '2') {
        select3.disabled = false;
    }

    // Règle 3: Désactivation supplémentaire de T (select3) basée sur A (select2), seulement si T n'est pas déjà désactivé.
    if (!select3.disabled) {
        const valueA = select2.value;
        if ((tabId === 'task' && valueA === 'B') ||
            ((tabId === 'skill' || tabId === 'abilitie') && valueA === '1') ||
            (tabId === 'knowledge' && valueA === 'A')) {
            select3.disabled = true;
        }
    }
}

// ...
// Dans DOMContentLoaded, remplacer l'appel à loadSavedSelectionIfNeeded
// par la nouvelle fonction.
document.addEventListener("DOMContentLoaded", function() {
  // ...
  restoreStateOnLoad();
  // ...
});
// ...

// -- LOGIQUE DE PERSISTANCE DES CONTROLES GLOBAUX AU F5 --

function saveGlobalControlsState() {
    const data = {
        pertinence: document.getElementById('global-pertinence-select')?.value || '',
        attendu: document.getElementById('global-niveau-attendu-select')?.value || '',
        tolere: document.getElementById('global-niveau-tolere-select')?.value || ''
    };
    localStorage.setItem('ksatGlobalControlsState', JSON.stringify(data));
}

function restoreGlobalControlsState() {
    try {
        const dataJSON = localStorage.getItem('ksatGlobalControlsState');
        if (!dataJSON) return;
        
        const data = JSON.parse(dataJSON);
        const p = document.getElementById('global-pertinence-select');
        const a = document.getElementById('global-niveau-attendu-select');
        const t = document.getElementById('global-niveau-tolere-select');

        if (p) p.value = data.pertinence || '';
        if (a) a.value = data.attendu || '';
        if (t) t.value = data.tolere || '';

        // Appliquer la logique de dépendance après restauration
        if (p) {
            handleGlobalPertinenceChange(p.value);
        }
        if (a) {
            updateGlobalTolereOptions(a.value);
        }
    } catch (e) {
        console.error("Erreur de restauration des contrôles globaux:", e);
    }
}


// ... (dans DOMContentLoaded)
document.addEventListener('DOMContentLoaded', function() {
    // Restaurer l'état des contrôles globaux en premier
    restoreGlobalControlsState();

    // Lancer la restauration de la sauvegarde principale (si elle existe)
    restoreStateOnLoad();

    // Attacher les listeners pour la sauvegarde automatique des contrôles globaux
    document.getElementById('global-pertinence-select')?.addEventListener('change', saveGlobalControlsState);
    document.getElementById('global-niveau-attendu-select')?.addEventListener('change', saveGlobalControlsState);
    document.getElementById('global-niveau-tolere-select')?.addEventListener('change', saveGlobalControlsState);

    // ... (reste du code)
});
// ... (fin du script)

// --- Logique de persistance de session (F5) ---

function saveStateToSession() {
    if (document.getElementById('loading-overlay')?.classList.contains('hidden') === false) {
        return; // Ne pas sauvegarder pendant le chargement initial
    }
    const state = {
        activeTab: currentActiveTab,
        globalControls: {
            pertinence: document.getElementById('global-pertinence-select')?.value || '',
            attendu: document.getElementById('global-niveau-attendu-select')?.value || '',
            tolere: document.getElementById('global-niveau-tolere-select')?.value || ''
        },
        selectValues: {},
        allSelectValues: allSelectValues  // Sauvegarder les valeurs des checkboxes
    };

    document.querySelectorAll('.tab-content').forEach(tab => {
        const tabId = tab.id;
        tab.querySelectorAll('tbody tr').forEach((row, rowIndex) => {
            row.querySelectorAll('.select-group select').forEach((select, selectIndex) => {
                const key = `${tabId}_${rowIndex}_${selectIndex}`;
                state.selectValues[key] = select.value;
            });
        });
    });

    sessionStorage.setItem('ksatFullPageState', JSON.stringify(state));
    console.log("État de la page (avec index) sauvegardé pour la session.");
}

// ... (dans performRestoration)
// ÉTAPE 4: Mettre à jour les compteurs et attacher les listeners de sauvegarde de session
initializeSelectionCounters();

// Attacher les listeners après que la restauration soit terminée pour éviter de sauvegarder pendant le processus
document.querySelectorAll('#global-pertinence-select, #global-niveau-attendu-select, #global-niveau-tolere-select').forEach(el => {
    el.addEventListener('change', saveStateToSession);
});
document.getElementById('tab-contents').addEventListener('change', (event) => {
    if (event.target.tagName === 'SELECT') {
        saveStateToSession();
    }
});
document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => setTimeout(saveStateToSession, 50));
});

console.log("Restauration de l'état terminée.");


// Fonction pour initialiser toutes les checkboxes comme cochées par défaut
function initializeDefaultCheckboxes() {
    const categories = ['task', 'knowledge', 'skill', 'abilitie'];
    
    categories.forEach(category => {
        const tabContent = document.getElementById(category);
        if (!tabContent) return;
        
        // Initialiser allSelectValues pour cette catégorie
        if (!allSelectValues[category]) {
            allSelectValues[category] = {};
        }
        
        // Trouver toutes les checkboxes de KSAT dans cette catégorie
        const checkboxes = tabContent.querySelectorAll('.ksat-checkbox[data-category="' + category + '"]');
        
        // Cocher toutes les checkboxes et initialiser allSelectValues
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
            const ksatId = checkbox.getAttribute('data-ksat-id');
            
            // Initialiser la sélection (équivalent à "1")
            allSelectValues[category][ksatId] = {
                primary: '1',
                secondary: '',
                tertiary: ''
            };
        });
        
        // Cocher la checkbox "Check All"
        const checkAllCheckbox = document.getElementById('check-all-' + category);
        if (checkAllCheckbox) {
            checkAllCheckbox.checked = true;
        }
    });
    
    // Mettre à jour les compteurs
    initializeSelectionCounters();
    
    // Sauvegarder l'état initial
    setTimeout(() => {
        saveStateToSession();
    }, 100);
}

// ... (dans restoreStateOnLoad)
// Remplacer l'ancienne logique par une qui utilise le nouvel état de session
function restoreStateOnLoad() {
    serverStorage.getItem('currentOpeningSelection').then(explicitLoadDataJSON => {
        let dataToRestoreJSON = null;

        if (explicitLoadDataJSON) {
            console.log("Chargement d'une sélection explicite...");
            dataToRestoreJSON = explicitLoadDataJSON;
            serverStorage.removeItem('currentOpeningSelection'); 
            sessionStorage.setItem('ksatFullPageState', explicitLoadDataJSON); 
        } else {
            dataToRestoreJSON = sessionStorage.getItem('ksatFullPageState');
            if (dataToRestoreJSON) {
                console.log("Restauration de l'état de la session (F5)...");
            }
        }

        if (dataToRestoreJSON) {
            const restoreData = JSON.parse(dataToRestoreJSON);
            // Restaurer allSelectValues si présent
            if (restoreData.allSelectValues) {
                Object.keys(restoreData.allSelectValues).forEach(category => {
                    allSelectValues[category] = restoreData.allSelectValues[category];
                });
            }
            performRestoration(restoreData);
        } else {
            console.log("Aucun état à restaurer. Initialisation par défaut : toutes les checkboxes sont cochées.");
            // Initialiser toutes les checkboxes comme cochées par défaut
            initializeDefaultCheckboxes();
        }
    }).catch(error => {
        console.error("Erreur lors de la récupération de la sélection à charger:", error);
        const sessionStateJSON = sessionStorage.getItem('ksatFullPageState');
        if (sessionStateJSON) {
             console.log("Restauration de l'état de session (F5) en fallback...");
            const restoreData = JSON.parse(sessionStateJSON);
            // Restaurer allSelectValues si présent
            if (restoreData.allSelectValues) {
                Object.keys(restoreData.allSelectValues).forEach(category => {
                    allSelectValues[category] = restoreData.allSelectValues[category];
                });
            }
            performRestoration(restoreData);
        } else {
            console.log("Aucun état trouvé. Initialisation par défaut : toutes les checkboxes sont cochées.");
            initializeDefaultCheckboxes();
        }
    });
}

// Fonctionnalités pour le bouton Step 3
function checkSavedSelections() {
    const button = document.getElementById('etape2-button');
    const tooltip = document.getElementById('etape2-tooltip');
    
    if (!button) return;
    
    // Vérifier si des work roles sont sélectionnés depuis Step0
    const step0Data = localStorage.getItem('step0_baseline_data');
    let hasWorkRoles = false;
    
    if (step0Data) {
        try {
            const data = JSON.parse(step0Data);
            hasWorkRoles = data.selectedWorkRoles && data.selectedWorkRoles.length > 0;
        } catch (e) {
            console.error('Error parsing step0_baseline_data:', e);
        }
    }
    
    // Vérifier dans localStorage s'il y a des sélections sauvegardées
    const savedSelections = localStorage.getItem('ksatSavedSelections');
    const hasSelections = savedSelections && JSON.parse(savedSelections).length > 0;
    
    // Activer le bouton si des work roles sont sélectionnés OU s'il y a des sauvegardes
    if (hasWorkRoles) {
        // Des work roles sont sélectionnés, activer le bouton
        button.disabled = false;
        button.classList.remove('opacity-50', 'cursor-not-allowed');
        tooltip.classList.add('hidden');
        console.log('[BUTTON] Step 3 button enabled: work roles selected');
        return;
    }
    
    // Sinon, vérifier côté serveur via AJAX
    fetch('/check-saved-selections/', {
        method: 'GET',
        headers: {
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || '',
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.has_saved_selections || hasSelections) {
            // L'utilisateur a des sauvegardes, activer le bouton
            button.disabled = false;
            button.classList.remove('opacity-50', 'cursor-not-allowed');
            tooltip.classList.add('hidden');
            console.log('[BUTTON] Step 3 button enabled: saved selections found');
        } else {
            // Pas de sauvegardes et pas de work roles, garder le bouton désactivé
            button.disabled = true;
            button.classList.add('opacity-50', 'cursor-not-allowed');
            console.log('[BUTTON] Step 3 button disabled: no work roles and no saved selections');
        }
    })
    .catch(error => {
        console.log('Erreur lors de la vérification des sauvegardes:', error);
        // En cas d'erreur, utiliser la vérification localStorage
        if (hasSelections) {
            button.disabled = false;
            button.classList.remove('opacity-50', 'cursor-not-allowed');
            tooltip.classList.add('hidden');
        } else {
            button.disabled = true;
            button.classList.add('opacity-50', 'cursor-not-allowed');
        }
    });
}

// Fonction pour aller à l'étape 2
function checkAndGoToEtape2() {
    const button = document.getElementById('etape2-button');
    
    if (button.disabled) {
        // Afficher le tooltip temporairement
        const tooltip = document.getElementById('etape2-tooltip');
        tooltip.classList.remove('hidden');
        
        setTimeout(() => {
            tooltip.classList.add('hidden');
        }, 3000);
        
        return;
    }
    
    // SAUVEGARDER les données KSAT AVANT de rediriger (comme dans summary_mil.html)
    console.log('[STEP 3] ===== CLICKED STEP 3 BUTTON =====');
    
    // Désactiver le bouton pour éviter les double-clics
    button.disabled = true;
    button.textContent = 'Saving...';
    
    // Afficher un message de sauvegarde
    const saveMessage = document.createElement('div');
    saveMessage.id = 'ksat-save-message';
    saveMessage.className = 'fixed top-20 right-5 bg-blue-500 text-white py-3 px-6 rounded-lg shadow-xl z-50';
    saveMessage.innerHTML = '<strong>Saving KSAT data...</strong>';
    document.body.appendChild(saveMessage);
    
    console.log('[STEP 3] Saving KSAT data before redirecting...');
    console.log('[STEP 3] allSelectValues type:', typeof allSelectValues);
    console.log('[STEP 3] allSelectValues:', allSelectValues);
    
    // S'assurer que allSelectValues est initialisé
    if (!allSelectValues || Object.keys(allSelectValues).length === 0) {
        console.warn('[STEP 3] allSelectValues is empty, initializing...');
        if (typeof initializeAllSelectValues === 'function') {
            initializeAllSelectValues();
            console.log('[STEP 3] allSelectValues initialized');
        }
    }
    
    try {
        saveKsatDataForRecap();
        console.log('[STEP 3] KSAT data saved successfully');
        
        // Vérifier que les données sont bien sauvegardées
        const verify = sessionStorage.getItem('ksatLastSavedState');
        if (!verify) {
            throw new Error('Data was not saved to sessionStorage');
        }
        
        // Mettre à jour le message de succès
        saveMessage.className = 'fixed top-20 right-5 bg-green-500 text-white py-3 px-6 rounded-lg shadow-xl z-50';
        saveMessage.innerHTML = '<strong>✓ KSAT data saved successfully!</strong><br><small>Redirecting...</small>';
        
        // Attendre un peu pour que l'utilisateur voie le message, puis rediriger
        setTimeout(() => {
            console.log('[STEP 3] Redirecting to etape2_first_step...');
            window.location.href = "{% url 'etape2_first_step' %}";
        }, 1000);
        
    } catch (error) {
        console.error('[STEP 3] ERROR saving KSAT data:', error);
        console.error('[STEP 3] Error stack:', error.stack);
        
        // Réactiver le bouton
        button.disabled = false;
        button.textContent = 'Step 3 →';
        
        // Afficher un message d'erreur
        saveMessage.className = 'fixed top-20 right-5 bg-red-500 text-white py-3 px-6 rounded-lg shadow-xl z-50';
        saveMessage.innerHTML = '<strong>✗ Error saving KSAT data!</strong><br><small>Check console for details</small>';
        
        // Supprimer le message après 5 secondes
        setTimeout(() => {
            saveMessage.remove();
        }, 5000);
        
        // Ne pas rediriger si la sauvegarde échoue
        alert('Erreur lors de la sauvegarde des données KSAT. Vérifiez la console (F12) pour plus de détails.');
    }
}

// Vérifier les sauvegardes au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    checkSavedSelections();
    
    // Gestion du hover sur le bouton pour afficher/masquer le tooltip
    const button = document.getElementById('etape2-button');
    const tooltip = document.getElementById('etape2-tooltip');
    
    if (button && tooltip) {
        button.addEventListener('mouseenter', function() {
            if (button.disabled) {
                tooltip.classList.remove('hidden');
            }
        });
        
        button.addEventListener('mouseleave', function() {
            tooltip.classList.add('hidden');
        });
    }
});

// Réactiver le bouton après une sauvegarde réussie
// Intercepter la fonction saveCurrentSelection existante
const originalSaveCurrentSelection = saveCurrentSelection;
saveCurrentSelection = function() {
    originalSaveCurrentSelection();
    
    // Réactiver le bouton Étape 2 après une sauvegarde réussie
    setTimeout(() => {
        checkSavedSelections();
    }, 1000);
};

</script>
<!-- Les données modales sont maintenant chargées directement dans la variable JavaScript -->

<!-- Style de débogage -->
<style>
.debug-info {
  background-color: #f8f9fa;
  border: 1px solid #ddd;
  padding: 5px;
  margin: 5px 0;
  font-size: 12px;
  color: #333;
}
</style>

<script>
// Cache pour les données KSAT
let dcwfKsatData = null;
let ncwfKsatData = null;
let ksatDataLoaded = false;

// Fonction pour charger les données KSAT
async function loadKsatData() {
    if (ksatDataLoaded) {
        return Promise.resolve();
    }
    
    try {
        const [dcwfResponse, ncwfResponse] = await Promise.all([
            fetch('/api/ksat-data/dcwf/'),
            fetch('/api/ksat-data/ncwf/')
        ]);
        
        if (dcwfResponse.ok && ncwfResponse.ok) {
            dcwfKsatData = await dcwfResponse.json();
            ncwfKsatData = await ncwfResponse.json();
            ksatDataLoaded = true;
            console.log('Données KSAT chargées avec succès');
            console.log('DCWF KSATs chargés:', dcwfKsatData ? dcwfKsatData.length : 0);
            // Compter les abilities dans les données chargées
            if (dcwfKsatData) {
                const abilityCount = dcwfKsatData.filter(item => {
                    const ksat = (item.ksat || '').trim();
                    return ksat.charAt(0).toUpperCase() === 'A';
                }).length;
                console.log('Abilities trouvées dans dcwf_data.json:', abilityCount);
            }
            // Mettre à jour les compteurs après le chargement des données
            if (typeof updateIndividualRoleCounters === 'function') {
                updateIndividualRoleCounters();
            }
            // Afficher les indicateurs Skills Alignment
            updateSkillsAlignmentIndicators();
        } else {
            console.error('Erreur lors du chargement des données KSAT:', dcwfResponse.status, ncwfResponse.status);
        }
    } catch (e) {
        console.error('Erreur lors du chargement des données KSAT:', e);
    }
}

// Fonction pour trouver le Skills Alignment d'un KSAT
function getSkillsAlignment(ksatId, wrlId) {
    if (!ncwfKsatData || !ksatId) {
        return null;
    }
    
    // Chercher le KSAT dans les données NCWF
    // Si on a un WRL-ID, chercher avec le WRL-ID aussi pour être plus précis
    let ksatEntry = null;
    
    if (wrlId) {
        // Chercher avec le WRL-ID et l'ID du KSAT
        ksatEntry = ncwfKsatData.find(item => {
            const itemId = (item.ID || item.id || '').trim();
            const itemWrlId = (item['WRL-ID'] || '').trim();
            return itemId === ksatId && itemWrlId === wrlId;
        });
    }
    
    // Si pas trouvé avec WRL-ID, chercher juste par ID
    if (!ksatEntry) {
        ksatEntry = ncwfKsatData.find(item => {
            const itemId = (item.ID || item.id || '').trim();
            return itemId === ksatId;
        });
    }
    
    // Retourner le Skills Alignment s'il existe
    if (ksatEntry && ksatEntry['Skills Alignment']) {
        return ksatEntry['Skills Alignment'];
    }
    
    return null;
}

// Fonction pour vérifier si un KSAT correspond aux critères OPM-ID/WRL-ID
function isKsatAllowed(ksatEntry) {
    if (!ksatEntry) return false;
    
    const allowedOpmIds = ['TBD-A', 'TBD-B'];
    const allowedWrlIds = ['IN-WRL-001', 'IN-WRL-002'];
    
    const opmId = (ksatEntry['OPM-ID'] || ksatEntry.opm_id || '').trim();
    const wrlId = (ksatEntry['WRL-ID'] || ksatEntry.wrl_id || '').trim();
    
    return allowedOpmIds.includes(opmId) || allowedWrlIds.includes(wrlId);
}

// Fonction pour trouver les tâches qui contiennent un K ou S donné dans leur Skills Alignment
// Filtrée pour les OPM-ID: TBD-A, TBD-B et WRL-ID: IN-WRL-001, IN-WRL-002
function findTasksContainingKsat(ksatId, category) {
    if (!ncwfKsatData || !ksatId) {
        return [];
    }
    
    // Vérifier que c'est un K ou S (pas une tâche)
    const ksatType = ksatId.charAt(0).toUpperCase();
    if (ksatType !== 'K' && ksatType !== 'S') {
        return [];
    }
    
    const tasks = [];
    const allowedOpmIds = ['TBD-A', 'TBD-B'];
    const allowedWrlIds = ['IN-WRL-001', 'IN-WRL-002'];
    
    // Parcourir toutes les tâches (T) dans les données
    ncwfKsatData.forEach(item => {
        const itemKsat = (item.KSAT || item.ksat || '').trim().toUpperCase();
        const itemOpmId = (item['OPM-ID'] || item.opm_id || '').trim();
        const itemWrlId = (item['WRL-ID'] || item.wrl_id || '').trim();
        
        // Vérifier que l'OPM-ID ou WRL-ID est autorisé
        const isAllowedOpmId = allowedOpmIds.includes(itemOpmId);
        const isAllowedWrlId = allowedWrlIds.includes(itemWrlId);
        
        // Si c'est une tâche, qu'elle a un Skills Alignment, et qu'elle correspond aux critères
        if (itemKsat === 'T' && item['Skills Alignment'] && (isAllowedOpmId || isAllowedWrlId)) {
            const skillsAlignment = item['Skills Alignment'];
            
            // Vérifier si le K ou S est dans le Skills Alignment
            // Le format est "K1290: Description\nK1291: Description\n..."
            const lines = skillsAlignment.split('\n').filter(line => line.trim());
            
            lines.forEach(line => {
                const trimmed = line.trim();
                // Extraire l'ID du KSAT (ex: "K1290" ou "S0806")
                const match = trimmed.match(/^([KS]\d+):/);
                if (match) {
                    const alignedKsatId = match[1];
                    if (alignedKsatId === ksatId) {
                        // Cette tâche contient le K ou S
                        tasks.push({
                            id: item.ID || item.id,
                            description: item.Description || item.description,
                            wrlId: item['WRL-ID'] || item.wrl_id,
                            opmId: item['OPM-ID'] || item.opm_id
                        });
                    }
                }
            });
        }
    });
    
    return tasks;
}

// Fonction pour trouver les K et S contenus dans une tâche (T)
// Filtrée pour les OPM-ID: TBD-A, TBD-B et WRL-ID: IN-WRL-001, IN-WRL-002
function findKsatInTask(taskId) {
    if (!ncwfKsatData || !taskId) {
        return { knowledge: [], skills: [] };
    }
    
    // Vérifier que c'est une tâche (T)
    const ksatType = taskId.charAt(0).toUpperCase();
    if (ksatType !== 'T') {
        return { knowledge: [], skills: [] };
    }
    
    const knowledge = [];
    const skills = [];
    const allowedOpmIds = ['TBD-A', 'TBD-B'];
    const allowedWrlIds = ['IN-WRL-001', 'IN-WRL-002'];
    
    // Chercher la tâche dans les données
    const task = ncwfKsatData.find(item => {
        const itemId = (item.ID || item.id || '').trim();
        return itemId === taskId;
    });
    
    if (task && task['Skills Alignment']) {
        const taskOpmId = (task['OPM-ID'] || task.opm_id || '').trim();
        const taskWrlId = (task['WRL-ID'] || task.wrl_id || '').trim();
        
        // Vérifier que l'OPM-ID ou WRL-ID est autorisé
        const isAllowedOpmId = allowedOpmIds.includes(taskOpmId);
        const isAllowedWrlId = allowedWrlIds.includes(taskWrlId);
        
        // Ne traiter que si la tâche correspond aux critères
        if (isAllowedOpmId || isAllowedWrlId) {
            const skillsAlignment = task['Skills Alignment'];
            const lines = skillsAlignment.split('\n').filter(line => line.trim());
            
            lines.forEach(line => {
                const trimmed = line.trim();
                // Extraire l'ID et la description (ex: "K1290: Description" ou "S0806: Description")
                const match = trimmed.match(/^([KS])(\d+):\s*(.+)$/);
                if (match) {
                    const [, type, id, description] = match;
                    const ksatId = type + id;
                    const ksatInfo = {
                        id: ksatId,
                        description: description.trim()
                    };
                    
                    if (type === 'K') {
                        knowledge.push(ksatInfo);
                    } else if (type === 'S') {
                        skills.push(ksatInfo);
                    }
                }
            });
        }
    }
    
    return { knowledge, skills };
}

// Fonction pour mettre à jour les indicateurs Skills Alignment
function updateSkillsAlignmentIndicators() {
    if (!ncwfKsatData) {
        // Réessayer après un court délai si les données ne sont pas encore chargées
        setTimeout(updateSkillsAlignmentIndicators, 500);
        return;
    }
    
    // Mettre à jour les indicateurs pour les K/S (qui sont liés à des tâches)
    document.querySelectorAll('.skills-alignment-indicator-top').forEach(indicator => {
        const ksatId = indicator.getAttribute('data-ksat-id');
        const category = indicator.getAttribute('data-category');
        
        if (ksatId) {
            // Trouver les tâches qui contiennent ce K ou S (déjà filtrées par OPM-ID/WRL-ID)
            const tasks = findTasksContainingKsat(ksatId, category);
            if (tasks.length > 0) {
                indicator.style.display = 'inline-block';
                // Stocker les tâches dans un attribut data pour utilisation ultérieure
                indicator.setAttribute('data-tasks', JSON.stringify(tasks));
            } else {
                indicator.style.display = 'none';
            }
        }
    });
    
    // Mettre à jour les indicateurs pour les tâches (T) qui contiennent des K/S
    document.querySelectorAll('.task-skills-alignment-indicator-top').forEach(indicator => {
        const ksatId = indicator.getAttribute('data-ksat-id');
        const category = indicator.getAttribute('data-category');
        
        if (ksatId) {
            // Trouver les K et S contenus dans cette tâche
            const { knowledge, skills } = findKsatInTask(ksatId);
            if (knowledge.length > 0 || skills.length > 0) {
                indicator.style.display = 'inline-block';
                // Stocker les K/S dans un attribut data pour utilisation ultérieure
                indicator.setAttribute('data-knowledge', JSON.stringify(knowledge));
                indicator.setAttribute('data-skills', JSON.stringify(skills));
            } else {
                indicator.style.display = 'none';
            }
        }
    });
}

// Fonction pour afficher le Skills Alignment dans une modal
function showSkillsAlignment(element) {
    const ksatId = element.getAttribute('data-ksat-id');
    const wrlId = element.getAttribute('data-role-wrl-id');
    
    if (!ksatId) {
        return;
    }
    
    const skillsAlignment = getSkillsAlignment(ksatId, wrlId);
    
    if (!skillsAlignment) {
        alert('Aucun Skills Alignment trouvé pour ce KSAT');
        return;
    }
    
    // Créer ou récupérer la modal
    let modal = document.getElementById('skills-alignment-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'skills-alignment-modal';
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center';
        modal.style.display = 'none';
        modal.innerHTML = `
            <div class="bg-white rounded-lg shadow-xl max-w-3xl w-full mx-4 max-h-[80vh] overflow-hidden flex flex-col">
                <div class="bg-blue-600 text-white px-6 py-4 flex justify-between items-center">
                    <h3 class="text-xl font-bold">Skills Alignment</h3>
                    <button onclick="closeSkillsAlignmentModal()" class="text-white hover:text-gray-200 text-2xl font-bold">&times;</button>
                </div>
                <div class="p-6 overflow-y-auto flex-1" id="skills-alignment-content">
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Fermer en cliquant sur le fond
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeSkillsAlignmentModal();
            }
        });
    }
    
    // Formater le contenu Skills Alignment
    const content = document.getElementById('skills-alignment-content');
    const lines = skillsAlignment.split('\n').filter(line => line.trim());
    
    // Séparer les Knowledge (K) et Skills (S)
    const knowledgeItems = [];
    const skillItems = [];
    
    lines.forEach(line => {
        const trimmed = line.trim();
        if (!trimmed) return;
        
        if (trimmed.startsWith('K')) {
            knowledgeItems.push(trimmed);
        } else if (trimmed.startsWith('S')) {
            skillItems.push(trimmed);
        }
    });
    
    let html = '<div class="space-y-4">';
    
    // Section Knowledge
    if (knowledgeItems.length > 0) {
        html += '<div>';
        html += '<h4 class="text-lg font-bold text-blue-700 mb-3">Knowledge (K)</h4>';
        html += '<div class="space-y-2">';
        knowledgeItems.forEach(item => {
            // Extraire l'ID et la description
            const match = item.match(/^(K\d+):\s*(.+)$/);
            if (match) {
                const [, ksatId, description] = match;
                html += `<div class="p-3 bg-blue-50 border-l-4 border-blue-500 rounded hover:bg-blue-100 transition-colors">
                    <span class="font-semibold text-blue-700">${ksatId}:</span>
                    <span class="text-blue-800 ml-2">${description}</span>
                </div>`;
            } else {
                html += `<div class="p-3 bg-blue-50 border-l-4 border-blue-500 rounded">
                    <span class="font-semibold text-blue-700">${item}</span>
                </div>`;
            }
        });
        html += '</div></div>';
    }
    
    // Section Skills
    if (skillItems.length > 0) {
        html += '<div>';
        html += '<h4 class="text-lg font-bold text-green-700 mb-3">Skills (S)</h4>';
        html += '<div class="space-y-2">';
        skillItems.forEach(item => {
            // Extraire l'ID et la description
            const match = item.match(/^(S\d+):\s*(.+)$/);
            if (match) {
                const [, ksatId, description] = match;
                html += `<div class="p-3 bg-green-50 border-l-4 border-green-500 rounded hover:bg-green-100 transition-colors">
                    <span class="font-semibold text-green-700">${ksatId}:</span>
                    <span class="text-green-800 ml-2">${description}</span>
                </div>`;
            } else {
                html += `<div class="p-3 bg-green-50 border-l-4 border-green-500 rounded">
                    <span class="font-semibold text-green-700">${item}</span>
                </div>`;
            }
        });
        html += '</div></div>';
    }
    
    html += '</div>';
    
    content.innerHTML = html;
    modal.style.display = 'flex';
}

// Fonction pour fermer la modal
function closeSkillsAlignmentModal() {
    const modal = document.getElementById('skills-alignment-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Fonction pour afficher les tâches liées à un K ou S
function showTaskAlignment(element) {
    const ksatId = element.getAttribute('data-ksat-id');
    const tasksJson = element.getAttribute('data-tasks');
    
    if (!tasksJson) {
        alert('No linked tasks found for this KSAT');
        return;
    }
    
    const tasks = JSON.parse(tasksJson);
    
    if (tasks.length === 0) {
        alert('No linked tasks found for this KSAT');
        return;
    }
    
    // Créer ou récupérer la modal
    let modal = document.getElementById('task-alignment-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'task-alignment-modal';
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center';
        modal.style.display = 'none';
        modal.innerHTML = `
            <div class="bg-white rounded-lg shadow-xl max-w-3xl w-full mx-4 max-h-[80vh] overflow-hidden flex flex-col">
                <div class="bg-orange-600 text-white px-6 py-4 flex justify-between items-center">
                    <h3 class="text-xl font-bold">Linked Tasks</h3>
                    <button onclick="closeTaskAlignmentModal()" class="text-white hover:text-gray-200 text-2xl font-bold">&times;</button>
                </div>
                <div class="p-6 overflow-y-auto flex-1" id="task-alignment-content">
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Fermer en cliquant sur le fond
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeTaskAlignmentModal();
            }
        });
    }
    
    // Formater le contenu
    const content = document.getElementById('task-alignment-content');
    let html = '<div class="space-y-4">';
    html += `<p class="text-gray-700 mb-4">The KSAT <strong>${ksatId}</strong> is linked to the following tasks:</p>`;
    
    tasks.forEach(task => {
        html += `<div class="p-4 bg-orange-50 border-l-4 border-orange-500 rounded hover:bg-orange-100 transition-colors">
            <div class="font-semibold text-orange-700 mb-1">${task.id}</div>
            <div class="text-orange-800">${task.description || 'Pas de description'}</div>
            ${task.wrlId ? `<div class="text-xs text-gray-600 mt-1">WRL-ID: ${task.wrlId}</div>` : ''}
        </div>`;
    });
    
    html += '</div>';
    content.innerHTML = html;
    modal.style.display = 'flex';
}

// Fonction pour fermer la modal des tâches
function closeTaskAlignmentModal() {
    const modal = document.getElementById('task-alignment-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Fonction pour afficher les K/S contenus dans une tâche
function showTaskSkillsAlignment(element) {
    const taskId = element.getAttribute('data-ksat-id');
    const knowledgeJson = element.getAttribute('data-knowledge');
    const skillsJson = element.getAttribute('data-skills');
    
    if (!knowledgeJson && !skillsJson) {
        alert('No Knowledge or Skill found for this task');
        return;
    }
    
    const knowledge = knowledgeJson ? JSON.parse(knowledgeJson) : [];
    const skills = skillsJson ? JSON.parse(skillsJson) : [];
    
    if (knowledge.length === 0 && skills.length === 0) {
        alert('No Knowledge or Skill found for this task');
        return;
    }
    
    // Créer ou récupérer la modal
    let modal = document.getElementById('task-skills-alignment-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'task-skills-alignment-modal';
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center';
        modal.style.display = 'none';
        modal.innerHTML = `
            <div class="bg-white rounded-lg shadow-xl max-w-3xl w-full mx-4 max-h-[80vh] overflow-hidden flex flex-col">
                <div class="bg-blue-600 text-white px-6 py-4 flex justify-between items-center">
                    <h3 class="text-xl font-bold">Linked Knowledge and Skills</h3>
                    <button onclick="closeTaskSkillsAlignmentModal()" class="text-white hover:text-gray-200 text-2xl font-bold">&times;</button>
                </div>
                <div class="p-6 overflow-y-auto flex-1" id="task-skills-alignment-content">
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Fermer en cliquant sur le fond
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeTaskSkillsAlignmentModal();
            }
        });
    }
    
    // Formater le contenu
    const content = document.getElementById('task-skills-alignment-content');
    let html = '<div class="space-y-4">';
    html += `<p class="text-gray-700 mb-4">The task <strong>${taskId}</strong> contains the following Knowledge and Skills:</p>`;
    
    // Section Knowledge
    if (knowledge.length > 0) {
        html += '<div>';
        html += '<h4 class="text-lg font-bold text-blue-700 mb-3">Knowledge (K)</h4>';
        html += '<div class="space-y-2">';
        knowledge.forEach(ksat => {
            html += `<div class="p-3 bg-blue-50 border-l-4 border-blue-500 rounded hover:bg-blue-100 transition-colors">
                <span class="font-semibold text-blue-700">${ksat.id}:</span>
                <span class="text-blue-800 ml-2">${ksat.description}</span>
            </div>`;
        });
        html += '</div></div>';
    }
    
    // Section Skills
    if (skills.length > 0) {
        html += '<div>';
        html += '<h4 class="text-lg font-bold text-green-700 mb-3">Skills (S)</h4>';
        html += '<div class="space-y-2">';
        skills.forEach(ksat => {
            html += `<div class="p-3 bg-green-50 border-l-4 border-green-500 rounded hover:bg-green-100 transition-colors">
                <span class="font-semibold text-green-700">${ksat.id}:</span>
                <span class="text-green-800 ml-2">${ksat.description}</span>
            </div>`;
        });
        html += '</div></div>';
    }
    
    html += '</div>';
    content.innerHTML = html;
    modal.style.display = 'flex';
}

// Fonction pour fermer la modal des K/S d'une tâche
function closeTaskSkillsAlignmentModal() {
    const modal = document.getElementById('task-skills-alignment-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// Fonction pour normaliser un OPM ID pour la comparaison
function normalizeOpmId(opmId) {
    if (!opmId) return '';
    // Retirer les parenthèses et espaces, et convertir en string
    return String(opmId).replace(/[()\s]/g, '').trim();
}

// Fonction pour compter les KSAT DCWF pour un OPM ID (T, K, S, A séparément)
function countDCWFKsat(opmId) {
    if (!dcwfKsatData || !opmId) {
        return { T: 0, K: 0, S: 0, A: 0 };
    }
    
    // Normaliser l'OPM ID : extraire uniquement les chiffres
    const normalizedOpmId = String(opmId).replace(/[^\d]/g, '');
    const counts = { T: 0, K: 0, S: 0, A: 0 };
    
    dcwfKsatData.forEach(item => {
        // Le nouveau format a opm_id comme string de chiffres (ex: "411")
        const itemOpmId = String(item.opm_id || '').trim();
        
        // Vérifier que la description n'est pas null ou vide
        const description = item.description;
        if (description === null || description === undefined || description === '') {
            return; // Ignorer les entrées sans description
        }
        
        if (itemOpmId === normalizedOpmId) {
            const ksat = (item.ksat || '').trim();
            // Gérer les cas comme "K*" ou "K"
            const ksatType = ksat.charAt(0).toUpperCase();
            if (ksatType === 'T' || ksatType === 'K' || ksatType === 'S' || ksatType === 'A') {
                counts[ksatType] = (counts[ksatType] || 0) + 1;
            }
        }
    });
    
    return counts;
}

// Fonction pour compter les TKS NCWF pour un OPM ID (T, K, S séparément)
function countNCWFTks(opmId) {
    if (!ncwfKsatData || !opmId) {
        return { T: 0, K: 0, S: 0 };
    }
    
    const normalizedOpmId = normalizeOpmId(opmId);
    const counts = { T: 0, K: 0, S: 0 };
    
    ncwfKsatData.forEach(item => {
        const itemOpmId = item['OPM-ID'] || item.opm_id || '';
        const normalizedItemOpmId = normalizeOpmId(itemOpmId);
        const ksat = (item.KSAT || item.ksat || '').trim().toUpperCase();
        
        // Vérifier que la description n'est pas null ou vide
        const description = item.Description || item.description;
        if (description === null || description === undefined || description === '') {
            return; // Ignorer les entrées sans description
        }
        
        if (normalizedItemOpmId === normalizedOpmId && (ksat === 'T' || ksat === 'K' || ksat === 'S')) {
            counts[ksat] = (counts[ksat] || 0) + 1;
        }
    });
    
    return counts;
}

// Fonction pour extraire l'abréviation d'un élément
function getElementAbbreviation(element) {
    if (!element) return '';
    const normalized = element.replace(/\s+/g, ' ').trim();
    
    // Map pour DCWF
    const dcwfMap = {
        'Information Technology (IT)': 'IT',
        'Information Technology  (IT)': 'IT',
        'Cybersecurity (CS)': 'CS',
        'Cyber Enablers (EN)': 'EN',
        'Cyber Effects (CE)': 'CE',
        'Intel (Cyber) (CI)': 'CI',
        'Data/AI (DA)': 'DA',
        'Software Engineering (SE)': 'SE'
    };
    
    // Map pour NCWF
    const ncwfMap = {
        'Oversight & Governance': 'OG',
        'Implementation & Operation': 'IO',
        'Design & Development': 'DD',
        'Protection & Defense': 'PD',
        'Protection and Defense': 'PD',
        'Investigation': 'IN'
    };
    
    // Essayer DCWF d'abord
    if (dcwfMap[normalized]) {
        return dcwfMap[normalized];
    }
    
    // Essayer NCWF
    if (ncwfMap[normalized]) {
        return ncwfMap[normalized];
    }
    
    // Sinon, essayer d'extraire depuis les parenthèses
    const match = normalized.match(/\(([A-Z]+)\)/);
    return match ? match[1] : '';
}

// Fonction pour charger et afficher les sélections de Step0
function loadAndDisplayStep0Selections() {
    try {
        const step0Data = localStorage.getItem('step0_baseline_data');
        if (!step0Data) {
            console.log('Aucune donnée Step0 trouvée');
            return;
        }
        
        const data = JSON.parse(step0Data);
        console.log('Données Step0 chargées:', data);
        
        if (!data.selectedWorkRoles || data.selectedWorkRoles.length === 0) {
            return;
        }
        
        const container = document.getElementById('selected-roles-container');
        const sectionDiv = document.getElementById('step0-selected-roles');
        
        if (!container || !sectionDiv) {
            console.error('Conteneur non trouvé');
            return;
        }
        
        // Afficher la section
        sectionDiv.style.display = 'block';
        
        // Charger les données KSAT d'abord
        loadKsatData().then(() => {
            console.log('Données KSAT chargées:', { 
                dcwfLoaded: !!dcwfKsatData, 
                dcwfLength: dcwfKsatData ? dcwfKsatData.length : 0,
                ncwfLoaded: !!ncwfKsatData,
                ncwfLength: ncwfKsatData ? ncwfKsatData.length : 0
            });
            
            // Créer les cartes pour chaque work role
            data.selectedWorkRoles.forEach(role => {
                const isPrimary = role.opm_code === data.primaryRoleOpmId;
                const roleCard = document.createElement('div');
                roleCard.className = `selected-role-card ${isPrimary ? 'primary' : ''}`;
                
                const dcwfName = role.dcwf_work_role || '';
                const ncwfName = role.ncwf_work_role || '';
                const dcwfElement = role.dcwf_element || '';
                const ncwfElement = role.ncwf_element || '';
                const opmId = role.opm_code || '';
                
                const dcwfAbbr = getElementAbbreviation(dcwfElement);
                const ncwfAbbr = getElementAbbreviation(ncwfElement);
                
                // Compter les KSAT
                const dcwfCounts = countDCWFKsat(opmId);
                const ncwfCounts = countNCWFTks(opmId);
                
                
                // Formater les compteurs DCWF (T, K, S, A) - toujours afficher A même si 0
                const dcwfCountsText = [];
                if (dcwfCounts.T > 0) dcwfCountsText.push(`T:${dcwfCounts.T}`);
                if (dcwfCounts.K > 0) dcwfCountsText.push(`K:${dcwfCounts.K}`);
                if (dcwfCounts.S > 0) dcwfCountsText.push(`S:${dcwfCounts.S}`);
                // Toujours afficher A même si 0
                dcwfCountsText.push(`A:${dcwfCounts.A}`);
                const dcwfCountsDisplay = dcwfCountsText.length > 0 ? dcwfCountsText.join(' ') : '';
                
                // Formater les compteurs NCWF (T, K, S)
                const ncwfCountsText = [];
                if (ncwfCounts.T > 0) ncwfCountsText.push(`T:${ncwfCounts.T}`);
                if (ncwfCounts.K > 0) ncwfCountsText.push(`K:${ncwfCounts.K}`);
                if (ncwfCounts.S > 0) ncwfCountsText.push(`S:${ncwfCounts.S}`);
                const ncwfCountsDisplay = ncwfCountsText.length > 0 ? ncwfCountsText.join(' ') : '';
                
                roleCard.innerHTML = `
                    <div class="role-opm">OPM-ID: ${opmId}</div>
                    ${dcwfName ? `<div class="role-name" style="font-weight: 500; color: rgba(255, 255, 255, 0.9); font-size: 14px; margin-bottom: 2px;">${dcwfName}${dcwfAbbr ? ` (${dcwfAbbr})` : ''}</div>` : ''}
                    ${dcwfCountsDisplay ? `<div style="font-size: 11px; color: rgba(255, 255, 255, 0.7); margin-bottom: 8px;">${dcwfCountsDisplay}</div>` : ''}
                    ${ncwfName ? `<div class="role-name" style="font-weight: 600; color: rgba(255, 255, 255, 0.95); font-size: 14px; margin-bottom: 2px;">${ncwfName}${ncwfAbbr ? ` (${ncwfAbbr})` : ''}</div>` : ''}
                    ${ncwfCountsDisplay ? `<div style="font-size: 11px; color: rgba(255, 255, 255, 0.7);">${ncwfCountsDisplay}</div>` : ''}
                `;
                
                container.appendChild(roleCard);
            });
        }).catch(() => {
            // Si le chargement échoue, afficher les cartes sans les compteurs
            data.selectedWorkRoles.forEach(role => {
                const isPrimary = role.opm_code === data.primaryRoleOpmId;
                const roleCard = document.createElement('div');
                roleCard.className = `selected-role-card ${isPrimary ? 'primary' : ''}`;
                
                const dcwfName = role.dcwf_work_role || '';
                const ncwfName = role.ncwf_work_role || '';
                const dcwfElement = role.dcwf_element || '';
                const ncwfElement = role.ncwf_element || '';
                
                const dcwfAbbr = getElementAbbreviation(dcwfElement);
                const ncwfAbbr = getElementAbbreviation(ncwfElement);
                
                roleCard.innerHTML = `
                    <div class="role-opm">OPM-ID: ${role.opm_code}</div>
                    ${dcwfName ? `<div class="role-name" style="font-weight: 500; color: rgba(255, 255, 255, 0.9); font-size: 14px; margin-bottom: 4px;">${dcwfName}${dcwfAbbr ? ` (${dcwfAbbr})` : ''}</div>` : ''}
                    ${ncwfName ? `<div class="role-name" style="font-weight: 600; color: rgba(255, 255, 255, 0.95); font-size: 14px;">${ncwfName}${ncwfAbbr ? ` (${ncwfAbbr})` : ''}</div>` : ''}
                `;
                
                container.appendChild(roleCard);
            });
            
            // Activer le bouton même si le chargement des KSAT a échoué
            const button = document.getElementById('etape2-button');
            if (button) {
                button.disabled = false;
                button.classList.remove('opacity-50', 'cursor-not-allowed');
                const tooltip = document.getElementById('etape2-tooltip');
                if (tooltip) {
                    tooltip.classList.add('hidden');
                }
                console.log('[BUTTON] Step 3 button enabled (work roles loaded, KSAT load failed)');
            }
        });
        
        // Activer le bouton Step 3 après le chargement des work roles
        const button = document.getElementById('etape2-button');
        if (button && data.selectedWorkRoles && data.selectedWorkRoles.length > 0) {
            button.disabled = false;
            button.classList.remove('opacity-50', 'cursor-not-allowed');
            const tooltip = document.getElementById('etape2-tooltip');
            if (tooltip) {
                tooltip.classList.add('hidden');
            }
            console.log('[BUTTON] Step 3 button enabled: work roles found');
        }
    } catch (e) {
        console.error('Erreur lors du chargement des données Step0:', e);
    }
}

// Charger les sélections Step0 au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
    loadAndDisplayStep0Selections();
    
    // Vérifier aussi si des work roles sont dans l'URL (paramètres GET)
    // Si oui, activer le bouton Step 3
    setTimeout(() => {
        const urlParams = new URLSearchParams(window.location.search);
        const hasDcwfIds = urlParams.has('dcwf_ids') || urlParams.has('dcwf_2025_ids');
        const hasNcwfIds = urlParams.has('ncwf_2017_ids') || urlParams.has('ncwf_2024_ids') || urlParams.has('ncwf_2025_ids');
        
        if (hasDcwfIds || hasNcwfIds) {
            const button = document.getElementById('etape2-button');
            if (button) {
                button.disabled = false;
                button.classList.remove('opacity-50', 'cursor-not-allowed');
                const tooltip = document.getElementById('etape2-tooltip');
                if (tooltip) {
                    tooltip.classList.add('hidden');
                }
                console.log('[BUTTON] Step 3 button enabled: work roles in URL parameters');
            }
        }
        
        // Vérifier aussi les sauvegardes (fonction existante)
        checkSavedSelections();
    }, 500);
    
    // Restaurer l'état des checkboxes depuis allSelectValues
    restoreCheckboxesState();
});

// Fonction pour restaurer l'état des checkboxes depuis allSelectValues
function restoreCheckboxesState() {
    restoreCheckboxesFromAllSelectValues();
}

// Fonction pour restaurer les checkboxes depuis allSelectValues
function restoreCheckboxesFromAllSelectValues() {
    // Parcourir toutes les catégories
    ['task', 'knowledge', 'skill', 'abilitie'].forEach(category => {
        if (allSelectValues[category]) {
            const tabContent = document.getElementById(category);
            if (!tabContent) {
                // Si le tabContent n'existe pas encore, réessayer après un délai
                setTimeout(() => restoreCheckboxesFromAllSelectValues(), 200);
                return;
            }
            
            // Parcourir tous les KSAT sélectionnés pour cette catégorie
            Object.keys(allSelectValues[category]).forEach(ksatId => {
                // Essayer plusieurs sélecteurs possibles pour trouver la checkbox
                let checkbox = tabContent.querySelector(`.ksat-checkbox[data-ksat-id="${ksatId}"]`);
                
                // Si pas trouvé, essayer sans guillemets dans l'attribut
                if (!checkbox) {
                    checkbox = tabContent.querySelector(`.ksat-checkbox[data-ksat-id='${ksatId}']`);
                }
                
                // Si toujours pas trouvé, chercher par ID partiel
                if (!checkbox && ksatId) {
                    const allCheckboxes = tabContent.querySelectorAll('.ksat-checkbox');
                    allCheckboxes.forEach(cb => {
                        if (cb.getAttribute('data-ksat-id') === ksatId) {
                            checkbox = cb;
                        }
                    });
                }
                
                if (checkbox) {
                    checkbox.checked = true;
                } else {
                    console.warn(`Checkbox non trouvée pour KSAT ID: ${ksatId} dans la catégorie: ${category}`);
                }
            });
            
            // Mettre à jour l'état de "Check All"
            updateCheckAllState(category);
        }
    });
}

// Fonction pour gérer le changement d'une checkbox KSAT individuelle
function handleKSATCheckboxChange(checkbox, category) {
    const ksatId = checkbox.getAttribute('data-ksat-id');
    const isChecked = checkbox.checked;
    
    // Stocker la sélection dans allSelectValues (équivalent à "1" dans le select)
    if (!allSelectValues[category]) {
        allSelectValues[category] = {};
    }
    
    if (isChecked) {
        // Sélectionner le KSAT (équivalent à "1")
        allSelectValues[category][ksatId] = {
            primary: '1',
            secondary: '',
            tertiary: ''
        };
    } else {
        // Désélectionner le KSAT
        delete allSelectValues[category][ksatId];
    }
    
    // Mettre à jour les compteurs
    updateSelectionCountersForTab(category);
    
    // Mettre à jour l'état de la checkbox "Check All"
    updateCheckAllState(category);
    
    // Mettre à jour les compteurs T/K/S/A dans div.mb-3
    updateIndividualRoleCounters();
    
    // Sauvegarder l'état dans la session
    saveStateToSession();
}

// Fonction pour gérer la checkbox "Check All"
function toggleAllKSATs(category, isChecked) {
    const tabContent = document.getElementById(category);
    if (!tabContent) return;
    
    // Trouver toutes les checkboxes de KSAT dans cette catégorie
    const checkboxes = tabContent.querySelectorAll('.ksat-checkbox[data-category="' + category + '"]');
    
    // Initialiser allSelectValues pour cette catégorie si nécessaire
    if (!allSelectValues[category]) {
        allSelectValues[category] = {};
    }
    
    // Cocher ou décocher toutes les checkboxes et mettre à jour allSelectValues
    checkboxes.forEach(checkbox => {
        checkbox.checked = isChecked;
        const ksatId = checkbox.getAttribute('data-ksat-id');
        
        if (isChecked) {
            // Sélectionner le KSAT (équivalent à "1")
            allSelectValues[category][ksatId] = {
                primary: '1',
                secondary: '',
                tertiary: ''
            };
        } else {
            // Désélectionner le KSAT
            delete allSelectValues[category][ksatId];
        }
    });
    
    // Mettre à jour les compteurs une seule fois
    updateSelectionCountersForTab(category);
    
    // Mettre à jour l'état de la checkbox "Check All"
    updateCheckAllState(category);
    
    // Mettre à jour les compteurs T/K/S/A dans div.mb-3
    updateIndividualRoleCounters();
    
    // Sauvegarder l'état dans la session
    saveStateToSession();
}

// Fonction pour mettre à jour l'état de la checkbox "Check All"
function updateCheckAllState(category) {
    const tabContent = document.getElementById(category);
    if (!tabContent) return;
    
    const checkboxes = tabContent.querySelectorAll('.ksat-checkbox[data-category="' + category + '"]');
    const checkAllCheckbox = document.getElementById('check-all-' + category);
    
    if (!checkAllCheckbox || checkboxes.length === 0) return;
    
    // Vérifier si toutes les checkboxes sont cochées
    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
    const someChecked = Array.from(checkboxes).some(cb => cb.checked);
    
    // Mettre à jour l'état de la checkbox "Check All"
    checkAllCheckbox.checked = allChecked;
    checkAllCheckbox.indeterminate = someChecked && !allChecked;
}

// Fonction pour sauvegarder l'état actuel des KSAT dans sessionStorage (appelée au clic sur Step 3)
function saveKsatDataForRecap() {
    console.log('[SAVE] ===== SAVING KSAT DATA FOR RECAP =====');
    console.log('[SAVE] Function called from checkAndGoToEtape2 (Step 3)');
    
    // Vérifier que allSelectValues existe
    if (typeof allSelectValues === 'undefined') {
        console.error('[SAVE] ERROR: allSelectValues is not defined! Initializing it...');
        // Initialiser allSelectValues si nécessaire
        if (typeof allSelectValues === 'undefined') {
            window.allSelectValues = {
                task: {},
                knowledge: {},
                skill: {},
                abilitie: {}
            };
        }
        // Réinitialiser depuis les checkboxes
        initializeAllSelectValues();
    }
    
    console.log('[SAVE] allSelectValues exists:', typeof allSelectValues !== 'undefined');
    console.log('[SAVE] allSelectValues content:', allSelectValues);
    
    // Récupérer les informations sur les work roles depuis les attributs data-* du <th>
    const roles = [];
    document.querySelectorAll('thead tr:first-of-type th:not(:first-child)').forEach(th => {
        // Récupérer depuis les attributs data-* (plus fiable)
        const opmId = th.getAttribute('data-opm-id') || '';
        const framework = th.getAttribute('data-framework') || '';
        const modelType = th.getAttribute('data-model-type') || '';
        const roleId = th.getAttribute('data-role-id') || '';
        
        // Fallback: récupérer depuis le DOM si les attributs ne sont pas disponibles
        const opmIdDiv = th.querySelector('div div.text-xs.text-center.mb-1.font-normal');
        const titleDiv = th.querySelector('div div.text-center');
        const frameworkSpan = th.querySelector('div div.text-center span');
        
        const opmIdFromDom = opmIdDiv ? opmIdDiv.textContent.trim() : '';
        const title = titleDiv ? titleDiv.textContent.trim() : '';
        const frameworkFromDom = frameworkSpan ? frameworkSpan.textContent.replace(/[\(\)]/g, '').trim() : '';
        
        // Utiliser les attributs data-* en priorité, sinon le DOM
        const finalOpmId = opmId || opmIdFromDom;
        const finalFramework = framework || frameworkFromDom;
        
        if (finalOpmId && finalOpmId !== '&nbsp;' && finalOpmId !== '') {
            roles.push({
                title: title,
                framework: finalFramework,
                opmId: finalOpmId,
                modelType: modelType,
                roleId: roleId
            });
        }
    });
    
    // Collecter les données KSAT pour chaque onglet
    const ksatData = {};
    
    document.querySelectorAll('.tab-content').forEach(tabContent => {
        const tabId = tabContent.id;
        ksatData[tabId] = [];
        
        tabContent.querySelectorAll('tbody tr').forEach(row => {
            const firstCell = row.querySelector('td:first-child');
            if (!firstCell) return;
            
            const checkbox = firstCell.querySelector('.ksat-checkbox');
            if (!checkbox) return; // Skip if no checkbox found
            
            // CRITICAL: Use data-ksat-id from checkbox (same as allSelectValues keys)
            const ksatIdFromCheckbox = checkbox.getAttribute('data-ksat-id') || '';
            const isChecked = checkbox.checked;
            
            const description = firstCell.querySelector('p.font-medium')?.textContent.trim() || '';
            
            // Fallback: extract from text if data-ksat-id is not available
            const ksatIdFromText = firstCell.querySelector('.text-xs.text-gray-500')?.textContent.trim() || '';
            const normalizedKsatIdFromText = ksatIdFromText.replace('ID: ', '').trim().replace(/\n/g, '');
            
            // Use checkbox ID first (matches allSelectValues), fallback to text ID
            const finalKsatId = ksatIdFromCheckbox || normalizedKsatIdFromText;
            
            if (!finalKsatId) {
                console.warn('[SAVE] Skipping KSAT row - no ID found');
                return;
            }
            
            const roleStatuses = {};
            const roleCells = row.querySelectorAll('td:not(:first-child)');
            roleCells.forEach((cell, idx) => {
                if (roles[idx]) {
                    const role = roles[idx];
                    // Sauvegarder avec plusieurs clés pour faciliter la recherche
                    const hasCheckmark = cell.textContent.includes('✅');
                    roleStatuses[role.title] = hasCheckmark;
                    // Ajouter aussi une clé combinée OPM-ID + Framework pour faciliter le groupement
                    roleStatuses[`${role.opmId}_${role.framework}`] = hasCheckmark;
                }
            });
            
            ksatData[tabId].push({
                description: description,
                id: finalKsatId, // Use the same ID as in allSelectValues
                roleStatuses: roleStatuses,
                checked: isChecked
            });
        });
    });
    
    // Log allSelectValues before saving
    console.log('[SAVE] allSelectValues:', allSelectValues);
    console.log('[SAVE] allSelectValues summary:', {
        task: Object.keys(allSelectValues.task || {}).length,
        knowledge: Object.keys(allSelectValues.knowledge || {}).length,
        skill: Object.keys(allSelectValues.skill || {}).length,
        abilitie: Object.keys(allSelectValues.abilitie || {}).length,
        total: Object.values(allSelectValues).reduce((sum, cat) => sum + Object.keys(cat || {}).length, 0)
    });
    
    console.log('[SAVE] Roles found:', roles.length);
    console.log('[SAVE] KSAT data categories:', Object.keys(ksatData));
    Object.keys(ksatData).forEach(cat => {
        console.log(`[SAVE] ${cat}: ${ksatData[cat].length} items`);
    });
    
    // Récupérer l'URL actuelle avec tous les paramètres
    const currentUrl = window.location.href;
    
    // Créer l'objet de sauvegarde
    const autoSaveData = {
        timestamp: new Date().toISOString(),
        roles: roles,
        ksatData: ksatData,
        allSelectValues: allSelectValues,
        currentUrl: currentUrl  // Sauvegarder l'URL complète avec les paramètres
    };
    
    // Sauvegarder dans sessionStorage
    sessionStorage.setItem('ksatLastSavedState', JSON.stringify(autoSaveData));
    console.log('[SAVE] ===== SAVE COMPLETE =====');
    console.log('[SAVE] Saved to sessionStorage: ksatLastSavedState');
    console.log('[SAVE] Current URL saved:', currentUrl);
    console.log('[SAVE] Roles count:', roles.length);
    console.log('[SAVE] KSAT data categories:', Object.keys(ksatData));
    console.log('[SAVE] allSelectValues total:', Object.values(allSelectValues).reduce((sum, cat) => sum + Object.keys(cat || {}).length, 0));
    
    // Vérifier que les données sont bien sauvegardées
    const verify = sessionStorage.getItem('ksatLastSavedState');
    if (verify) {
        const parsed = JSON.parse(verify);
        console.log('[SAVE] VERIFICATION - Saved data structure:', {
            hasRoles: !!(parsed.roles && parsed.roles.length > 0),
            hasKsatData: !!(parsed.ksatData),
            hasAllSelectValues: !!(parsed.allSelectValues),
            rolesCount: parsed.roles ? parsed.roles.length : 0,
            ksatDataKeys: parsed.ksatData ? Object.keys(parsed.ksatData) : []
        });
    } else {
        console.error('[SAVE] ERROR: Data was not saved to sessionStorage!');
    }
    console.log('[AUTO-SAVE] Total KSATs:', Object.values(ksatData).reduce((sum, arr) => sum + arr.length, 0));
    console.log('[AUTO-SAVE] Total selected KSATs:', Object.values(allSelectValues).reduce((sum, cat) => sum + Object.keys(cat || {}).length, 0));
}

// Initialize allSelectValues from all checked checkboxes on page load
function initializeAllSelectValues() {
    console.log('[INIT] Initializing allSelectValues from checkboxes...');
    
    // Clear existing allSelectValues
    allSelectValues = {
        task: {},
        knowledge: {},
        skill: {},
        abilitie: {}
    };
    
    // For each category, find all checkboxes and add checked ones to allSelectValues
    ['task', 'knowledge', 'skill', 'abilitie'].forEach(category => {
        const tabContent = document.getElementById(category);
        if (!tabContent) {
            console.warn(`[INIT] Tab content not found for category: ${category}`);
            return;
        }
        
        const checkboxes = tabContent.querySelectorAll('.ksat-checkbox[data-category="' + category + '"]');
        console.log(`[INIT] Found ${checkboxes.length} checkboxes in ${category}`);
        
        let checkedCount = 0;
        checkboxes.forEach(checkbox => {
            if (checkbox.checked) {
                const ksatId = checkbox.getAttribute('data-ksat-id');
                if (ksatId) {
                    allSelectValues[category][ksatId] = {
                        primary: '1',
                        secondary: '',
                        tertiary: ''
                    };
                    checkedCount++;
                }
            }
        });
        
        console.log(`[INIT] Added ${checkedCount} checked KSATs to allSelectValues[${category}]`);
    });
    
    console.log('[INIT] allSelectValues initialized:', allSelectValues);
    console.log('[INIT] Total KSATs selected:', 
        Object.values(allSelectValues).reduce((sum, cat) => sum + Object.keys(cat).length, 0));
}

// Déclencher la sauvegarde automatique au chargement de la page (après un délai pour laisser le temps au DOM de se charger)
document.addEventListener('DOMContentLoaded', function() {
    // Initialize allSelectValues first, then auto-save
    // Use multiple attempts to ensure DOM is ready
    let attempts = 0;
    const maxAttempts = 5;
    
    function tryInitializeAndSave() {
        attempts++;
        console.log(`[INIT] Attempt ${attempts} to initialize allSelectValues...`);
        
        // Check if tab contents exist
        const taskTab = document.getElementById('task');
        const knowledgeTab = document.getElementById('knowledge');
        
        if (taskTab && knowledgeTab) {
            // DOM is ready, initialize and save
            console.log('[INIT] DOM ready, initializing allSelectValues...');
            initializeAllSelectValues();
            
            // Initialize allSelectValues (no auto-save, will be saved when clicking Step 3)
            console.log('[INIT] allSelectValues initialized');
        } else if (attempts < maxAttempts) {
            // DOM not ready yet, try again
            console.log(`[INIT] DOM not ready yet, retrying in 500ms... (attempt ${attempts}/${maxAttempts})`);
            setTimeout(tryInitializeAndSave, 500);
        } else {
            // Max attempts reached, try anyway
            console.warn('[INIT] Max attempts reached, initializing anyway...');
            initializeAllSelectValues();
            console.log('[INIT] allSelectValues initialized (max attempts)');
        }
    }
    
    // Start the initialization process
    setTimeout(tryInitializeAndSave, 500);
});

// Note: KSAT data is now saved only when clicking "Step 3" button (in checkAndGoToEtape2 function)
// No auto-save on checkbox changes
</script>
{% endblock %}

